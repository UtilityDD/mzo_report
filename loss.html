<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Parameters: Malda Zone</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
/* Base styles */
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start; /* Align to top to give space for sticky filters */
  font-family: 'Inter', sans-serif; /* Using Inter font */
  margin: 0;
  background-color: #f5f8fa;
  color: #333;
  padding-top: 10px; /* Add some padding at the top */
  min-height: 100vh; /* Ensure body takes full viewport height */
  overflow-y: auto; /* Allow scrolling for content */
}

h2 {
  text-align: center;
  color: #2c3e50;
  margin-bottom: 15px;
  font-weight: 700;
  font-size: 24px;
}

/* Button styles (toggle-filters-button removed) */
.toggle-button {
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 8px; /* More rounded corners */
  cursor: pointer;
  font-weight: 600;
  transition: background-color 0.2s, transform 0.2s;
  box-shadow: 0 2px 5px rgba(0,0,0,0.15); /* Stronger shadow */
  padding: 10px 15px;
  font-size: 14px;
}

.toggle-button:hover {
  background-color: #2980b9;
  transform: translateY(-1px); /* Slight lift effect */
}


/* Filters */
.filters-container {
  position: sticky;
  top: 0;
  z-index: 100;
  background-color: #f5f8fa;
  padding: 15px 0;
  border-bottom: 1px solid #e0e0e0;
  /* Removed max-height transition as it's always visible */
  margin-bottom: 15px;
  width: 100%;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05); /* Shadow for sticky effect */
}

/* Removed .filters-container.collapsed */

.filters {
  display: flex;
  gap: 20px; /* Increased gap */
  flex-wrap: wrap;
  padding: 10px;
  border-radius: 10px;
  width: 90%;
  max-width: 1200px; /* Increased max-width */
  justify-content: center;
  margin: 0 auto;
  background: #ffffff; /* White background for filter block */
  box-shadow: 0 1px 6px rgba(0, 0, 0, 0.08);
}

.filter-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
  flex: 1;
  min-width: 180px; /* Increased min-width */
}

.filter-group label {
  font-weight: 600;
  color: #2c3e50;
  font-size: 13px;
}

select {
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #ddd;
  background-color: white;
  font-size: 13px;
  appearance: none; /* Remove default arrow */
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23333333%22%20d%3D%22M287%2C197.3L159.2%2C69.5c-3.2-3.2-8.3-3.2-11.5%2C0L5.4%2C197.3c-3.2%2C3.2-3.2%2C8.3%2C0%2C11.5l15.3%2C15.3c3.2%2C3.2%2C8.3%2C3.2%2C11.5%2C0l116.5-116.5l116.5%2C116.5c3.2%2C3.2%2C8.3%2C3.2%2C11.5%2C0l15.3-15.3C290.2%2C205.6%2C290.2%2C200.5%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right 10px top 50%;
  background-size: 12px auto;
}

.checkbox-group {
  display: flex;
  flex-wrap: wrap;
  gap: 8px; /* Increased gap */
  max-height: 150px; /* Increased max-height */
  overflow-y: auto;
  padding-right: 5px; /* For scrollbar */
  border: 1px solid #eee;
  border-radius: 6px;
  padding: 8px;
  background-color: #fdfdfd;
}

.checkbox-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  background-color: #f0f8ff; /* Lighter background for checkboxes */
  border-radius: 5px;
  font-size: 12px;
  border: 1px solid #d0e1f2;
  white-space: nowrap;
  cursor: pointer;
  transition: background-color 0.2s;
}

.checkbox-item:hover {
  background-color: #e6f3ff;
}

.checkbox-item input[type="checkbox"] {
  margin: 0;
  width: 14px;
  height: 14px;
  accent-color: #3498db; /* Blue accent for checkboxes */
}

/* Tab container */
.tab-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto 20px auto;
  background: white;
  border-radius: 10px;
  box-shadow: 0 1px 6px rgba(0, 0, 0, 0.08);
  overflow: hidden; /* For rounded corners */
}

.tab-buttons {
  display: flex;
  border-bottom: 1px solid #e0e0e0;
}

.tab-button {
  flex: 1;
  padding: 15px 20px;
  background-color: #e9ecef; /* Lighter background for inactive tabs */
  border: none;
  font-size: 16px;
  font-weight: 600;
  color: #555;
  cursor: pointer;
  transition: all 0.3s ease;
  border-radius: 10px 10px 0 0; /* Rounded top corners */
  margin-right: 2px; /* Small gap between tabs */
  display: flex; /* Enable flex for content and icon */
  align-items: center;
  justify-content: center;
  position: relative; /* For positioning the icon */
}

.tab-button i { /* Style for icons within tabs */
    margin-right: 8px;
    font-size: 1.1em;
}

.tab-button:last-child {
  margin-right: 0;
}

.tab-button.active {
  background-color: #286090; /* Darker blue for active tab */
  color: white;
  box-shadow: inset 0 3px 0 0 #1d486e; /* Darker shadow for active tab */
}

.tab-button:hover:not(.active) {
  background-color: #dee2e6; /* Slightly darker hover for inactive */
  color: #3498db;
}

/* Filter clear icon */
.filter-clear-icon {
    margin-left: 8px;
    font-size: 18px; /* Larger for better tap target */
    line-height: 1;
    color: #e74c3c; /* Red color for clear action */
    cursor: pointer;
    position: absolute;
    right: 10px; /* Position to the right */
    top: 50%;
    transform: translateY(-50%);
    display: none; /* Hidden by default */
    background-color: rgba(255,255,255,0.8);
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    font-weight: bold;
}

.filter-clear-icon:hover {
    background-color: #f0f0f0;
    color: #c0392b;
}


.tab-content {
  padding: 20px;
}

/* Chart container */
.chart-container {
  padding: 10px;
  min-height: 350px; /* Slightly increased min-height */
  box-sizing: border-box;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative; /* For absolute positioning of message */
}

/* Chart message style */
#chartMessage {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.9);
    color: #555;
    font-size: 1.1em;
    font-weight: 500;
    text-align: center;
    border-radius: 8px;
    z-index: 5; /* Above canvas */
}


canvas {
  max-width: 100%;
  max-height: 700px; /* Increased max-height for desktop view */
}

/* Tooltip */
#differenceTooltip {
  position: absolute;
  background: rgba(255, 255, 255, 0.97);
  border: 1px solid #ddd;
  padding: 12px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.15);
  display: none;
  z-index: 1000;
  font-size: 12px;
  transition: opacity 0.3s ease, transform 0.3s ease;
  opacity: 0;
  transform: translateY(10px);
  max-width: 300px;
  pointer-events: none; /* Allow interaction with elements below */
}

#differenceTooltip.active {
  opacity: 1;
  transform: translateY(0);
}

#differenceTooltip .month-title {
  font-weight: 600;
  font-size: 13px;
  border-bottom: 1px solid #eee;
  padding-bottom: 8px;
  margin-bottom: 8px;
  color: #2c3e50;
}

#differenceTooltip .metric-title {
  font-weight: 600;
  color: #3498db;
  margin-top: 10px;
  margin-bottom: 5px;
}

#differenceTooltip .year-value {
  display: flex;
  justify-content: space-between;
  padding: 3px 0;
}

#differenceTooltip .diff-value {
  display: flex;
  justify-content: space-between;
  padding: 5px 0;
  margin-top: 3px;
  font-weight: 500;
}

#differenceTooltip hr {
  border: none;
  height: 1px;
  background-color: #eee;
  margin: 10px 0;
}

#differenceTooltip .increase {
  color: #e74c3c;
}

#differenceTooltip .decrease {
  color: #27ae60;
}

#differenceTooltip .neutral {
  color: #7f8c8d;
}

/* Table shared styles */
#dataTableWrapper, #regionTableWrapper {
  width: 100%; /* Full width within its container */
  margin-top: 20px; /* Space from chart */
  overflow-x: auto;
  background-color: #ffffff;
  border-radius: 8px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.05);
}

#dataTable, #regionTable {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
  min-width: 700px; /* Increased min-width for desktop */
}

#dataTable th, #dataTable td,
#regionTable th, #regionTable td {
  padding: 8px 12px; /* Increased padding */
  text-align: center;
  border: 1px solid #e0e0e0;
  font-size: 13px;
  white-space: nowrap;
}

#dataTable th:first-child, #dataTable td:first-child {
  position: sticky;
  left: 0;
  background-color: #f5f8fa;
  z-index: 2; /* Increased z-index for Sl. column */
  box-shadow: 2px 0 4px rgba(0,0,0,0.04);
  font-weight: 600;
  width: 1%;
}

/* New CSS for Unit column sticky behavior in regionTable */
#regionTable th:first-child, #regionTable td:first-child {
  position: sticky;
  left: 0;
  background-color: #e9f2fb; /* Match header background */
  z-index: 2; /* Ensure it's above other cells but below Sl. */
  box-shadow: 2px 0 4px rgba(0,0,0,0.04);
  font-weight: 600;
  width: 1%; /* Keep it narrow */
}

/* New CSS for Unit column sticky behavior in regionTable */
#regionTable th:nth-child(2), #regionTable td:nth-child(2) {
    position: sticky;
    left: 40px; /* Adjust based on the width of the first column (Sl.) */
    background-color: #f5f8fa; /* Match body background */
    z-index: 1; /* Ensure it's above other cells */
    box-shadow: 2px 0 4px rgba(0,0,0,0.04);
}


#dataTable th, #regionTable th {
  background-color: #e9f2fb; /* Light blue header */
  font-weight: 600;
  color: #2c3e50;
  padding: 10px;
}

#dataTable tr:hover, #regionTable tr:hover {
  background-color: #f0f8ff;
  transition: background-color 0.2s ease;
}

/* RegionTable specific styles */
#regionTable {
  border-collapse: separate;
  border-spacing: 0;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

#regionTable td {
  padding: 8px 10px;
  border: 1px solid #e5e5e5;
  transition: background-color 0.2s;
}

#regionTable tr:nth-child(even) {
  background-color: #f9f9f9;
}

#regionTable .positive, .positive {
  color: #e74c3c;
  font-weight: 500;
}

#regionTable .negative, .negative {
  color: #27ae60;
  font-weight: 500;
}

/* Expandable table (now for indentation only) */
.region-row {
  font-weight: 600;
  background-color: #f0f7ff;
  cursor: pointer; /* Add cursor for clickable rows */
}

.division-row {
  font-weight: 500;
  background-color: #f5f9ff;
  border-left: 3px solid #d6e9ff;
  cursor: pointer; /* Add cursor for clickable rows */
}

.ccc-row {
  font-weight: normal;
  background-color: #fafcff;
  border-left: 3px solid #ebf5ff;
  cursor: pointer; /* Add cursor for clickable rows */
}

.region-row:hover, .division-row:hover, .ccc-row:hover {
  background-color: #e6f3ff !important;
}

/* New styles for expanded row options */
.options-row td {
    padding: 10px;
    text-align: center;
    background-color: #e9f2fb; /* Lighter background for options */
    border-top: 1px solid #d0e1f2;
}

.options-row .option-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
}

.options-row .option-buttons button {
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 8px 15px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    transition: background-color 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.options-row .option-buttons button:hover {
    background-color: #2980b9;
}


/* Comparison specific styles */
.comparison-options {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 20px;
    padding: 15px;
    background-color: #f8fbfd;
    border-radius: 8px;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
    justify-content: center;
    align-items: center;
}

.comparison-option-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.comparison-option-group label {
    font-weight: 600;
    color: #2c3e50;
    font-size: 13px;
}

.comparison-option-group .radio-group {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.comparison-option-group .radio-item {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 13px;
    cursor: pointer;
}

.comparison-option-group input[type="radio"] {
    accent-color: #3498db;
    width: 14px;
    height: 14px;
}

.comparison-period-selectors {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.comparison-period-selectors .filter-group {
    flex: 1;
    min-width: 120px;
}

/* Comparison Sub-Tabs */
.comparison-sub-tabs {
    display: flex;
    border-bottom: 1px solid #e0e0e0;
    margin-bottom: 15px;
}

.comparison-sub-tab-button {
    flex: 1;
    padding: 10px 15px;
    background-color: #f0f0f0;
    border: none;
    font-size: 14px;
    font-weight: 500;
    color: #555;
    cursor: pointer;
    transition: all 0.2s ease;
    border-radius: 5px 5px 0 0;
    margin-right: 2px;
    display: flex; /* Enable flex for content and icon */
    align-items: center;
    justify-content: center;
    position: relative; /* For positioning the icon */
}

.comparison-sub-tab-button:last-child {
    margin-right: 0;
}

.comparison-sub-tab-button.active {
    background-color: #3498db;
    color: white;
    box-shadow: inset 0 2px 0 0 #2980b9;
}

.comparison-sub-tab-button:hover:not(.active) {
    background-color: #e9f2fb;
    color: #3498db;
}

/* Sortable column header */
.sortable-header {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
}

.sort-icon {
    font-size: 10px;
    line-height: 1;
}


/* Mobile adjustments */
@media (max-width: 768px) {
  h2 {
    font-size: 20px;
    margin-bottom: 10px;
  }

  .toggle-button, .toggle-filters-button {
    padding: 8px 12px;
    font-size: 12px;
  }

  .filters {
    gap: 10px;
    padding: 5px;
    width: 95%;
  }

  .filter-group {
    min-width: 120px;
  }

  .filter-group label, select, .checkbox-item {
    font-size: 11px;
  }

  .checkbox-group {
    max-height: 100px;
    gap: 4px;
    padding: 5px;
  }

  .checkbox-item {
    padding: 2px 5px;
  }

  .tab-button {
    padding: 12px 10px;
    font-size: 14px;
  }

  .tab-content {
    padding: 15px;
  }

  .chart-container {
    min-height: 250px;
  }

  #dataTable th, #dataTable td,
  #regionTable th, #regionTable td {
    font-size: 11px;
    padding: 6px 8px;
  }

  #dataTable, #regionTable {
    min-width: unset; /* Allow table to shrink */
  }

  /* Remove expand-icon specific styles if not needed */
  .expand-icon {
    display: none; /* Hide the icon on mobile if not used */
  }

  .comparison-options {
    flex-direction: column;
    gap: 10px;
    padding: 10px;
  }

  .comparison-period-selectors {
    flex-direction: column;
    gap: 8px;
    width: 100%;
  }

  .comparison-period-selectors .filter-group {
    min-width: unset;
    width: 100%;
  }
}

/* Loading animation styles */
.loader-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.9); /* Slightly transparent white */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999; /* Ensure it's on top of everything */
    transition: opacity 0.3s ease-in-out;
    opacity: 1;
    visibility: visible;
}

.loader-overlay.hidden {
    opacity: 0;
    visibility: hidden; /* Added this line */
    pointer-events: none; /* Allow clicks through once hidden */
}

.spinner {
    border: 8px solid #f3f3f3; /* Light grey */
    border-top: 8px solid #3498db; /* Blue */
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div id="loaderOverlay" class="loader-overlay">
        <div class="spinner"></div>
    </div>

    <h2>Performance Parameters: Malda Zone</h2>
    <!-- Removed toggle-filters-button -->
    <div class="filters-container">
        <div class="filters">
            <div class="filter-group">
                <label>Parameters:</label>
                <div id="parameterCheckboxes" class="checkbox-group"></div>
            </div>
        </div>
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" onclick="showTab('chartTab')"><i class="fas fa-chart-line"></i> Chart</button>
            <button class="tab-button" onclick="showTab('comparisonTab')"><i class="fas fa-exchange-alt"></i> Comparison</button>
        </div>

        <div id="chartTab" class="tab-content">
            <div class="chart-filters" style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px; justify-content: center;">
                <div class="filter-group">
                    <label for="cccFilter">Select Unit / Office:</label>
                    <select id="cccFilter"></select>
                </div>
                <div class="filter-group">
                    <label>Year:</label>
                    <div id="yearCheckboxes" class="checkbox-group"></div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="chart"></canvas>
                <div id="chartMessage" style="display:none;"></div>
            </div>
            <button onclick="toggleTable()" class="toggle-button">Data Table</button>
            <div id="dataTableWrapper">
                <table id="dataTable" border="1">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="comparisonTab" class="tab-content" style="display:none;">
            <div class="comparison-options">
                <div class="comparison-option-group">
                    <label>Compare By:</label>
                    <div class="radio-group">
                        <div class="radio-item">
                            <input type="radio" id="compareCustom" name="compareOption" value="custom">
                            <label for="compareCustom">Custom Dates</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="compareLastMonth" name="compareOption" value="lastMonth">
                            <label for="compareLastMonth">vs. Last Month</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="compareLastMarch" name="compareOption" value="lastMarch" checked>
                            <label for="compareLastMarch">vs. Last March</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="comparePrevYear" name="compareOption" value="prevYear">
                            <label for="comparePrevYear">vs. This Month Previous Year</label>
                        </div>
                    </div>
                </div>
                <div class="comparison-period-selectors" id="customPeriodSelectors" style="display:none;">
                    <div class="filter-group">
                        <label for="regionMonthSelect1">Period 1:</label>
                        <div style="display:flex;gap:4px;">
                            <select id="regionMonthSelect1" onchange="updateRegionTable()" style="flex:1"></select>
                            <select id="regionYearSelect1" onchange="updateRegionTable()" style="flex:1"></select>
                        </div>
                    </div>
                    <div class="filter-group">
                        <label for="regionMonthSelect2">Period 2:</label>
                        <div style="display:flex;gap:4px;">
                            <select id="regionMonthSelect2" onchange="updateRegionTable()" style="flex:1"></select>
                            <select id="regionYearSelect2" onchange="updateRegionTable()" style="flex:1"></select>
                        </div>
                    </div>
                </div>
            </div>

            <div class="comparison-sub-tabs">
                <button class="comparison-sub-tab-button" onclick="showComparisonSubTab('region')">Region</button>
                <button class="comparison-sub-tab-button" onclick="showComparisonSubTab('division')">
                    Division <span id="divisionFilterIcon" class="filter-clear-icon">✖</span>
                </button>
                <button class="comparison-sub-tab-button" onclick="showComparisonSubTab('ccc')">
                    CCC <span id="cccFilterIcon" class="filter-clear-icon">✖</span>
                </button>
            </div>

            <div id="regionTableWrapper">
                <table id="regionTable" border="1">
                    <thead>
                        <tr>
                            <th>Sl.</th> <!-- Added Serial Number header -->
                            <th>Unit</th>
                            <th id="period1Header">Period 1</th>
                            <th id="period2Header">Period 2</th>
                            <th id="changeHeader" class="sortable-header" onclick="toggleSort('difference')">
                                Change <span id="changeSortIcon" class="sort-icon"></span>
                            </th>
                            <th id="changePercentHeader" class="sortable-header" onclick="toggleSort('percentDiff')">
                                Change % <span id="percentSortIcon" class="sort-icon"></span>
                            </th>
                            <th>Target</th> <!-- New: Target column header -->
                            <th>Diff (vs. Target)</th> <!-- New: Diff (vs. Target) column header -->
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="differenceTooltip"></div>

    <script>
        const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSYyqn0urGdbqXarhELRbSCeRvgUCSHID_1Z4E_kptBTR5u69R0HHX0Jk23n6KseriNct2q9XwXu04E/pub?output=csv";
        const targetCsvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSYyqn0urGdbqXarhELRbSCeRvgUCSHID_1Z4E_kptBTR5u69R0HHX0Jk23n6KseriNct2q9XwXu04E/pub?gid=2042465667&single=true&output=csv";

        let rawData = [];
        let targetDataRaw = []; // Will store raw target data
        let targetDataMap = {}; // Processed target data for easy lookup: { 'CCC_NAME': { 'PARAMETER_NAME': TARGET_VALUE, ... }, ... }

        let chart;
        const monthNames = ["Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "Jan", "Feb", "Mar"];
        const parameters = ["CUM. INPUT (MU)", "CUM. DEMAND(MU)", "CUM. COLLEC. (MU)", "CUM. AT&C LOSS", "CUM. DIST. LOSS", "COLL. EFF."];
        const parameterDisplayMap = {
            "CUM. INPUT (MU)": "Input",
            "CUM. DEMAND(MU)": "Demand",
            "CUM. COLLEC. (MU)": "Collection",
            "CUM. AT&C LOSS": "AT&C Loss",
            "CUM. DIST. LOSS": "T&D Loss",
            "COLL. EFF.": "Collection Efficiency"
        };
        const parametersToHideChangePercent = ["CUM. AT&C LOSS", "CUM. DIST. LOSS", "COLL. EFF."];
        // Define parameters where an increase is considered good (e.g., Demand, Collection, Efficiency)
        const parametersGoodWhenIncreasing = ["CUM. DEMAND(MU)", "CUM. COLLEC. (MU)", "COLL. EFF."];
        // Define parameters where a decrease is considered good (e.g., AT&C Loss, T&D Loss, Input)
        const parametersGoodWhenDecreasing = ["CUM. INPUT (MU)", "CUM. AT&C LOSS", "CUM. DIST. LOSS"];


        let chartData = {}; // Stores data for the chart, used for hover comparison
        let tooltipTimeout = null;
        let currentActiveTab = 'chartTab'; // Track the currently active main tab
        let currentComparisonSubTab = 'division'; // Track the currently active comparison sub-tab - Changed to 'division'
        let currentSortColumn = null; // 'difference' or 'percentDiff'
        let currentSortOrder = 'none'; // 'asc', 'desc', 'none'
        let expandedRowOptions = null; // To keep track of the currently expanded options row (either region or division)
        let selectedCCC = ""; // Global variable to store the currently selected CCC for tooltip access

        // Global variables for filtering comparison table rows
        let currentRegionFilter = null;
        let currentDivisionFilter = null;

        // Hierarchy data for expandable table
        const hierarchyData = {
            "MALDA REGION": {
                divisions: ["South Malda Div Total", "North Malda Div Total", "Gazole Div Total", "Chanchal Div Total", "Malda Div Total"],
                cccs: {
                    "South Malda Div Total": ["RATHBARI", "FULBARI", "MOKDAMPUR", "OLD MALDA", "KALIACHAK", "SUJAPUR", "AIHO", "MOTHABARI", "MATHURAPUR", "BAISNABNAGAR", "GOLAPGANJ"],
                    "North Malda Div Total": ["SAMSI", "PARANPUR", "GAZOLE", "CHANCHAL", "H.C. PUR", "BHALUKA", "BAMANGOLA", "MALATIPUR", "KUSHIDA", "PANDUA"],
                    "Gazole Div Total": ["OLD MALDA", "AIHO", "GAZOLE", "BAMANGOLA", "PANDUA"],
                    "Chanchal Div Total": ["SAMSI", "PARANPUR", "CHANCHAL", "H.C. PUR", "BHALUKA", "MALATIPUR", "KUSHIDA"],
                    "Malda Div Total": ["RATHBARI", "FULBARI", "MOKDAMPUR", "KALIACHAK", "SUJAPUR", "MOTHABARI", "MATHURAPUR", "BAISNABNAGAR", "GOLAPGANJ"]
                }
            },
            "U/DINAJPUR REGION": {
                divisions: ["Raiganj Div Total", "Islampur Div Total"],
                cccs: {
                    "Raiganj Div Total": ["RAIGANJ", "KALIAGANJ", "HEMTABAD", "BIRNAGAR", "ITAHAR", "KARANDEGHI"],
                    "Islampur Div Total": ["DALKHOLA", "KANKI", "GOALPOKHAR", "ISLAMPUR", "CHOPRA"]
                }
            },
            "D/DINAJPUR REGION": {
                divisions: ["Balurghat Div Total", "Buniadpur Div Total"],
                cccs: {
                    "Balurghat Div Total": ["BALURGHAT", "HILI", "KUMARGUNJ", "TAPAN", "PATIRAM"],
                    "Buniadpur Div Total": ["BUNIADPUR", "HARIRAMPUR", "GANGARAMPUR", "KUSHMUNDI"]
                }
            }
        };

        const monthNumToNameMap = {
            1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun",
            7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"
        };
        const monthNameToNumMap = {
            "Jan": 1, "Feb": 2, "Mar": 3, "Apr": 4, "May": 5, "Jun": 6,
            "Jul": 7, "Aug": 8, "Sep": 9, "Oct": 10, "Nov": 11, "Dec": 12
        };

        // --- Loader Functions ---
        function showLoader() {
            document.getElementById('loaderOverlay').classList.remove('hidden');
        }

        function hideLoader() {
            document.getElementById('loaderOverlay').classList.add('hidden');
        }

        // --- Color Palettes ---
        // Fixed contrasting colors for different years (when only one parameter is selected)
        const YEAR_COLORS = [
            '#4e79a7', // Muted Blue
            '#f28e2b', // Orange
            '#e15759', // Red
            '#76b7b2', // Teal
            '#59a14f', // Green
            '#edc948', // Yellow
            '#af7aa1', // Purple
            '#ff9da7', // Pink
            '#9c755f', // Brown
            '#bab0ac'  // Grey
        ];

        // Fixed contrasting colors for different parameters (when multiple parameters are selected)
        const PARAMETER_COLORS = {
            "CUM. INPUT (MU)": '#3498DB',     // Bright Blue
            "CUM. DEMAND(MU)": '#9B59B6',     // Bright Purple
            "CUM. COLLEC. (MU)": '#2ECC71',   // Bright Green
            "CUM. AT&C LOSS": '#E74C3C',      // Bright Red
            "CUM. DIST. LOSS": '#F1C40F',     // Bright Yellow
            "COLL. EFF.": '#1ABC9C'           // Bright Turquoise
        };

        // Helper function to convert HEX to HSL
        function hexToHsl(hex) {
            let r = 0, g = 0, b = 0;
            // Handle short hex codes (e.g., #F00)
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            r /= 255;
            g /= 255;
            b /= 255;

            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }

        // Helper function to convert HSL to RGB
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            let r, g, b;

            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // Function to adjust color (brightness and opacity) based on year's position
        function adjustColorForYear(hexColor, yearIndex, numYears) {
            if (numYears <= 1) {
                return hexColor; // No adjustment needed for single year
            }

            let [h, s, l] = hexToHsl(hexColor); // l is 0-100 here

            // Define desired range for opacity (older -> newer)
            const minOpacity = 0.5; // More transparent for older years
            const maxOpacity = 1.0; // Fully opaque for newer years

            // Define desired range for lightness (older -> newer)
            const minLightness = 30; // Darker for newer years
            const maxLightness = 75; // Lighter for older years

            // Calculate opacity: increase opacity linearly from oldest to newest
            const opacity = minOpacity + (yearIndex / (numYears - 1)) * (maxOpacity - minOpacity);

            // Calculate lightness: decrease lightness linearly from oldest to newest (making them darker)
            const lightness = maxLightness - (yearIndex / (numYears - 1)) * (maxLightness - minLightness);
            
            // Ensure lightness stays within valid HSL range (0-100)
            const adjustedL = Math.max(0, Math.min(100, lightness));

            const [r, g, b] = hslToRgb(h, s, adjustedL);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }


        // --- Data Fetching and Filter Population ---
        function fetchCSV() {
            showLoader(); // Show loader when fetching starts
            Promise.all([
                new Promise(resolve => {
                    Papa.parse(csvUrl, {
                        download: true,
                        header: true,
                        complete: function(results) {
                            rawData = results.data.filter(row => row.CCC && row.YEAR && row.MONTH);
                            resolve();
                        }
                    });
                }),
                new Promise(resolve => {
                    Papa.parse(targetCsvUrl, {
                        download: true,
                        header: true,
                        complete: function(results) {
                            targetDataRaw = results.data.filter(row => row.CCC); // Filter out rows with missing CCC
                            // Populate targetDataMap for quick lookup
                            targetDataRaw.forEach(row => {
                                const cccName = row.CCC.trim();
                                targetDataMap[cccName] = {};
                                parameters.forEach(param => {
                                    if (row[param] && !isNaN(parseFloat(row[param]))) {
                                        targetDataMap[cccName][param] = parseFloat(row[param]);
                                    }
                                });
                            });
                            resolve();
                        }
                    });
                })
            ]).then(() => {
                populateCCCFilter();
                generateYearCheckboxes();
                generateParameterCheckboxes();
                initializeComparisonFilters(); // Initialize comparison dropdowns
                showTab('comparisonTab'); // Show comparison tab by default
                document.getElementById('compareLastMarch').checked = true; // Select "vs. Last March"
                showComparisonSubTab('division'); // Show division view by default in comparison tab
                updateChart(); // Initial chart load for chart tab. Call after everything is set up.
                hideLoader(); // Hide loader after all initial data and UI is rendered
            }).catch(error => {
                console.error("Error fetching CSV data:", error);
                hideLoader(); // Hide loader even on error
                // Optionally display an error message to the user
                document.getElementById("chartMessage").style.display = 'flex';
                document.getElementById("chartMessage").innerHTML = "Failed to load data. Please check the console for errors.";
            });
        }

        function populateCCCFilter() {
            const cccFilter = document.getElementById("cccFilter");
            // Collect all unique CCCs, including regions and divisions, for the filter
            const allUniqueUnits = new Set();
            rawData.forEach(row => {
                if (row.CCC) allUniqueUnits.add(row.CCC.trim());
            });
            Object.keys(hierarchyData).forEach(region => allUniqueUnits.add(region));
            Object.values(hierarchyData).forEach(regionObj => {
                regionObj.divisions.forEach(div => allUniqueUnits.add(div));
            });

            const sortedUnits = [...allUniqueUnits].filter(unit => unit && unit !== "").sort((a, b) => a.localeCompare(b));

            cccFilter.innerHTML = `<option value="" disabled selected>--Select Office--</option>` +
                                  sortedUnits.map(ccc => `<option value="${ccc}">${ccc}</option>`).join('');

            cccFilter.addEventListener("change", () => {
                if (currentActiveTab === 'chartTab') {
                    updateChart();
                } else {
                    updateRegionTable();
                }
            });
        }

        function generateYearCheckboxes() {
            const years = [...new Set(rawData
                .map(row => row.YEAR)
                .filter(year => year && !isNaN(parseInt(year)))
            )];
            years.sort((a, b) => a - b); // Sort years in ascending order (chronological)

            const container = document.getElementById("yearCheckboxes");
            container.innerHTML = years.map(year =>
                `<div class="checkbox-item">
                    <input type="checkbox" id="year-${year}" value="${year}" checked>
                    <label for="year-${year}">${year}-${(parseInt(year) + 1).toString().slice(-2)}</label>
                </div>`
            ).join('');
            container.addEventListener("change", () => {
                if (currentActiveTab === 'chartTab') {
                    updateChart();
                } else {
                    // No year filter in comparison tab, so no action needed here
                }
            });
        }

        function generateParameterCheckboxes() {
            const container = document.getElementById("parameterCheckboxes");
            container.innerHTML = parameters.map(param =>
                `<div class="checkbox-item">
                    <input type="checkbox" id="param-${param.replace(/\s+/g, '-').replace(/[()]/g, '')}" value="${param}" ${param === "CUM. AT&C LOSS" ? "checked" : ""}>
                    <label for="param-${param.replace(/\s+/g, '-').replace(/[()]/g, '')}">${parameterDisplayMap[param]}</label>
                </div>`
            ).join('');

            // Add a new event listener specifically for single selection in comparison tab
            container.addEventListener("change", (event) => {
                if (currentActiveTab === 'comparisonTab') {
                    const clickedCheckbox = event.target;
                    if (clickedCheckbox.type === 'checkbox' && clickedCheckbox.checked) {
                        // Uncheck all other checkboxes in the same group
                        container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                            if (checkbox !== clickedCheckbox) {
                                checkbox.checked = false;
                            }
                        });
                    } else if (clickedCheckbox.type === 'checkbox' && !clickedCheckbox.checked) {
                        // If the only checked checkbox is unchecked, re-check it to ensure at least one is always selected
                        const checkedCount = container.querySelectorAll('input[type="checkbox"]:checked').length;
                        if (checkedCount === 0) {
                            clickedCheckbox.checked = true; // Prevent all from being unchecked
                        }
                    }
                }

                // Always update the relevant tab content
                if (currentActiveTab === 'chartTab') {
                    updateChart();
                } else {
                    updateRegionTable();
                }
            });
        }

        // --- Chart Functions ---
        function updateChart() {
            selectedCCC = document.getElementById("cccFilter").value; // Assign to global variable
            const selectedYears = [...document.querySelectorAll("#yearCheckboxes input:checked")].map(cb => cb.value);
            selectedYears.sort((a, b) => parseInt(a) - parseInt(b)); // Sort years for consistent color assignment
            const selectedParameters = [...document.querySelectorAll("#parameterCheckboxes input:checked")].map(cb => cb.value);
            const chartCanvas = document.getElementById("chart");
            const chartMessageDiv = document.getElementById("chartMessage");
            const dataTableBody = document.getElementById("dataTable").querySelector("tbody");

            // Case 1: No office selected
            if (!selectedCCC) {
                if (chart) chart.destroy(); // Destroy existing chart
                chartCanvas.style.display = 'none'; // Hide canvas
                chartMessageDiv.style.display = 'flex'; // Show message
                chartMessageDiv.innerHTML = "Please select a Unit / Office to view chart data.";
                dataTableBody.innerHTML = ""; // Clear data table
                return;
            }

            // Case 2: Office selected, but no years or parameters
            if (selectedYears.length === 0 || selectedParameters.length === 0) {
                if (chart) chart.destroy();
                chartCanvas.style.display = 'none';
                chartMessageDiv.style.display = 'flex';
                chartMessageDiv.innerHTML = "Please select at least one Year and at least one Parameter to view chart data.";
                dataTableBody.innerHTML = "<tr><td colspan='100%'>Please select at least one Year and at least one Parameter to view data table.</td></tr>";
                return;
            }

            // Case 3: All selections made, proceed with chart and table rendering
            chartCanvas.style.display = 'block'; // Show canvas
            chartMessageDiv.style.display = 'none'; // Hide message

            const labels = monthNames;
            const datasets = [];
            chartData = {}; // Reset chart data for hover comparison

            const isParamColoringMode = selectedParameters.length > 1;

            selectedParameters.forEach((metric) => {
                if (!chartData[metric]) chartData[metric] = {};

                // Add datasets for actual data
                selectedYears
                    .filter(y => y && !isNaN(parseInt(y)))
                    .forEach((year, yearIndex) => {
                        if (!chartData[metric][year]) chartData[metric][year] = {}; // Initialize inner object

                        let baseColor;
                        if (!isParamColoringMode) {
                            // Scenario 1: One parameter selected, use year-specific fixed colors
                            baseColor = YEAR_COLORS[yearIndex % YEAR_COLORS.length];
                        } else {
                            // Scenario 2: Multiple parameters selected, use parameter-specific fixed colors
                            baseColor = PARAMETER_COLORS[metric] || '#000000'; // Fallback to black
                        }

                        // Adjust color (brightness and opacity) based on the year's position
                        const lineColor = adjustColorForYear(baseColor, yearIndex, selectedYears.length);
                        const dataLabelColor = lineColor; // Data labels match line color

                        datasets.push({
                            label: `${parameterDisplayMap[metric]} (${year}-${(parseInt(year) + 1).toString().slice(-2)})`,
                            data: labels.map((_, index) => {
                                const fiscalMonthNum = [4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3][index];
                                const actualYearForMonth = (fiscalMonthNum >= 4) ? parseInt(year) : parseInt(year) + 1;

                                const entry = rawData.find(row =>
                                    row.CCC === selectedCCC &&
                                    parseInt(row.MONTH) === fiscalMonthNum &&
                                    parseInt(row.YEAR) === actualYearForMonth
                                );

                                const value = entry ? parseFloat(entry[metric]) : null;
                                if (value !== null) {
                                    chartData[metric][year][fiscalMonthNum] = value;
                                }
                                return value;
                            }),
                            borderColor: lineColor,
                            backgroundColor: lineColor, // For point fill
                            pointBackgroundColor: lineColor,
                            pointBorderColor: "#fff",
                            pointRadius: window.innerWidth <= 768 ? 3 : 5,
                            pointHoverRadius: window.innerWidth <= 768 ? 4 : 7,
                            borderWidth: window.innerWidth <= 768 ? 1.5 : 3,
                            pointBorderWidth: window.innerWidth <= 768 ? 1 : 2,
                            tension: 0.4,
                            fill: false,
                            metric: metric,
                            year: year,
                            datalabels: {
                                align: 'top',
                                anchor: 'end',
                                formatter: (value) => value ? `${value.toFixed(1)}` : '',
                                color: dataLabelColor,
                                backgroundColor: 'rgba(255, 255, 255, 0.8)',
                                borderRadius: 4,
                                padding: { top: 2, bottom: 2, left: 2, right: 2 },
                                font: {
                                    weight: 'normal',
                                    size: window.innerWidth <= 768 ? 9 : 12,
                                }
                            }
                        });
                    });

                // Add dataset for target line if target exists for this CCC and metric
                const targetValue = targetDataMap[selectedCCC]?.[metric];
                if (targetValue !== undefined && targetValue !== null) {
                    datasets.push({
                        label: `${parameterDisplayMap[metric]} Target`,
                        data: Array(labels.length).fill(targetValue), // Horizontal line
                        borderColor: PARAMETER_COLORS[metric] || '#000000', // Use parameter color
                        backgroundColor: PARAMETER_COLORS[metric] || '#000000',
                        borderDash: [5, 5], // Dashed line for target
                        pointRadius: 0, // No points for target line
                        pointHoverRadius: 0,
                        borderWidth: window.innerWidth <= 768 ? 1 : 2,
                        fill: false,
                        metric: metric, // Keep metric for tooltip if needed, though target is simpler
                        isTarget: true, // Custom property to identify target line
                        datalabels: {
                            display: false // No datalabels for target line
                        }
                    });
                }
            });

            renderChart(labels, datasets);
            updateDataTable();
        }

        function renderChart(labels, datasets) {
            if (chart) chart.destroy();
            const ctx = document.getElementById("chart").getContext("2d");
            const tooltipEl = document.getElementById('differenceTooltip');

            tooltipEl.style.display = 'none';
            tooltipEl.classList.remove('active');

            chart = new Chart(ctx, {
                type: "line",
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: window.innerWidth <= 768
                            ? { left: 5, right: 5, top: 30, bottom: 5 }
                            : { left: 10, right: 10, top: 40, bottom: 10 }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    onHover: function(event, elements) {
                        if (elements && elements.length) {
                            document.getElementById('chart').style.cursor = 'pointer';
                        } else {
                            document.getElementById('chart').style.cursor = 'default';
                            if (tooltipTimeout) clearTimeout(tooltipTimeout);
                            tooltipTimeout = setTimeout(() => {
                                tooltipEl.classList.remove('active');
                                setTimeout(() => { tooltipEl.style.display = 'none'; }, 300);
                            }, 100);
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                boxWidth: 12,
                                usePointStyle: true,
                                pointStyle: 'circle',
                                padding: 9,
                                font: { size: window.innerWidth <= 768 ? 9 : 12 }
                            }
                        },
                        tooltip: {
                            enabled: false,
                            mode: 'index',
                            intersect: false,
                            external: function(context) {
                                if (tooltipTimeout) clearTimeout(tooltipTimeout);
                                if (context.tooltip.opacity === 0) {
                                    tooltipTimeout = setTimeout(() => {
                                        tooltipEl.classList.remove('active');
                                        setTimeout(() => { tooltipEl.style.display = 'none'; }, 300);
                                    }, 100);
                                    return;
                                }

                                tooltipEl.style.display = 'block';
                                setTimeout(() => {
                                    const position = context.chart.canvas.getBoundingClientRect();
                                    tooltipEl.style.left = position.left + window.pageXOffset + context.tooltip.caretX + 'px';
                                    tooltipEl.style.top = position.top + window.pageYOffset + context.tooltip.caretY + 'px';
                                    tooltipEl.classList.add('active');
                                }, 10);

                                const activeElements = context.tooltip.dataPoints;
                                if (activeElements.length < 1) return;

                                const metricGroups = {};
                                activeElements.forEach(element => {
                                    const dataset = context.chart.data.datasets[element.datasetIndex];
                                    const metric = dataset.metric;
                                    // Only include actual data points in year-on-year comparison
                                    if (!dataset.isTarget) {
                                        const year = dataset.year;
                                        if (!metricGroups[metric]) metricGroups[metric] = [];
                                        metricGroups[metric].push({
                                            year: year,
                                            value: element.raw,
                                            datasetIndex: element.datasetIndex
                                        });
                                    }
                                });

                                const monthIndex = context.tooltip.dataPoints[0].dataIndex;
                                const displayMonth = monthNames[monthIndex];
                                let tooltipContent = `<div class="month-title">${displayMonth}</div>`;

                                Object.keys(metricGroups).forEach(metric => {
                                    const points = metricGroups[metric];
                                    if (points.length < 1) return; // Should be at least one point

                                    tooltipContent += `<div class="metric-title">${parameterDisplayMap[metric]}</div>`;

                                    // Display actual values for each year
                                    points.forEach(point => {
                                        if (point.value !== null) {
                                            tooltipContent += `<div class="year-value">
                                                <span>${point.year}:</span>
                                                <span>${point.value.toFixed(2)}</span>
                                            </div>`;
                                        }
                                    });

                                    // Get target value for this metric and selected CCC
                                    const targetValue = targetDataMap[selectedCCC]?.[metric];
                                    if (targetValue !== undefined && targetValue !== null) {
                                        tooltipContent += `<div class="year-value">
                                            <span>Target:</span>
                                            <span>${targetValue.toFixed(2)}</span>
                                        </div>`;

                                        // Compare each actual value against the target
                                        points.forEach(point => {
                                            if (point.value !== null) {
                                                const difference = point.value - targetValue;
                                                const percentChange = (targetValue !== 0) ? (difference / Math.abs(targetValue)) * 100 : 0;

                                                let cssClass = "";
                                                if (parametersGoodWhenIncreasing.includes(metric)) {
                                                    cssClass = difference > 0 ? 'negative' : difference < 0 ? 'positive' : 'neutral';
                                                } else if (parametersGoodWhenDecreasing.includes(metric)) { // Added this condition
                                                    cssClass = difference < 0 ? 'negative' : difference > 0 ? 'positive' : 'neutral';
                                                } else {
                                                    cssClass = 'neutral'; // Default if not in either good-when-increasing/decreasing
                                                }
                                                const symbol = difference > 0 ? '↑' : difference < 0 ? '↓' : '→';

                                                tooltipContent += `<div class="diff-value ${cssClass}">
                                                    <span>${point.year} vs Target:</span>
                                                    <span>${difference.toFixed(2)} ${symbol} (${percentChange.toFixed(1)}%)</span>
                                                </div>`;
                                            }
                                        });
                                    }

                                    // Add year-on-year comparison (existing logic)
                                    for (let i = 0; i < points.length - 1; i++) {
                                        for (let j = i + 1; j < points.length; j++) {
                                            const pointA = points[i];
                                            const pointB = points[j];
                                            if (pointA.value !== null && pointB.value !== null) {
                                                const difference = pointB.value - pointA.value;
                                                const percentChange = (pointA.value !== 0) ? (difference / Math.abs(pointA.value)) * 100 : 0;

                                                const cssClass = difference > 0 ? 'increase' : difference < 0 ? 'decrease' : 'neutral';
                                                const symbol = difference > 0 ? '↑' : difference < 0 ? '↓' : '→';

                                                tooltipContent += `<div class="diff-value ${cssClass}">
                                                    <span>${pointB.year} - ${pointA.year}:</span>
                                                    <span>${difference.toFixed(2)} ${symbol} (${percentChange.toFixed(1)}%)</span>
                                                </div>`;
                                            }
                                        }
                                    }
                                    tooltipContent += '<hr>';
                                });
                                tooltipEl.innerHTML = tooltipContent;
                            }
                        },
                        datalabels: {
                            display: true,
                            clip: false
                        }
                    },
                    scales: {
                        x: {
                            title: { display: false },
                            grid: { display: true, color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: { font: { size: window.innerWidth <= 768 ? 10 : 12 } }
                        },
                        y: {
                            title: { display: false },
                            suggestedMax: 1.03,
                            grid: { display: true, color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: { font: { size: window.innerWidth <= 768 ? 10 : 12 } }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function toggleTable() {
            const wrapper = document.getElementById("dataTableWrapper");
            wrapper.style.display = wrapper.style.display === "none" ? "block" : "none";
        }

        function updateDataTable() {
            const table = document.getElementById("dataTable");
            const selectedCCC = document.getElementById("cccFilter").value;
            const selectedParameters = [...document.querySelectorAll("#parameterCheckboxes input:checked")].map(cb => cb.value);
            const selectedYears = [...document.querySelectorAll("#yearCheckboxes input:checked")].map(cb => cb.value);
            selectedYears.sort((a, b) => parseInt(a) - parseInt(b));

            const latestSelectedYear = selectedYears.length > 0 ? selectedYears[selectedYears.length - 1] : null;

            let thead = "<tr><th>Sl.</th><th>Month</th>";
            selectedParameters.forEach(param => {
                selectedYears.forEach(year => {
                    thead += `<th>${parameterDisplayMap[param]}<br>(${year}-${(parseInt(year) + 1).toString().slice(-2)})</th>`;
                });
                thead += `<th>${parameterDisplayMap[param]} Target</th>`;
                
                if (latestSelectedYear) {
                    thead += `<th>Diff (vs. Target)</th>`;
                }
            });
            thead += "</tr>";
            table.querySelector("thead").innerHTML = thead;

            const fiscalMonthOrder = [4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3];
            let tbody = "";
            for (let i = 0; i < 12; i++) {
                const monthNum = fiscalMonthOrder[i];
                const monthLabel = monthNames[i];
                let row = `<tr><td>${i + 1}</td><td>${monthLabel}</td>`;
                selectedParameters.forEach(param => {
                    selectedYears.forEach(year => {
                        const actualValue = chartData[param]?.[year]?.[monthNum];
                        const previousYear = parseInt(year) - 1;
                        const actualValuePreviousYear = chartData[param]?.[previousYear.toString()]?.[monthNum];

                        let prevYearDiffHtml = "";
                        if (actualValue != null && !isNaN(actualValue) && actualValuePreviousYear != null && !isNaN(actualValuePreviousYear)) {
                            const diffFromPrevYear = actualValue - actualValuePreviousYear;
                            let diffClass = "";
                            if (parametersGoodWhenIncreasing.includes(param)) {
                                diffClass = diffFromPrevYear > 0 ? "negative" : diffFromPrevYear < 0 ? "positive" : "neutral";
                            } else if (parametersGoodWhenDecreasing.includes(param)) {
                                diffClass = diffFromPrevYear < 0 ? "negative" : diffFromPrevYear > 0 ? "positive" : "neutral";
                            } else {
                                diffClass = 'neutral';
                            }
                            prevYearDiffHtml = `<span style="font-size: 0.8em;" class="${diffClass}"> (${diffFromPrevYear.toFixed(2)})</span>`;
                        }
                        
                        row += `<td>${actualValue != null ? actualValue.toFixed(2) : "-"} ${prevYearDiffHtml}</td>`;
                    });

                    const targetValue = targetDataMap[selectedCCC]?.[param];

                    row += `<td>${targetValue != null ? targetValue.toFixed(2) : "-"}</td>`;

                    if (latestSelectedYear) {
                        const actualValueForLatestYear = chartData[param]?.[latestSelectedYear]?.[monthNum];
                        let diffTargetVsLatestFY = null;
                        let diffTargetVsLatestFYClass = "";

                        if (actualValueForLatestYear != null && targetValue != null) {
                            diffTargetVsLatestFY = actualValueForLatestYear - targetValue;
                            if (parametersGoodWhenIncreasing.includes(param)) {
                                diffTargetVsLatestFYClass = diffTargetVsLatestFY > 0 ? "negative" : diffTargetVsLatestFY < 0 ? "positive" : "";
                            } else if (parametersGoodWhenDecreasing.includes(param)) {
                                diffTargetVsLatestFYClass = diffTargetVsLatestFY < 0 ? "negative" : diffTargetVsLatestFY > 0 ? "positive" : "";
                            } else {
                                diffTargetVsLatestFYClass = 'neutral';
                            }
                        }
                        row += `<td class="${diffTargetVsLatestFYClass}">${diffTargetVsLatestFY != null && !isNaN(diffTargetVsLatestFY) ? diffTargetVsLatestFY.toFixed(2) : "-"}</td>`;
                    }
                });
                row += "</tr>";
                tbody += row;
            }
            table.querySelector("tbody").innerHTML = tbody;
        }

        // --- Comparison Tab Functions ---
        function initializeComparisonFilters() {
            const monthSelect1 = document.getElementById("regionMonthSelect1");
            const monthSelect2 = document.getElementById("regionMonthSelect2");
            const yearSelect1 = document.getElementById("regionYearSelect1");
            const yearSelect2 = document.getElementById("regionYearSelect2");

            monthNames.forEach((month, index) => {
                const option1 = document.createElement("option");
                option1.value = index;
                option1.textContent = month;
                monthSelect1.appendChild(option1);

                const option2 = document.createElement("option");
                option2.value = index;
                option2.textContent = month;
                monthSelect2.appendChild(option2);
            });

            const years = [...new Set(rawData.map(row => row.YEAR).filter(year => year && !isNaN(parseInt(year))))].sort((a, b) => b - a);
            years.forEach(year => {
                const option1 = document.createElement("option");
                option1.value = year;
                option1.textContent = year;
                yearSelect1.appendChild(option1);

                const option2 = document.createElement("option");
                option2.value = year;
                option2.textContent = year;
                yearSelect2.appendChild(option2);
            });

            // Determine the latest month and year from rawData for initial Period 1
            let latestMonthNum = 0;
            let latestYearNum = 0;
            rawData.forEach(row => {
                const year = parseInt(row.YEAR);
                const month = parseInt(row.MONTH);
                if (year > latestYearNum) {
                    latestYearNum = year;
                    latestMonthNum = month;
                } else if (year === latestYearNum && month > latestMonthNum) {
                    latestMonthNum = month;
                }
            });

            // Convert latestMonthNum (1-12) to fiscalMonthIndex (0-11 for monthNames array)
            const fiscalYearStartMonth = 4; // April is month 4
            let latestFiscalMonthIndex = (latestMonthNum >= fiscalYearStartMonth) ? latestMonthNum - fiscalYearStartMonth : latestMonthNum + (12 - fiscalYearStartMonth);

            // Set initial values for custom selectors (even if hidden)
            monthSelect1.value = latestFiscalMonthIndex;
            yearSelect1.value = latestYearNum;

            // Default Period 2 to previous year of Period 1's month
            monthSelect2.value = latestFiscalMonthIndex;
            yearSelect2.value = latestYearNum - 1;

            // Add event listeners for comparison radio buttons
            document.querySelectorAll('input[name="compareOption"]').forEach(radio => {
                radio.addEventListener('change', handleComparisonOptionChange);
            });

            // Set default comparison option to "vs. Last March"
            document.getElementById('compareLastMarch').checked = true;
            handleComparisonOptionChange(); // Initial call to set up UI based on default radio
        }

        function handleComparisonOptionChange() {
            const selectedOption = document.querySelector('input[name="compareOption"]:checked').value;
            const customPeriodSelectors = document.getElementById('customPeriodSelectors');
            const monthSelect1 = document.getElementById("regionMonthSelect1");
            const yearSelect1 = document.getElementById("regionYearSelect1");
            const monthSelect2 = document.getElementById("regionMonthSelect2");
            const yearSelect2 = document.getElementById("regionYearSelect2");

            // Determine the latest month and year from rawData for Period 1
            let latestMonthNum = 0; // 1-12 (Jan-Dec)
            let latestYearNum = 0;
            rawData.forEach(row => {
                const year = parseInt(row.YEAR);
                const month = parseInt(row.MONTH);
                if (year > latestYearNum) {
                    latestYearNum = year;
                    latestMonthNum = month;
                } else if (year === latestYearNum && month > latestMonthNum) {
                    latestMonthNum = month;
                }
            });

            // Convert latestMonthNum (1-12) to fiscalMonthIndex (0-11 for monthNames array)
            const fiscalYearStartMonthNum = 4; // April is month 4 (1-indexed)
            let latestFiscalMonthIndex = (latestMonthNum >= fiscalYearStartMonthNum) ? latestMonthNum - fiscalYearStartMonthNum : latestMonthNum + (12 - fiscalYearStartMonthNum);

            let period1MonthIndex = latestFiscalMonthIndex;
            let period1Year = latestYearNum;
            let period2MonthIndex, period2Year;

            if (selectedOption === 'custom') {
                customPeriodSelectors.style.display = 'flex';
                // Values are already set by user, no change needed here for period1/2
            } else {
                customPeriodSelectors.style.display = 'none';

                if (selectedOption === 'lastMonth') {
                    // Period 1: Latest Month (latestFiscalMonthIndex, latestYearNum)
                    period2MonthIndex = (latestFiscalMonthIndex === 0) ? 11 : latestFiscalMonthIndex - 1; // If Apr (index 0), then Mar (index 11)
                    period2Year = (latestFiscalMonthIndex === 0) ? latestYearNum - 1 : latestYearNum; // If Apr (index 0), then previous year for Mar
                } else if (selectedOption === 'lastMarch') {
                    // Period 1: Latest Month (latestFiscalMonthIndex, latestYearNum)
                    // Period 2: March of latest year data (March is index 11)
                    period2MonthIndex = 11; // March is index 11 in monthNames (Apr-Mar)
                    period2Year = latestYearNum; // March of the same fiscal year as Period 1
                } else if (selectedOption === 'prevYear') {
                    // Period 1: Latest Month (latestFiscalMonthIndex, latestYearNum)
                    // Period 2: Corresponding month of previous year
                    period2MonthIndex = latestFiscalMonthIndex;
                    period2Year = latestYearNum - 1;
                }

                monthSelect1.value = period1MonthIndex;
                yearSelect1.value = period1Year;
                monthSelect2.value = period2MonthIndex;
                yearSelect2.value = period2Year;
            }
            updateRegionTable();
        }

        // Stores the processed data for the current comparison view, to be sorted
        let currentComparisonData = [];

        function updateRegionTable() {
            // Collapse any expanded options rows when the table updates
            collapseAllOptions();

            const selectedParameter = [...document.querySelectorAll("#parameterCheckboxes input:checked")].map(cb => cb.value)[0]; // Use first selected parameter

            if (!selectedParameter) {
                document.getElementById("regionTable").querySelector("tbody").innerHTML = "<tr><td colspan='8'>Please select at least one Parameter.</td></tr>"; // colspan updated
                return;
            }

            const monthSelect1 = document.getElementById("regionMonthSelect1");
            const yearSelect1 = document.getElementById("regionYearSelect1");
            const monthSelect2 = document.getElementById("regionMonthSelect2");
            const yearSelect2 = document.getElementById("regionYearSelect2");

            const fiscalMonthMap = [4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3];
            const actualMonth1 = fiscalMonthMap[parseInt(monthSelect1.value)];
            const actualMonth2 = fiscalMonthMap[parseInt(monthSelect2.value)];
            const actualYear1 = parseInt(yearSelect1.value);
            const actualYear2 = parseInt(yearSelect2.value);

            // Update header labels
            document.getElementById("period1Header").textContent = `${monthNumToNameMap[actualMonth1]} ${actualYear1}`;
            document.getElementById("period2Header").textContent = `${monthNumToNameMap[actualMonth2]} ${actualYear2}`;

            let processedEntries = [];

            // Logic based on active comparison sub-tab and filters to populate processedEntries
            if (currentComparisonSubTab === 'region') {
                // If we are explicitly on the region tab, clear any filters
                currentRegionFilter = null;
                currentDivisionFilter = null;
                const regions = Object.keys(hierarchyData).sort();
                regions.forEach(regionName => {
                    const regionEntry = processHierarchyLevel(
                        rawData.filter(row => row.CCC === regionName && parseInt(row.MONTH) === actualMonth1 && parseInt(row.YEAR) === actualYear1),
                        rawData.filter(row => row.CCC === regionName && parseInt(row.MONTH) === actualMonth2 && parseInt(row.YEAR) === actualYear2),
                        selectedParameter,
                        regionName
                    );
                    if (regionEntry) processedEntries.push(regionEntry);
                });
            } else if (currentComparisonSubTab === 'division') {
                let divisionsToShow = [];
                if (currentRegionFilter) {
                    // Show divisions only for the filtered region
                    divisionsToShow = hierarchyData[currentRegionFilter]?.divisions || [];
                } else {
                    // Show all divisions if no region filter is active
                    Object.values(hierarchyData).forEach(regionObj => {
                        regionObj.divisions.forEach(div => divisionsToShow.push(div));
                    });
                }
                divisionsToShow.sort().forEach(divName => {
                    const divEntry = processHierarchyLevel(
                        rawData.filter(row => row.CCC === divName && parseInt(row.MONTH) === actualMonth1 && parseInt(row.YEAR) === actualYear1),
                        rawData.filter(row => row.CCC === divName && parseInt(row.MONTH) === actualMonth2 && parseInt(row.YEAR) === actualYear2),
                        selectedParameter,
                        divName
                    );
                    if (divEntry) processedEntries.push(divEntry);
                });
            } else if (currentComparisonSubTab === 'ccc') {
                let cccsToShow = [];
                if (currentDivisionFilter) {
                    // Find the CCCs for the filtered division
                    let foundCccs = [];
                    for (const regionKey in hierarchyData) {
                        if (hierarchyData[regionKey].cccs[currentDivisionFilter]) {
                            foundCccs = hierarchyData[regionKey].cccs[currentDivisionFilter];
                            break;
                        }
                    }
                    cccsToShow = foundCccs;
                } else if (currentRegionFilter) {
                    // If a region is filtered, show all CCCs under that region's divisions
                    for (const div of hierarchyData[currentRegionFilter].divisions) {
                        if (hierarchyData[currentRegionFilter].cccs[div]) {
                             cccsToShow.push(...hierarchyData[currentRegionFilter].cccs[div]);
                        }
                    }
                } else {
                    // If no region or division filter, show all individual CCCs
                    const allCCCs = new Set(rawData.map(row => row.CCC).filter(Boolean));
                    [...allCCCs].sort().forEach(cccName => {
                        const isRegionOrDivision = Object.keys(hierarchyData).includes(cccName) ||
                                                   Object.values(hierarchyData).some(reg => reg.divisions.includes(cccName));
                        if (!isRegionOrDivision) {
                            cccsToShow.push(cccName);
                        }
                    });
                }
                cccsToShow.sort().forEach(cccName => {
                    const cccEntry = processHierarchyLevel(
                        rawData.filter(row => row.CCC === cccName && parseInt(row.MONTH) === actualMonth1 && parseInt(row.YEAR) === actualYear1),
                        rawData.filter(row => row.CCC === cccName && parseInt(row.MONTH) === actualMonth2 && parseInt(row.YEAR) === actualYear2),
                        selectedParameter,
                        cccName
                    );
                    if (cccEntry) processedEntries.push(cccEntry);
                });
            }

            // Store the processed data before sorting
            currentComparisonData = processedEntries;

            // Apply sorting if a column is selected for sorting
            if (currentSortColumn) {
                sortData(currentSortColumn, currentSortOrder);
            } else {
                // If no sorting is active, render based on the default processed order
                renderComparisonTable(currentComparisonData);
            }
            updateFilterIconsDisplay(); // Call this after table is rendered and filters are set
        }

        function processHierarchyLevel(period1FilteredData, period2FilteredData, parameter, unitName) {
            const entry1 = period1FilteredData.find(row => row.CCC === unitName);
            const entry2 = period2FilteredData.find(row => row.CCC === unitName);

            const value1 = entry1 ? parseFloat(entry1[parameter]) : null;
            const value2 = entry2 ? parseFloat(entry2[parameter]) : null;

            let difference = null;
            let percentDiff = null;
            let diffClass = "";

            if (value1 != null && value2 != null) { // Changed to != null
                // Change calculation: Current data (Period 1) - Previous data (Period 2)
                difference = value1 - value2;
                percentDiff = (value2 !== 0) ? (difference / Math.abs(value2)) * 100 : 0;

                // Determine color based on whether an increase is good for this parameter
                if (parametersGoodWhenIncreasing.includes(parameter)) {
                    // For parameters where increase is good (e.g., Demand, Collection, Efficiency)
                    diffClass = difference > 0 ? "negative" : difference < 0 ? "positive" : "";
                } else {
                    // For parameters where decrease is good (e.g., AT&C Loss, T&D Loss, Input)
                    diffClass = difference < 0 ? "negative" : difference > 0 ? "positive" : "";
                }
            }

            // Get target value for this unit and parameter
            const targetValue = targetDataMap[unitName]?.[parameter];
            let diffVsTarget = null;
            let diffVsTargetClass = "";

            if (value1 != null && targetValue != null) { // Changed to != null
                diffVsTarget = value1 - targetValue;
                if (parametersGoodWhenIncreasing.includes(parameter)) {
                    diffVsTargetClass = diffVsTarget > 0 ? "negative" : diffVsTarget < 0 ? "positive" : "";
                } else if (parametersGoodWhenDecreasing.includes(parameter)) {
                    diffVsTargetClass = diffVsTarget < 0 ? "negative" : diffVsTarget > 0 ? "positive" : "";
                } else {
                    diffVsTargetClass = 'neutral';
                }
            }


            return {
                name: unitName,
                value1: value1,
                value2: value2,
                difference: difference,
                percentDiff: percentDiff,
                diffClass: diffClass,
                targetValue: targetValue, // New: Add target value
                diffVsTarget: diffVsTarget, // New: Add difference vs target
                diffVsTargetClass: diffVsTargetClass // New: Add class for difference vs target
            };
        }

        // Function to collapse all region and division options
        function collapseAllOptions() {
            document.querySelectorAll('.options-row').forEach(row => row.remove());
            if (expandedRowOptions) {
                expandedRowOptions.classList.remove('expanded');
                expandedRowOptions = null;
            }
        }

        function toggleRegionExpand(rowElement, regionName) {
            const isExpanded = rowElement.classList.contains('expanded');

            // Collapse any currently expanded row if it's not the one being clicked again
            if (expandedRowOptions && expandedRowOptions !== rowElement) {
                collapseAllOptions();
            }

            if (isExpanded) {
                // Collapse the current row
                rowElement.classList.remove('expanded');
                const nextSibling = rowElement.nextElementSibling;
                if (nextSibling && nextSibling.classList.contains('options-row')) {
                    nextSibling.remove();
                }
                expandedRowOptions = null;
            } else {
                // Expand the current row
                rowElement.classList.add('expanded');
                expandedRowOptions = rowElement;

                const newRow = document.createElement('tr');
                newRow.classList.add('options-row');
                newRow.innerHTML = `
                    <td colspan="8"> <!-- Adjusted colspan to 8 -->
                        <div class="option-buttons">
                            <button onclick="showComparisonSubTab('division', '${regionName}', 'region')">View Divisions</button>
                            <button onclick="showComparisonSubTab('ccc', '${regionName}', 'region')">View CCCs</button>
                            <button onclick="drillDownToChart('${regionName}')">View Chart</button>
                        </div>
                    </td>
                `;
                rowElement.after(newRow);
            }
        }

        function toggleDivisionExpand(rowElement, divisionName) {
            const isExpanded = rowElement.classList.contains('expanded');

            // Collapse any currently expanded row if it's not the one being clicked again
            if (expandedRowOptions && expandedRowOptions !== rowElement) {
                collapseAllOptions();
            }

            if (isExpanded) {
                // Collapse the current row
                rowElement.classList.remove('expanded');
                const nextSibling = rowElement.nextElementSibling;
                if (nextSibling && nextSibling.classList.contains('options-row')) {
                    nextSibling.remove();
                }
                expandedRowOptions = null;
            } else {
                // Expand the current row
                rowElement.classList.add('expanded');
                expandedRowOptions = rowElement;

                const newRow = document.createElement('tr');
                newRow.classList.add('options-row');
                newRow.innerHTML = `
                    <td colspan="8"> <!-- Adjusted colspan to 8 -->
                        <div class="option-buttons">
                            <button onclick="showComparisonSubTab('ccc', '${divisionName}', 'division')">View CCCs</button>
                            <button onclick="drillDownToChart('${divisionName}')">View Chart</button>
                        </div>
                    </td>
                `;
                rowElement.after(newRow);
            }
        }


        function generateHierarchyRow(entry, rowClass, level, serialNumber, hidePercentColumn = false) {
            const indent = level * 30; // 0px for region, 30px for division, 60px for CCC
            let onClickHandler = '';

            if (rowClass === 'region-row') {
                // For region rows, the click handler is on the row itself to toggle options
                onClickHandler = `onclick="toggleRegionExpand(this, '${entry.name}')"`;
            } else if (rowClass === 'division-row') {
                // For division rows, the click handler is to toggle options
                onClickHandler = `onclick="toggleDivisionExpand(this, '${entry.name}')"`;
            } else if (rowClass === 'ccc-row') {
                // For CCC rows, the click handler is to drill down to chart directly
                onClickHandler = `onclick="drillDownToChart('${entry.name}')"`;
            }

            return `
                <tr class="${rowClass}" ${onClickHandler}>
                    <td>${serialNumber}</td> <!-- Display serial number -->
                    <td style="padding-left:${indent + 15}px;">
                        ${entry.name}
                    </td>
                    <td>${entry.value1 != null ? entry.value1.toFixed(2) : "-"}</td>
                    <td>${entry.value2 != null ? entry.value2.toFixed(2) : "-"}</td>
                    <td class="${entry.diffClass}">${entry.difference != null ? entry.difference.toFixed(2) : "-"}</td>
                    ${hidePercentColumn ? '' : `<td class="${entry.diffClass}">${entry.percentDiff != null ? entry.percentDiff.toFixed(2) + "%" : "-"}</td>`}
                    <td>${entry.targetValue != null ? entry.targetValue.toFixed(2) : "-"}</td>
                    <td class="${entry.diffVsTargetClass}">${entry.diffVsTarget != null && !isNaN(entry.diffVsTarget) ? entry.diffVsTarget.toFixed(2) : "-"}</td>
                </tr>
            `;
        }

        function toggleSort(column) {
            if (currentSortColumn === column) {
                // Cycle through 'asc' -> 'desc' -> 'none'
                if (currentSortOrder === 'asc') {
                    currentSortOrder = 'desc';
                } else if (currentSortOrder === 'desc') {
                    currentSortOrder = 'none';
                    currentSortColumn = null; // Reset column if no sort
                } else {
                    currentSortOrder = 'asc';
                }
            } else {
                // New column selected, start with ascending
                currentSortColumn = column;
                currentSortOrder = 'asc';
            }
            sortData(currentSortColumn, currentSortOrder);
            updateSortIcons();
        }

        function sortData(column, order) {
            const sortedData = [...currentComparisonData]; // Create a copy to sort

            if (order === 'none' || !column) {
                // If no sort or column is null, revert to initial order (which is alphabetical by name)
                // Re-fetch or re-process to get the default alphabetical order
                updateRegionTable(); // This will re-process and then call render with default order
                return;
            }

            sortedData.sort((a, b) => {
                const valA = a[column];
                const valB = b[column];

                // Handle null/undefined values: push them to the end
                if (valA == null && valB == null) return 0; // Changed to == null
                if (valA == null) return 1; // Changed to == null
                if (valB == null) return -1; // Changed to == null

                if (order === 'asc') {
                    return valA - valB;
                } else { // 'desc'
                    return valB - valA;
                }
            });
            renderComparisonTable(sortedData);
        }

        function renderComparisonTable(dataToRender) {
            const table = document.getElementById("regionTable");
            const tbody = table.querySelector("tbody");
            let tbodyHtml = "";

            // Determine if Change % column should be hidden
            const selectedParameter = [...document.querySelectorAll("#parameterCheckboxes input:checked")].map(cb => cb.value)[0];
            const hidePercentColumn = parametersToHideChangePercent.includes(selectedParameter);
            const changePercentHeader = document.getElementById("changePercentHeader");
            if (hidePercentColumn) {
                changePercentHeader.style.display = 'none';
            } else {
                changePercentHeader.style.display = 'table-cell';
            }

            if (dataToRender.length === 0) {
                tbodyHtml = "<tr><td colspan='8'>No data available for selected periods or filters.</td></tr>"; // colspan updated
            } else {
                dataToRender.forEach((entry, index) => { // Added index for serial number
                    // Determine the correct row class based on the entry's name and hierarchy
                    let rowClass = '';
                    let level = 0;
                    if (Object.keys(hierarchyData).includes(entry.name)) {
                        rowClass = 'region-row';
                        level = 0;
                    } else if (Object.values(hierarchyData).some(reg => reg.divisions.includes(entry.name))) {
                        rowClass = 'division-row';
                        level = 1;
                    } else {
                        rowClass = 'ccc-row';
                        level = 2;
                    }
                    tbodyHtml += generateHierarchyRow(entry, rowClass, level, index + 1, hidePercentColumn); // Pass index + 1 as serial number
                });
            }
            tbody.innerHTML = tbodyHtml;
        }

        function updateSortIcons() {
            const changeSortIcon = document.getElementById('changeSortIcon');
            const percentSortIcon = document.getElementById('percentSortIcon');

            changeSortIcon.innerHTML = '';
            percentSortIcon.innerHTML = '';

            if (currentSortColumn === 'difference') {
                if (currentSortOrder === 'asc') {
                    changeSortIcon.innerHTML = '&#9650;'; // Up arrow
                } else if (currentSortOrder === 'desc') {
                    changeSortIcon.innerHTML = '&#9660;'; // Down arrow
                }
            } else if (currentSortColumn === 'percentDiff') {
                if (currentSortOrder === 'asc') {
                    percentSortIcon.innerHTML = '&#9650;'; // Up arrow
                } else if (currentSortOrder === 'desc') {
                    percentSortIcon.innerHTML = '&#9660;'; // Down arrow
                }
            }
        }

        // New function to drill down from Region/Division row to chart
        function drillDownToChart(unitName) {
            document.getElementById('cccFilter').value = unitName; // Set the CCC filter
            showTab('chartTab'); // Switch to the chart tab
        }


        // --- UI Toggle Functions ---
        function showTab(tabId) {
            currentActiveTab = tabId;

            // Collapse any expanded options rows when switching tabs
            collapseAllOptions();

            // Hide all main tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });

            // Deactivate all main tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });

            // Show the selected main tab content and activate its button
            document.getElementById(tabId).style.display = 'block';
            document.querySelector(`.tab-button[onclick="showTab('${tabId}')"]`).classList.add('active');

            // Specific logic for each main tab
            if (tabId === 'chartTab') {
                document.getElementById('dataTableWrapper').style.display = 'block'; // Show data table by default
                updateChart(); // Ensure chart is updated when tab is active
            } else if (tabId === 'comparisonTab') {
                // Enforce single parameter selection for comparison tab
                const parameterCheckboxes = document.querySelectorAll("#parameterCheckboxes input[type='checkbox']");
                let firstChecked = false;
                parameterCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        if (!firstChecked) {
                            firstChecked = true;
                        } else {
                            checkbox.checked = false; // Uncheck subsequent checked parameters
                        }
                    }
                });
                // If no parameter was checked, check the first one (e.g., AT&C Loss)
                if (!firstChecked && parameterCheckboxes.length > 0) {
                    // Find the checkbox for "CUM. AT&C LOSS" and check it
                    const atcLossCheckbox = document.getElementById('param-CUM-ATCLOSS');
                    if (atcLossCheckbox) {
                        atcLossCheckbox.checked = true;
                    } else {
                        // Fallback to checking the very first checkbox if AT&C Loss is not found
                        parameterCheckboxes[0].checked = true;
                    }
                }

                // Reset sorting when switching to comparison tab
                currentSortColumn = 'difference'; // Default sort column
                currentSortOrder = 'desc'; // Default sort order (high to low)
                updateSortIcons();

                document.getElementById('regionTableWrapper').style.display = 'block'; // Show comparison table by default
                // When switching to comparison tab, if no specific drill-down is requested,
                // ensure filters are cleared to show the default view of the current sub-tab.
                // This is handled by showComparisonSubTab's default behavior if filterUnitName is null.
                showComparisonSubTab(currentComparisonSubTab);
            }
        }

        function showComparisonSubTab(subTabId, filterUnitName = null, filterUnitType = null, fromClearIcon = false) {
            currentComparisonSubTab = subTabId;

            // Collapse any expanded options rows when changing sub-tabs
            collapseAllOptions();

            // Deactivate all comparison sub-tab buttons
            document.querySelectorAll('.comparison-sub-tab-button').forEach(button => {
                button.classList.remove('active');
            });

            // Activate the selected sub-tab button
            document.querySelector(`.comparison-sub-tab-button[onclick="showComparisonSubTab('${subTabId}')"]`).classList.add('active');

            // Set filters based on the clicked unit or clear them if fromClearIcon or direct tab click
            if (fromClearIcon) {
                if (filterUnitType === 'region') {
                    currentRegionFilter = null;
                } else if (filterUnitType === 'division') {
                    currentDivisionFilter = null;
                }
            } else if (filterUnitName) { // A specific unit was passed for filtering
                if (filterUnitType === 'region') {
                    currentRegionFilter = filterUnitName;
                    currentDivisionFilter = null; // Clear division filter if coming from region
                } else if (filterUnitType === 'division') {
                    currentDivisionFilter = filterUnitName;
                    currentRegionFilter = null; // Clear region filter if coming from division
                }
            } else { // Direct tab click (no filterUnitName)
                currentRegionFilter = null;
                currentDivisionFilter = null;
            }

            // Update the table based on the new sub-tab selection and potential filters
            updateRegionTable();
        }

        // New function to clear filters
        function clearFilter(filterType, event) {
            event.stopPropagation(); // Prevent the tab button's own click handler from firing
            if (filterType === 'region') {
                currentRegionFilter = null;
                currentDivisionFilter = null; // Clearing region also clears division
                showComparisonSubTab(currentComparisonSubTab, null, null, true); // Go back to current sub-tab without region/division filter
            } else if (filterType === 'division') {
                currentDivisionFilter = null;
                showComparisonSubTab(currentComparisonSubTab, null, null, true); // Go back to current sub-tab without division filter
            }
        }

        // Function to update the display of filter clear icons
        function updateFilterIconsDisplay() {
            const divisionIcon = document.getElementById('divisionFilterIcon');
            const cccIcon = document.getElementById('cccFilterIcon'); // Corrected ID reference

            // Logic for Division tab filter icon
            // Show icon if current sub-tab is division AND a region filter is active
            if (currentComparisonSubTab === 'division' && currentRegionFilter) {
                divisionIcon.style.display = 'flex';
                divisionIcon.onclick = (event) => clearFilter('region', event); // Clear region filter
            } else {
                divisionIcon.style.display = 'none';
                divisionIcon.onclick = null;
            }

            // Logic for CCC tab filter icon
            if (currentComparisonSubTab === 'ccc') {
                if (currentDivisionFilter) {
                    cccIcon.style.display = 'flex';
                    cccIcon.onclick = (event) => clearFilter('division', event); // Clear division filter
                } else if (currentRegionFilter) { // If CCC tab is active and filtered by region
                    cccIcon.style.display = 'flex';
                    cccIcon.onclick = (event) => clearFilter('region', event); // Clear region filter
                } else {
                    cccIcon.style.display = 'none';
                    cccIcon.onclick = null;
                }
            } else {
                cccIcon.style.display = 'none';
                cccIcon.onclick = null;
            }
        }


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            fetchCSV(); // This now handles showing and hiding the loader
            // The initial showTab and comparison tab default setup are now handled within fetchCSV's complete callback
            // to ensure they execute only after the rawData is loaded.
        });
    </script>
</body>
</html>
