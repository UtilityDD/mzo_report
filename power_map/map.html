<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Power Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.6.0/leaflet.polylineDecorator.min.js"></script>

    <style>
        @keyframes fade {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        #loading-screen {
            position: fixed;
            width: 100%;
            height: 100vh;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            font-size: 24px;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }

        #loading-icon {
            margin-right: 10px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #map {
            height: 100vh;
            background: white;
        }

        .leaflet-tooltip {
            background: white;
            border: 1px solid black;
            padding: 1px 2px;
            font-size: 10px;
        }

        #floating-table {
            position: fixed;
            top: 50px;
            right: 20px;
            background: white;
            border: 1px solid black;
            padding: 8px;
            opacity: 80%;
            max-height: 520px; /* Set a fixed height */
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 10000; /* Ensure it stays above the map */
            font-family: Arial, sans-serif;
            overflow: hidden; /* Hide overflow from table head */
        }

        #table-container {
            max-height: 500px; /* Adjust height for scrolling */
            overflow-y: auto; /* Enable vertical scroll */
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 1px;
            text-align: left;
        }

        th {
            background: #f4f4f4;
        }

        #map {
            height: 100vh;
            z-index: 0; /* Ensures the map stays behind */
        }

        #floating-table h3 {
            margin: 0;
            text-align: center;
            font-size: 14px;
        }

        #floating-table table {
            width: 100%;
            border-collapse: collapse;
        }

        #floating-table th, #floating-table td {
            border: 1px solid black;
            padding: 1px;
            font-size: 10px;
            text-align: center;
        }

        #floating-table th {
            background: #f0f0f0;
            position: sticky;
            top: 0;
        }

        #map-legend {
            position: fixed;
            bottom: 10px;
            right: 14px;
            background: rgba(174, 172, 172, 0.475);
            padding: 5px 10px;
            border: 1px solid black;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 15px; /* Spacing between items */
            white-space: nowrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #search-container {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: white;
    padding: 5px 10px;
    border: 1px solid black;
    box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
    z-index: 15000; /* Increased z-index */
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 270px; /* Fixed width */
}

        #search-box {
            width: 250px;
            padding: 2px;
            border: 1px solid gray;
            font-size: 14px;
        }

        #search-results {
    list-style: none;
    margin: 0;
    padding: 0;
    max-height: 200px;
    overflow-y: auto;
    width: 100%;
    background: white;
    border: 1px solid #ccc;
    border-radius: 0 0 4px 4px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    position: absolute;
    top: 100%;
    left: 0;
    z-index: 20000; /* Increased z-index to be higher than summary card */
    display: none;
}
#search-results li {
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 1px solid #eee;

}

#search-results li:hover {
    background: #f5f5f5;
}

#search-results li:last-child {
    border-bottom: none;
}
        #summary-card {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0);
            padding: 1px;
            border: 1px solid rgba(0, 0, 0, 0);
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0);
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 10000;
            text-align: center;
            font-weight: lighter;
        }

        #filter-container {
            position: fixed;
            top: 110px;
            left: 10px;
            background: white;
            padding: 10px;
            border: 1px solid black;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
            border-radius: 5px;
            max-height: 500px;
            overflow-y: auto;
        }

        .filter-category {
            font-weight: bold;
            margin-top: 5px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #status-message {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }
        
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-icon">⚡</div>
        <p id="loading-text">Loading map data...</p>
    </div>

    <div id="filter-container">
        <h3>Filter Options</h3>
        <div id="filter-options"></div>
        <button onclick="applyFilters()">Apply Filters</button>

    </div>

    <div id="summary-card">
        <h4 style="align-items: center; color: red;">Total: <span id="total-substations">0</span> no. / <span id="total-capacity">0</span> MVA (including 33/11kV PTRs at GSS)</h4>
    </div>

    <div id="floating-table">
        <h3>Substations</h3>
        <div id="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Substation</th>
                        <th>MVA</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- Data will be populated here -->
                </tbody>
            </table>
        </div>
    </div>

    <div id="search-container">
        <input id="search-box" 
               onkeydown="handleSearch(event)" 
               oninput="handleSearchInput(event)" 
               placeholder="Search Substation..." 
               type="text">
        <ul id="search-results"></ul>
    </div>

    <div id="map-legend">
        <div class="legend-item"><span class="legend-circle" style="color: red;">⬤</span> Existing 33/11kV SS</div>
        <div class="legend-item"><span class="legend-circle" style="color: rgb(3, 160, 37);">☉</span> GSS</div>
        <div class="legend-item"><span class="legend-circle" style="color: blue;">⬤</span> Proposed 33/11kV SS</div>
        <div class="legend-item"><span class="legend-circle" style="color: rgb(0, 0, 0);">⬤</span> Under Construction 33/11kV SS</div>
        <div class="legend-item"><span style="border-top: 2px solid rgb(255, 0, 0); width: 20px; display: inline-block;"></span> Existing 33kV Feeder</div>
        <div class="legend-item"><span style="border-top: 2px dashed blue; width: 20px; display: inline-block;"></span> Proposed 33kV Feeder</div>
    </div>

    <div id="status-message"></div>
    <div id="map"></div>

<script>
    // Global variables
    const csvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT8hYE6YBbfVQDJhgB3cIWqrrGrjMQAQ22mcmCJTOa995gCH-xBAfsAPpBvNYS1KlYIFMRHM59iGB7K/pub?output=csv';
    const geojsonUrl = 'https://raw.githubusercontent.com/shuklaneerajdev/IndiaStateTopojsonFiles/master/WestBengal.geojson';
    let map, worldPolygon, stateLayer, maskLayer;
    let selectedFilters = {Region: new Set(), Division: new Set(), Remarks: new Set()};
    let allData = []; // Store all data for filtering
    let loadingDataComplete = false;

    // Show status message
    function showStatus(message, duration = 3000) {
        const statusEl = document.getElementById('status-message');
        statusEl.textContent = message;
        statusEl.style.display = 'block';
        
        setTimeout(() => {
            statusEl.style.display = 'none';
        }, duration);
    }

    // Initialize map
    function initMap() {
        map = L.map('map', {
            zoomControl: true,
            minZoom: 7,
        }).setView([23.5, 87.5], 7);

        // Load the tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        return map;
    }

    // Convert DMS coordinates to decimal
    function dmsToDecimal(dms) {
        if (!dms || typeof dms !== 'string') return NaN;
        
        let parts = dms.match(/[NSWE]?\d+°\d+\.\d+'/g);
        if (!parts) return NaN;
        
        let degrees = parseFloat(parts[0].match(/\d+/)[0]);
        let minutes = parseFloat(parts[0].match(/\d+\.\d+/g)[0]);
        let decimal = degrees + minutes / 60;
        
        if (dms.includes('S') || dms.includes('W')) decimal *= -1;
        return decimal;
    }

    // Fetch and parse CSV data
    async function fetchCSV(url) {
        try {
            showStatus("Fetching substation data...");
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch CSV: ${response.status}`);
            }
            
            const csvText = await response.text();
            showStatus("Processing substation data...");
            
            return new Promise((resolve) => {
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        if (results.data && results.data.length > 0) {
                            // Filter out rows without valid coordinates
                            const validData = results.data.filter(entry => 
                                entry.LATITUDE && 
                                entry.LONGITUDE && 
                                !isNaN(dmsToDecimal(entry.LATITUDE)) && 
                                !isNaN(dmsToDecimal(entry.LONGITUDE))
                            );
                            
                            showStatus(`Loaded ${validData.length} substations`);
                            resolve(validData);
                        } else {
                            console.error("CSV parsing returned no data");
                            showStatus("Error: No data found in CSV", 5000);
                            resolve([]);
                        }
                    },
                    error: (error) => {
                        console.error("CSV parsing error:", error);
                        showStatus("Error parsing data", 5000);
                        resolve([]);
                    }
                });
            });
        } catch (error) {
            console.error("Error fetching CSV:", error);
            showStatus("Error loading data. Please check console.", 5000);
            return [];
        }
    }

    // Load GeoJSON for West Bengal state boundary
    async function loadStateGeoJSON() {
        try {
            showStatus("Loading state boundaries...");
            const response = await fetch(geojsonUrl);
            if (!response.ok) {
                throw new Error(`Failed to fetch GeoJSON: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Create world polygon for masking
            worldPolygon = {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[
                        [-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]
                    ]]
                }
            };
            
            // Add state boundaries to map
            stateLayer = L.geoJSON(data, {
                style: {
                    color: "black",
                    weight: 1.5,
                    fillOpacity: 0
                }
            }).addTo(map);
            
            // Process for mask layer
            data.features.forEach(feature => {
                if (feature.geometry.type === "Polygon") {
                    worldPolygon.geometry.coordinates.push(feature.geometry.coordinates[0]);
                } else if (feature.geometry.type === "MultiPolygon") {
                    feature.geometry.coordinates.forEach(polygon => {
                        worldPolygon.geometry.coordinates.push(polygon[0]);
                    });
                }
            });
            
            // Add mask layer
            maskLayer = L.geoJSON(worldPolygon, {
                style: {
                    color: "white",
                    weight: 1,
                    fillColor: "white",
                    fillOpacity: 0.85
                }
            }).addTo(map);
            
            // Fit map to state boundaries
            map.fitBounds(stateLayer.getBounds());
            stateLayer.bringToFront();
            
            return true;
        } catch (error) {
            console.error("Error loading GeoJSON:", error);
            showStatus("Error loading state boundaries", 5000);
            return false;
        }
    }

    // Create filter options
// Replace the existing createFilterOptions function with this one
// Replace the existing createFilterOptions function with this one
function createFilterOptions(data) {
    let filterContainer = document.getElementById("filter-options");
    filterContainer.innerHTML = "";

    // Remove the Apply Filters button if it exists
    const buttonElement = document.querySelector('#filter-container button');
    if (buttonElement) {
        buttonElement.remove();
    }

    let uniqueValues = {Region: new Set(), Division: new Set(), Remarks: new Set()};
    let valueCounts = {Region: {}, Division: {}, Remarks: {}};

    // Count occurrences of each value
    data.forEach(entry => {
        if (entry.Region && entry.Region.trim()) {
            const region = entry.Region.trim();
            uniqueValues.Region.add(region);
            valueCounts.Region[region] = (valueCounts.Region[region] || 0) + 1;
        }
        
        if (entry.Division && entry.Division.trim()) {
            const division = entry.Division.trim();
            uniqueValues.Division.add(division);
            valueCounts.Division[division] = (valueCounts.Division[division] || 0) + 1;
        }
        
        if (entry.Remarks && entry.Remarks.trim()) {
            const remarks = entry.Remarks.trim();
            uniqueValues.Remarks.add(remarks);
            valueCounts.Remarks[remarks] = (valueCounts.Remarks[remarks] || 0) + 1;
        }
    });

    ["Region", "Division", "Remarks"].forEach(category => {
        let categoryDiv = document.createElement("div");
        categoryDiv.classList.add("filter-category");
        categoryDiv.textContent = category;
        filterContainer.appendChild(categoryDiv);

        Array.from(uniqueValues[category]).sort().forEach(value => {
            let filterItem = document.createElement("div");
            filterItem.classList.add("filter-item");

            let checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = true;
            checkbox.dataset.category = category;
            checkbox.value = value;

            let label = document.createElement("label");
            // Add count in parentheses next to each filter value
            label.textContent = `${value} (${valueCounts[category][value]})`;

            filterItem.appendChild(checkbox);
            filterItem.appendChild(label);
            filterContainer.appendChild(filterItem);

            checkbox.addEventListener("change", function() {
                if (this.checked) {
                    selectedFilters[category].add(this.value);
                } else {
                    selectedFilters[category].delete(this.value);
                }
                // Immediately apply filters when checkbox state changes
                applyFilters();
            });

            selectedFilters[category].add(value);
        });
    });
}

// Update the filter container in HTML by removing the button in JavaScript
// We'll add this to the createFilterOptions function to modify the DOM directly

// Modified applyFilters function to handle connections properly without disturbing the map layers
function applyFilters() {
    // Create a map to track substations and their visibility
    let substationVisibility = {};
    let visibleMarkers = new Set();
    let visibleLines = new Set();
    let mapLayersToPreserve = new Set();
    
    // Track connection counts for dynamic summary update
    let solidConnectionCount = 0;
    let dashedConnectionCount = 0;
    
    // Make sure we track the layers we want to preserve
    if (stateLayer) mapLayersToPreserve.add(stateLayer);
    if (maskLayer) mapLayersToPreserve.add(maskLayer);
    map.eachLayer(layer => {
        if (layer instanceof L.TileLayer) {
            mapLayersToPreserve.add(layer);
        }
    });
    
    // Filter data based on selected filters
    let filteredData = allData.filter(entry =>
        (!entry.Region || !entry.Region.trim() || selectedFilters.Region.has(entry.Region.trim())) &&
        (!entry.Division || !entry.Division.trim() || selectedFilters.Division.has(entry.Division.trim())) &&
        (!entry.Remarks || !entry.Remarks.trim() || selectedFilters.Remarks.has(entry.Remarks.trim()))
    );

    // Build map of substation names that should be visible
    filteredData.forEach(entry => {
        if (entry.Substation) {
            substationVisibility[entry.Substation.trim()] = true;
        }
    });

    // Now update visibility of markers and lines without removing base layers
    map.eachLayer(layer => {
        // Skip base map layers that should always remain visible
        if (mapLayersToPreserve.has(layer)) {
            return;
        }
        
        if (layer instanceof L.Marker) {
            // For markers (substations)
            let isVisible = false;
            if (layer.getPopup()) {
                let popupContent = layer.getPopup().getContent();
                let match = popupContent.match(/<b>(.*?)<\/b>/);
                if (match && substationVisibility[match[1].trim()]) {
                    isVisible = true;
                    visibleMarkers.add(layer);
                }
            }
            
            // Update visibility without removing/adding layers
            if (isVisible) {
                if (!layer._isVisible) {
                    layer.setOpacity(1);
                    // Also show tooltip if it exists
                    if (layer.getTooltip()) {
                        layer.openTooltip();
                    }
                    layer._isVisible = true;
                }
            } else {
                if (layer._isVisible !== false) {
                    layer.setOpacity(0);
                    // Also hide tooltip if it exists
                    if (layer.getTooltip()) {
                        layer.closeTooltip();
                    }
                    layer._isVisible = false;
                }
            }
        } 
        else if (layer instanceof L.Polyline) {
            // Skip the state boundary lines
            if (stateLayer && stateLayer._layers && layer._leaflet_id in stateLayer._layers) {
                return;
            }
            
            // For connection lines between substations
            let shouldBeVisible = false;
            
            // Extract substation names from the popup if available
            if (layer._substations) {
                // If we've already cached the substation names for this line
                shouldBeVisible = layer._substations.every(name => 
                    substationVisibility[name]);
            } else if (layer._latlngs && layer._latlngs.length >= 2) {
                // We need to determine which substations this line connects
                // This is a simplification - in reality, we'd need to match line endpoints to markers
                let isConnectingVisibleMarkers = false;
                
                for (let marker of visibleMarkers) {
                    let markerPos = marker.getLatLng();
                    let firstPoint = layer._latlngs[0];
                    let lastPoint = layer._latlngs[layer._latlngs.length - 1];
                    
                    // Check if this line connects to this marker (approximate)
                    if ((Math.abs(markerPos.lat - firstPoint.lat) < 0.0001 && 
                         Math.abs(markerPos.lng - firstPoint.lng) < 0.0001) ||
                        (Math.abs(markerPos.lat - lastPoint.lat) < 0.0001 && 
                         Math.abs(markerPos.lng - lastPoint.lng) < 0.0001)) {
                        isConnectingVisibleMarkers = true;
                        break;
                    }
                }
                
                shouldBeVisible = isConnectingVisibleMarkers;
            }
            
            // Update visibility without removing/adding layers
            if (shouldBeVisible) {
                if (!layer._isVisible) {
                    layer.setStyle({ opacity: 1 });
                    // Show tooltips attached to this line
                    if (layer._tooltips) {
                        layer._tooltips.forEach(tooltip => tooltip.openTooltip());
                    } else if (layer.getTooltip()) {
                        layer.openTooltip();
                    }
                    layer._isVisible = true;
                }
                
                // Count visible connections by style for summary
                if (layer.options && layer.options.dashArray) {
                    dashedConnectionCount++;
                } else {
                    solidConnectionCount++;
                }
                
            } else {
                if (layer._isVisible !== false) {
                    layer.setStyle({ opacity: 0 });
                    // Hide tooltips attached to this line
                    if (layer._tooltips) {
                        layer._tooltips.forEach(tooltip => tooltip.closeTooltip());
                    } else if (layer.getTooltip()) {
                        layer.closeTooltip();
                    }
                    layer._isVisible = false;
                }
            }
        }
        // Also check for standalone tooltips (L.Tooltip instances directly added to the map)
        else if (layer instanceof L.Tooltip) {
            // Find parent layer of the tooltip
            let parentFound = false;
            map.eachLayer(potentialParent => {
                if (potentialParent._tooltip === layer && potentialParent._isVisible === false) {
                    // If parent is not visible, hide this tooltip
                    map.removeLayer(layer);
                    parentFound = true;
                }
            });
            
            // If no parent found, might be an orphaned tooltip
            if (!parentFound && layer._source && !layer._source._isVisible) {
                map.removeLayer(layer);
            }
        }
    });

    // Update connection counts in window object for summary use
    window.connectionCounts = {
        solid: solidConnectionCount,
        dashed: dashedConnectionCount
    };

    showStatus(`Displaying ${filteredData.length} substations`);
    
    // Update table and summary with filtered data
    populateTable(filteredData);
    updateSummary(filteredData);
    
    // Ensure state boundaries and mask remain visible
    restoreMapBorders();
}

    // Restore state boundaries
    function restoreMapBorders() {
        if (stateLayer) {
            stateLayer.bringToFront();
        }
        
        if (maskLayer) {
            maskLayer.bringToBack();
        }
    }

    // Plot map data (substations and connections)
    function plotMapData(data) {
    let substationMap = {};
    let connectionMap = {};
    let markersAdded = 0;
    let connectionsAdded = 0;
    // Add counters for connection types
    let solidConnections = 0;
    let dashedConnections = 0;

    // First pass: create all substation markers
    data.forEach(entry => {
        let lat = dmsToDecimal(entry.LATITUDE);
        let lng = dmsToDecimal(entry.LONGITUDE);
        
        if (!isNaN(lat) && !isNaN(lng) && entry.Substation) {
            let markerColor = (entry.Comment && ["black", "white", "red", "blue", "green", "yellow", "purple", "orange"].includes(entry.Comment.trim().toLowerCase()))
                ? entry.Comment.trim().toLowerCase()
                : "black";

            let symbol = entry.Symbol ? entry.Symbol.trim() : "⚡";
            let fontSize = entry.SymbolSize && !isNaN(entry.SymbolSize) ? parseInt(entry.SymbolSize) : 18;
            let size = fontSize * 1.2;
            let iconSize = [size, size];
            let iconAnchor = [size / 2, size / 2];

            let marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: "custom-symbol",
                    html: `<div style="
                    width: ${size}px; 
                    height: ${size}px; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    border-radius: 50%; 
                    font-size: ${fontSize}px; 
                    font-weight: bold; 
                    color: ${markerColor};
                    text-align: center;">
                    ${symbol}
                </div>`,
                    iconSize: iconSize,
                    iconAnchor: iconAnchor
                })
            }).addTo(map)
                .bindTooltip(entry.Substation, {permanent: true, direction: "top", className: "leaflet-tooltip"})
                .bindPopup(`<b>${entry.Substation}</b><br>Capacity: ${entry['MVA']}<br>Para-2: ${entry['Para-2'] || 'N/A'}<br>Para-3: ${entry['Para-3'] || 'N/A'}`);

            substationMap[entry.Substation] = {lat, lng, marker};
            markersAdded++;
        }
    });

    // Second pass: create connections between substations
    data.forEach(entry => {
        if (entry['Connected to']) {
            let connections = entry['Connected to'].split(':').map(s => s.trim());
            let labels = entry['RL'] ? entry['RL'].split(':').map(s => s.trim()) : [];

            connections.forEach((target, index) => {
                if (substationMap[target] && substationMap[entry.Substation]) {
                    let from = substationMap[entry.Substation];
                    let to = substationMap[target];

                    let key = [entry.Substation, target].sort().join("-");
                    if (!connectionMap[key]) {
                        connectionMap[key] = {count: 0, labels: new Set()};
                    }
                    let offsetIndex = connectionMap[key].count++;

                    let dx = to.lng - from.lng;
                    let dy = to.lat - from.lat;
                    let length = Math.sqrt(dx * dx + dy * dy);

                    if (length > 0) {
                        let offsetAmount = 0.0020 * offsetIndex;
                        let perpX = (-dy / length) * offsetAmount;
                        let perpY = (dx / length) * offsetAmount;

                        let fromOffset = [from.lat + perpY, from.lng + perpX];
                        let toOffset = [to.lat + perpY, to.lng + perpX];

                        const isDashed = entry['LineStyle'] === "dashed";
                        
                        let combinedLine = L.polyline([
                            [from.lat, from.lng], fromOffset, toOffset, [to.lat, to.lng]
                        ], {
                            color: entry['Colour'] ? entry['Colour'].trim() : "blue",
                            weight: 3,
                            dashArray: isDashed ? "5,5" : null,
                            opacity: 0.9
                        }).addTo(map);
                        
                        // Store the connected substations with the line for filtering
                        combinedLine._substations = [entry.Substation, target];
                        
                        // Track connection type
                        if (isDashed) {
                            dashedConnections++;
                        } else {
                            solidConnections++;
                        }
                        
                        combinedLine.bringToFront();
                        connectionsAdded++;

                        let label = labels[index] || "";
                        if (label) {
                            let label1Lat = fromOffset[0] + (2 / 3) * (toOffset[0] - fromOffset[0]);
                            let label1Lng = fromOffset[1] + (2 / 3) * (toOffset[1] - fromOffset[1]);

                            let label2Lat = toOffset[0] + (2 / 3) * (fromOffset[0] - toOffset[0]);
                            let label2Lng = toOffset[1] + (2 / 3) * (fromOffset[1] - toOffset[1]);

                            let labelTooltip1 = L.tooltip({
                                permanent: true,
                                direction: "center",
                                className: "line-label"
                            })
                                .setContent(label)
                                .setLatLng([label1Lat, label1Lng]);

                            let labelTooltip2 = L.tooltip({
                                permanent: true,
                                direction: "center",
                                className: "line-label"
                            })
                                .setContent(label)
                                .setLatLng([label2Lat, label2Lng]);

                            // Store tooltips with the line for visibility control
                            combinedLine._tooltips = [labelTooltip1, labelTooltip2];
                            
                            combinedLine.bindTooltip(labelTooltip1);
                            combinedLine.bindTooltip(labelTooltip2);
                        }
                    }
                }
            });
        }
    });
    
    // Store connection counts globally
    window.connectionCounts = {
        solid: solidConnections,
        dashed: dashedConnections
    };
    
    console.log(`Added ${markersAdded} markers and ${connectionsAdded} connections to the map`);
    console.log(`Connection types: ${solidConnections} solid (existing), ${dashedConnections} dashed (proposed)`);
    showStatus(`Added ${markersAdded} substations and ${connectionsAdded} connections`, 2000);
}

    // Populate substation table
// Modify the populateTable function to include division-based color bands
function populateTable(data) {
    let tableBody = document.getElementById("table-body");
    tableBody.innerHTML = ""; // Clear table before updating

    if (!data.length) {
        console.warn("No data to display in the table.");
        return;
    }

    // Create a map of divisions to colors
    const divisionColors = {};
    const colorPalette = [
        "#f8f9d2", "#e8f4d9", "#d4eedd", "#c5e8ef", 
        "#d6d4f0", "#e9d3e4", "#f2dcd4", "#f9e8d2",
        "#e6f7ff", "#d1e7dd", "#fff3cd", "#f8d7da"
    ];
    
    // Group data by division
    const divisionGroups = {};
    
    data.forEach(entry => {
        const division = entry.Division ? entry.Division.trim() : "Unknown";
        if (!divisionGroups[division]) {
            divisionGroups[division] = [];
        }
        if (entry.Substation) { // Only add valid entries
            divisionGroups[division].push(entry);
        }
    });
    
    // Sort divisions alphabetically
    const sortedDivisions = Object.keys(divisionGroups).sort();
    
    // Assign colors to divisions
    sortedDivisions.forEach((division, index) => {
        divisionColors[division] = colorPalette[index % colorPalette.length];
    });
    
    // Process each division group
    sortedDivisions.forEach(division => {
        // Calculate total MVA for this division
        const totalMVA = divisionGroups[division].reduce((sum, entry) => {
            const mva = parseFloat(entry.MVA);
            return sum + (isNaN(mva) ? 0 : mva);
        }, 0);
        
        // Add division header row with total MVA
        let divisionRow = document.createElement("tr");
        divisionRow.classList.add("division-header");
        divisionRow.innerHTML = `<td colspan="2" style="background-color: #f0f0f0; font-weight: bold; text-align: center;">
            ${division} - Total: ${totalMVA.toFixed(2)} MVA</td>`;
        tableBody.appendChild(divisionRow);
        
        // Sort substations within this division
        const sortedSubstations = divisionGroups[division].sort((a, b) => 
            (a.Substation || "").localeCompare(b.Substation || ""));
        
        // Add each substation in this division
        sortedSubstations.forEach(entry => {
            let substation = entry.Substation ? entry.Substation.trim() : "";
            let mva = entry.MVA ? entry.MVA : "";
            
            let row = document.createElement("tr");
            
            // Apply color based on division
            row.style.backgroundColor = divisionColors[division];
            
            row.innerHTML = `<td>${substation}</td><td>${mva || 'N/A'}</td>`;
            tableBody.appendChild(row);
        });
    });
}

    // Update summary statistics
    function updateSummary(data) {
    let gssCount = 0;
    let gssMVA = 0;
    let ssCount = 0;
    let ssMVA = 0;

    data.forEach(entry => {
        const mva = parseFloat(entry.MVA);
        const substation = entry.Substation || "";
        
        // Check if it's a GSS (has "GSS" in its name)
        if (substation.toUpperCase().includes("GSS")) {
            gssCount++;
            gssMVA += isNaN(mva) ? 0 : mva;
        } else {
            ssCount++;
            ssMVA += isNaN(mva) ? 0 : mva;
        }
    });

    // Update the summary card with the separated counts
    document.getElementById("summary-card").innerHTML = `
        <h4 style="align-items: center; background: white; padding: 5px; border-radius: 5px; box-shadow: 0 0 5px rgba(0,0,0,0.2);">
            33/11kV SS: ${ssCount} / ${ssMVA.toFixed(2)} MVA | 
            GSS: ${gssCount} / ${gssMVA.toFixed(2)} MVA | 
            Total: ${ssCount + gssCount} / ${(ssMVA + gssMVA).toFixed(2)} MVA
        </h4>
    `;
        // Get connection counts (use defaults if not set yet)
        const connectionCounts = window.connectionCounts || { solid: 0, dashed: 0 };
    
    // Update the summary card with the separated counts and add connection info
    document.getElementById("summary-card").innerHTML = `
        <h4 style="align-items: center; background: white; padding: 5px; border-radius: 5px; box-shadow: 0 0 5px rgba(0,0,0,0.2); margin-bottom: 2px;">
            33/11kV SS: ${ssCount} / ${ssMVA.toFixed(2)} MVA | 
            GSS: ${gssCount} / ${gssMVA.toFixed(2)} MVA | 
            Total: ${ssCount + gssCount} / ${(ssMVA + gssMVA).toFixed(2)} MVA
        </h4>
        <h4 style="align-items: center; background: white; padding: 5px; border-radius: 5px; box-shadow: 0 0 5px rgba(0,0,0,0.2); margin-top: 2px;">
            33kV Feeders: ${connectionCounts.solid} Existing | ${connectionCounts.dashed} Proposed | ${connectionCounts.solid + connectionCounts.dashed} Total
        </h4>
    `;
}


    // Handle search functionality
    function handleSearchInput(event) {
    const query = event.target.value.trim().toLowerCase();
    const searchResultsContainer = document.getElementById("search-results");
    
    // Clear previous results
    searchResultsContainer.innerHTML = "";
    
    if (query.length < 2) {
        searchResultsContainer.style.display = "none";
        return;
    }
    
    // Find matching substations
    let matchingStations = [];
    map.eachLayer(layer => {
        if (layer instanceof L.Marker && layer.getPopup()) {
            let popupContent = layer.getPopup().getContent();
            let match = popupContent.match(/<b>(.*?)<\/b>/);
            if (match) {
                let stationName = match[1].trim();
                if (stationName.toLowerCase().includes(query)) {
                    matchingStations.push({
                        name: stationName,
                        marker: layer
                    });
                }
            }
        }
    });
    
    // Sort results alphabetically
    matchingStations.sort((a, b) => a.name.localeCompare(b.name));
    
    // Limit to 10 results for better performance
    matchingStations = matchingStations.slice(0, 10);
    
    if (matchingStations.length > 0) {
        searchResultsContainer.style.display = "block";
        
        matchingStations.forEach(match => {
            let li = document.createElement("li");
            li.textContent = match.name;
            li.addEventListener("click", () => {
                document.getElementById("search-box").value = match.name;
                searchResultsContainer.style.display = "none";
                focusSubstation(match.name);
            });
            searchResultsContainer.appendChild(li);
        });
    } else {
        searchResultsContainer.style.display = "none";
    }
}

    // Focus map on searched substation
    function focusSubstation(name) {
        let searchResultsContainer = document.getElementById("search-results");
        searchResultsContainer.innerHTML = "";
        searchResultsContainer.style.display = "none";
        
        if (!name || name.length < 2) {
            showStatus("Please enter at least 2 characters to search");
            return;
        }

        let lowercaseQuery = name.trim().toLowerCase();
        let matchingMarkers = [];

        // Find matching substations
        map.eachLayer(layer => {
            if (layer instanceof L.Marker && layer.getPopup()) {
                let popupContent = layer.getPopup().getContent();
                let match = popupContent.match(/<b>(.*?)<\/b>/);
                if (match) {
                    let stationName = match[1].trim().toLowerCase();
                    if (stationName.includes(lowercaseQuery)) {
                        matchingMarkers.push({
                            name: match[1], // Original case name
                            marker: layer
                        });
                    }
                }
            }
        });

        if (matchingMarkers.length === 0) {
            showStatus("No substations found matching your search", 3000);
            return;
        } else if (matchingMarkers.length === 1) {
            // If only one match, zoom directly to it
            let marker = matchingMarkers[0].marker;
            let latlng = marker.getLatLng();
            map.flyTo(latlng, 14, {duration: 1.5, easeLinearity: 0.3});
            setTimeout(() => marker.openPopup(), 1500);
            showStatus(`Found: ${matchingMarkers[0].name}`);
        } else {
            // Multiple matches, show results for selection
            searchResultsContainer.style.display = "block";
            matchingMarkers.forEach(match => {
                let li = document.createElement("li");
                li.textContent = match.name;
                li.addEventListener("click", () => {
                    let latlng = match.marker.getLatLng();
                    map.flyTo(latlng, 14, {duration: 1.5, easeLinearity: 0.3});
                    setTimeout(() => match.marker.openPopup(), 1500);
                    searchResultsContainer.style.display = "none";
                    document.getElementById("search-box").value = match.name;
                });
                searchResultsContainer.appendChild(li);
            });
            showStatus(`Found ${matchingMarkers.length} matching substations`);
        }
    }

    // Update legend from data
    function updateLegend(data) {
        // This uses the static legend in HTML for now
        // Could be enhanced to dynamically create from data if needed
    }

    // Initialize the app
    async function initApp() {
        try {
            // Initialize map
            initMap();
            
            // Load state boundaries first
            await loadStateGeoJSON();
            
            // Fetch CSV data with retries
            let retries = 0;
            let maxRetries = 3;
            let success = false;
            
            while (!success && retries < maxRetries) {
                try {
                    showStatus(`Loading substation data (attempt${retries + 1}/${maxRetries})...`);
                    allData = await fetchCSV(csvUrl);
                    success = true;
                } catch (error) {
                    retries++;
                    showStatus(`Error loading data. Retrying (${retries}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before retrying
                }
            }

            if (!success) {
                showStatus("Failed to load substation data after multiple attempts", 5000);
                throw new Error("Failed to load data after multiple retries");
            }

            // Create filter options
            createFilterOptions(allData);
            
            // Plot initial data
            plotMapData(allData);
            
            // Populate the table
            populateTable(allData);
            
            // Update summary stats
            updateSummary(allData);
            
            // Update legend 
            updateLegend(allData);
            
            // Remove loading screen
            loadingDataComplete = true;
            document.getElementById("loading-screen").style.display = "none";
            
            showStatus("Map loaded successfully", 2000);
        } catch (error) {
            console.error("Error initializing application:", error);
            document.getElementById("loading-text").textContent = "Error loading map data. Please try again later.";
            document.getElementById("loading-icon").style.animation = "fade 2s infinite";
        }
    }

    // Handle clicks outside of search results to close dropdown
    document.addEventListener("click", function(event) {
        let searchContainer = document.getElementById("search-container");
        let searchResults = document.getElementById("search-results");
        
        if (!searchContainer.contains(event.target)) {
            searchResults.style.display = "none";
        }
    });

    // Initialize the application
    window.onload = function() {
        initApp();
    };
</script>
</body>
</html>
