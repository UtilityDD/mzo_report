<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Power Map</title>

    <!-- Leaflet Core Library (MUST be loaded first) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" rel="stylesheet" />

    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- Leaflet PolylineDecorator for line styling -->
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.6.0/leaflet.polylineDecorator.min.js"></script>
    <!-- Typed.js for animated text -->
    <script src="https://unpkg.com/typed.js@2.1.0/dist/typed.umd.js"></script>

    <!-- Font Awesome CDN for professional icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- Leaflet.PolylineMeasure plugin -->
    <!-- Leaflet.PolylineMeasure CSS -->
    <link rel="stylesheet" href="https://ppete2.github.io/Leaflet.PolylineMeasure/Leaflet.PolylineMeasure.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet.polylinemeasure@3.0.0/Leaflet.PolylineMeasure.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">


    <!-- jsPDF for Vector PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2pdf.js for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- html2canvas for map capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.75);
            --glass-border: rgba(255, 255, 255, 0.3);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            --accent-color: #2563eb;
            --accent-hover: #1d4ed8;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --bg-blur: blur(12px);
            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
        }

        @keyframes fade {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(0.33);
            }

            80%,
            100% {
                opacity: 0;
            }
        }

        @keyframes pulse-dot {
            0% {
                transform: scale(0.8);
            }

            50% {
                transform: scale(1);
            }

            100% {
                transform: scale(0.8);
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #loading-screen {
            position: fixed;
            width: 100%;
            height: 100vh;
            background: radial-gradient(circle at center, #ffffff 0%, #f1f5f9 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.8s;
        }

        .loader-visualization {
            position: relative;
            width: 120px;
            height: 120px;
            margin-bottom: 40px;
        }

        .pulse-ring {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: var(--accent-color);
            border-radius: 50%;
            animation: pulse-ring 2s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }

        .pulse-dot {
            position: absolute;
            left: 25%;
            top: 25%;
            width: 50%;
            height: 50%;
            background-color: var(--accent-color);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.4);
            animation: pulse-dot 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) -0.4s infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
        }

        .modal-close {
            font-size: 24px;
            font-weight: 600;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: #f1f5f9;
        }

        .modal-close:hover {
            background: #ffe4e6;
            color: #e11d48;
            transform: rotate(90deg);
        }

        #map {
            height: 100vh;
            background: #f8fafc;
        }

        .leaflet-tooltip {
            background: var(--glass-bg);
            backdrop-filter: var(--bg-blur);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm);
            padding: 4px 8px;
            font-size: 11px;
            font-weight: 500;
            box-shadow: var(--glass-shadow);
        }

        #map-legend {
            position: fixed;
            bottom: 24px;
            left: 24px;
            right: auto;
            background: var(--glass-bg);
            backdrop-filter: var(--bg-blur);
            padding: 12px 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            border-radius: var(--radius-md);
            z-index: 1000;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 10px;
            white-space: nowrap;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .custom-symbol:hover,
        .leaflet-interactive:hover {
            cursor: pointer;
            filter: brightness(1.2);
        }

        /* --- Minimized & Glassmorphism Map Layer Control --- */
        .leaflet-control-layers {
            margin-top: 70px !important;
            /* Push below #top-actions-container */
            margin-right: 24px !important;
            background: var(--glass-bg) !important;
            backdrop-filter: var(--bg-blur) !important;
            -webkit-backdrop-filter: var(--bg-blur) !important;
            border: 1px solid var(--glass-border) !important;
            border-radius: var(--radius-md) !important;
            box-shadow: var(--glass-shadow) !important;
            transition: all 0.3s ease;
            overflow: hidden;
            z-index: 1500 !important;
        }

        .leaflet-control-layers-toggle {
            background-size: 20px 20px !important;
            width: 44px !important;
            height: 44px !important;
            transition: transform 0.2s;
        }

        .leaflet-control-layers:hover .leaflet-control-layers-toggle {
            transform: scale(1.1);
        }

        .leaflet-control-layers-expanded {
            padding: 12px 16px !important;
            background: rgba(255, 255, 255, 0.95) !important;
            color: var(--text-primary) !important;
        }

        .leaflet-control-layers-list {
            font-family: inherit !important;
            font-size: 13px !important;
            font-weight: 500 !important;
        }

        .leaflet-control-layers-selector {
            margin-top: 2px !important;
            accent-color: var(--accent-color);
        }

        .leaflet-control-layers-base label {
            display: block;
            margin-bottom: 6px;
            cursor: pointer;
            padding: 4px 0;
            transition: color 0.2s;
        }

        .leaflet-control-layers-base label:hover {
            color: var(--accent-color);
        }

        .leaflet-control-layers-base label:last-child {
            margin-bottom: 0;
        }

        #status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            color: white;
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
            padding: 10px 18px;
            border-radius: 999px;
            z-index: 9999;
            display: none;
            font-weight: 600;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #status-message.show {
            display: inline-flex;
            opacity: 1;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }


        #filter-container {
            position: fixed;
            top: 20px;
            left: 16px;
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
            padding: 20px 16px;
            border-right: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 6px 0 32px rgba(15, 23, 42, 0.12);
            z-index: 2200;
            width: 240px;
            max-width: 240px;
            height: calc(100vh - 40px);
            overflow-y: auto;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-radius: var(--radius-lg);
            box-sizing: border-box;
        }

        #filter-container.collapsed {
            transform: translateX(-100%);
        }

        #filter-container .sidebar-header {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        #filter-container h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.01em;
        }

        .filter-category {
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
            margin: 16px 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .filter-item {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 13px;
            color: var(--text-secondary);
        }
        .filter-item label {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 0;
        }

        #filter-container button {
            width: 100%;
            padding: 10px;
            margin-top: 16px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }

        #filter-container button:hover {
            background: var(--accent-hover);
        }

        /* Report Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 4000;
            /* Above all map interaction but below loading */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: white;
            padding: 24px;
            border-radius: var(--radius-lg);
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
            position: relative;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #report-table-container {
            overflow-x: auto;
            overflow-y: auto;
            flex-grow: 1;
            -webkit-overflow-scrolling: touch;
        }

        .modal-overlay.show .modal-content {
            transform: scale(1);
        }

        #report-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
        }

        #report-table th {
            background: #f8fafc;
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid #e2e8f0;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        #report-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            color: var(--text-primary);
        }

        #report-table tr:hover td {
            background: #f1f5f9;
        }

        /* Progress Bar Styles */
        #progress-container {
            width: 280px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 100px;
            overflow: hidden;
            height: 6px;
            margin: 20px 0;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), #60a5fa);
            box-shadow: 0 0 10px rgba(37, 99, 235, 0.3);
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #loading-text {
            font-size: 15px;
            color: var(--text-secondary);
            font-weight: 500;
            animation: slideUp 0.5s ease-out;
            letter-spacing: 0.02em;
        }

        #toggle-filter-table-container {
            position: fixed;
            top: 20px;
            left: 266px;
            transform: none;
            z-index: 2400;
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #toggle-filter-table-container.collapsed {
            left: 0;
        }

        .toggle-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 48px;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-left: none;
            border-radius: 0 8px 8px 0;
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: background 0.2s;
            color: var(--text-secondary);
        }

        .toggle-icon:hover {
            background: #f8fafc;
            color: var(--accent-color);
        }

        #controls-stack {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            width: min(100%, 540px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            pointer-events: none;
            z-index: 2600;
        }

        #controls-stack > * {
            width: 100%;
            pointer-events: auto;
        }

        #search-container {
            background: var(--glass-bg);
            backdrop-filter: var(--bg-blur);
            padding: 12px 16px 8px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            border-radius: var(--radius-lg);
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: stretch;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #search-box {
            width: 100%;
            padding: 10px 16px;
            border: none;
            background: rgba(255, 255, 255, 0.6);
            border-radius: var(--radius-md);
            font-size: 14px;
            font-family: inherit;
            outline: none;
            transition: background 0.2s;
        }

        #search-box:focus {
            background: rgba(255, 255, 255, 0.9);
        }

        #search-results {
            width: 100%;
            list-style: none;
            margin: 0;
            padding: 0;
            max-height: 240px;
            overflow-y: auto;
            background: transparent;
            display: none;
        }

        #search-results li {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        #search-results li:hover {
            background: rgba(255, 255, 255, 0.5);
            color: var(--accent-color);
        }

        #top-actions-container {
            position: relative;
            z-index: auto;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            padding: 4px 8px;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
        }

        .action-button {
            background: var(--glass-bg);
            backdrop-filter: var(--bg-blur);
            -webkit-backdrop-filter: var(--bg-blur);
            padding: 8px 12px;
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            box-shadow: var(--glass-shadow);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .action-button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        .action-button i {
            font-size: 16px;
            color: var(--accent-color);
        }

        #zoom-level-display {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--glass-bg);
            backdrop-filter: var(--bg-blur);
            padding: 6px 12px;
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 700;
            color: var(--text-secondary);
            z-index: 1400;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            #map-legend {
                display: none !important;
            }

            #controls-stack {
                top: 12px;
                width: calc(100% - 32px);
                max-width: none;
                padding-bottom: 4px;
            }

            #top-actions-container {
                gap: 8px;
            }

            .action-button {
                padding: 0;
                width: 44px;
                height: 44px;
                justify-content: center;
                overflow: hidden;
                border-radius: 50%;
            }

            .action-button span {
                display: none;
            }

            .action-button i {
                margin: 0;
            }

            #filter-container {
                left: 50%;
                right: auto;
                top: auto;
                bottom: 0;
                width: calc(100% - 24px);
                max-width: 540px;
                height: auto;
                max-height: 65vh;
                border-radius: 16px 16px 0 0;
                transform: translate(-50%, 100%);
                box-shadow: 0 -10px 40px rgba(15, 23, 42, 0.35);
                border-right: none;
                padding: 20px;
                transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            #filter-container:not(.collapsed) {
                transform: translate(-50%, 0);
            }

            #filter-container.collapsed {
                transform: translate(-50%, 100%);
            }

            #toggle-filter-table-container {
                top: auto;
                bottom: 110px;
                left: 50%;
                transform: translateX(-50%);
                transition: bottom 0.3s ease;
                z-index: 2400;
            }

            #toggle-filter-table-container.collapsed {
                bottom: 20px;
            }

            .toggle-icon {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                border: 1px solid rgba(15, 23, 42, 0.2);
            }

            #zoom-level-display {
                bottom: 20px;
                right: 20px;
                padding: 4px 8px;
                font-size: 10px;
                background: rgba(255, 255, 255, 0.9);
                z-index: 2900;
            }

            .leaflet-control-layers {
                margin-top: 140px !important;
                margin-right: 12px !important;
            }

            .modal-content {
                padding: 16px;
                width: 100%;
                height: 100%;
                max-width: 100%;
                max-height: 100vh;
                border-radius: 0;
            }

            #report-table {
                font-size: 11px;
            }
        }

        #report-table th,
        #report-table td {
            padding: 8px 10px;
        }


        /* Allow gestures to pass through non-interactive elements */
        #map-legend {
            pointer-events: none;
        }

        /* Interactive elements keep clicks but won't block gestures outside them */
        #search-container,
        #filter-container {
            touch-action: auto;
            /* Allow gestures inside inputs */
        }

        /* Desktop-specific styles */
        @media (min-width: 769px) {
            #filter-container {
                display: block;
                /* Keep filter panel visible on desktop */
            }

            /* ==========================================
           PROFESSIONAL PRINT STYLES (PDF EXPORT)
           ========================================== */
            @media print {
                @page {
                    size: A3 landscape;
                    margin: 10mm;
                }

                body * {
                    visibility: hidden;
                }

                #map,
                #map *,
                #print-report-header,
                #print-report-header *,
                #print-report-footer,
                #print-report-footer * {
                    visibility: visible;
                }

                #map {
                    position: absolute !important;
                    left: 0 !important;
                    top: 120px !important;
                    width: 100% !important;
                    height: calc(100vh - 250px) !important;
                    border: 2px solid #1e293b !important;
                    border-radius: 12px !important;
                }

                #print-report-header {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    display: block !important;
                    border-bottom: 4px solid var(--accent-color);
                    padding-bottom: 10px;
                    font-family: 'Inter', sans-serif;
                }

                #print-report-footer {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    display: block !important;
                    border-top: 1px solid #e2e8f0;
                    padding-top: 10px;
                    font-family: 'Inter', sans-serif;
                }

                .no-print {
                    display: none !important;
                }

                /* Hide UI controls during print */
                .leaflet-control-container,
                #search-container,
                #filter-container,
                #toggle-filter-table-container,
                #zoom-level-display,
                #loading-screen,
                #map-legend {
                    display: none !important;
                }
            }
    </style>
</head>

<body>
    <!-- Print Only Report Elements -->
    <div id="print-report-header" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: flex-end;">
            <div>
                <h1 style="margin: 0; font-size: 32px; font-weight: 800; color: #0f172a;">POWER NETWORK INFRASTRUCTURE
                    REPORT</h1>
                <p id="print-metadata" style="margin: 5px 0 0 0; font-size: 14px; color: #64748b;"></p>
            </div>
            <div style="text-align: right;">
                <span style="font-size: 20px; font-weight: 900; color: #2563eb;">⚡ POWER MAP PRO</span>
            </div>
        </div>
    </div>

    <div id="print-report-footer" style="display: none;">
        <div style="display: flex; justify-content: space-between; font-size: 10px; color: #94a3b8;">
            <span>Generated via Power Map Professional Network Analysis Tool</span>
            <span>Confidential - Grid Infrastructure Data</span>
            <span id="print-date"></span>
        </div>
    </div>
    <div id="loading-screen">
        <div class="loader-visualization">
            <div class="pulse-ring"></div>
            <div class="pulse-dot"><i class="fas fa-bolt"></i></div>
        </div>
        <div id="animated-text-container" style="height: 60px; margin-bottom: 12px; text-align: center;">
            <span id="typed-element" style="font-size: 32px; font-weight: 800; letter-spacing: -0.02em;"></span>
        </div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
        <p id="loading-text">Establishing secure connection...</p>
    </div>

    <!-- Download Overlay -->
    <div id="download-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 9999; justify-content: center; align-items: center; flex-direction: column;">
        <div style="text-align: center; color: white;">
            <div
                style="width: 60px; height: 60px; border: 4px solid rgba(255,255,255,0.3); border-top-color: #2563eb; border-radius: 50%; animation: spin-download 1s linear infinite; margin: 0 auto 20px;">
            </div>
            <h2 style="margin: 0 0 10px; font-size: 24px; font-weight: 700;">Generating PDF...</h2>
            <p style="margin: 0; font-size: 14px; color: rgba(255,255,255,0.7);">Please wait while we prepare your map
            </p>
        </div>
    </div>
    <style>
        @keyframes spin-download {
            to {
                transform: rotate(360deg);
            }
        }
    </style>

    <div id="toggle-filter-table-container" style="">
        <span id="toggle-filter-table" class="toggle-icon"><i class="fa-solid fa-chevron-left"></i></span>
    </div>

    <div id="filter-container">
        <div class="sidebar-header">
            <h3>Filter Options</h3>
        </div>

        <!-- Step 1: Show/Hide Labels Checkbox -->
        <div style="margin-bottom:5px;">
            <label>
                <input type="checkbox" id="toggle-labels">
                Feeder labels
            </label>
        </div>
        <div style="margin-bottom:5px;">
            <label>
                <input type="checkbox" id="toggle-ss-labels">
                SS labels
            </label>
        </div>
        <div style="margin-bottom:5px; margin-left: 20px;">
            <label>
                <input type="checkbox" id="toggle-gss-labels">
                GSS labels only
            </label>
        </div>

        <!-- Proposed SS/Lines Toggle -->
        <div
            style="margin-top: 10px; margin-bottom: 5px; font-weight: bold; border-top: 1px solid #ccc; padding-top: 10px;">
            <label>
                <input type="checkbox" id="toggle-proposed" checked>
                Show Proposed SS/Lines
            </label>
        </div>

        <!-- Opacity Slider -->
        <div style="margin: 10px 0;">
            <label for="mask-opacity-slider" style="display: block; margin-bottom: 5px; font-weight: bold;">Map
                Clarity</label>
            <input type="range" id="mask-opacity-slider" min="0" max="0.8" step="0.05" value="0.3" style="width: 100%;">
        </div>
        <hr style="border: 0; border-top: 1px solid #ccc; margin: 10px 0;">

        <div id="filter-options"></div>
        <div style="margin-top: 20px;">
            <button onclick="applyFilters()" style="width: 100%; padding: 12px; font-weight: 600;">Apply
                Filters</button>
        </div>
        <!-- Handle for vertical resizing -->
        <div id="resize-handle-y"></div>
    </div>

    <div id="map-legend">
        <div class="legend-item"><span class="legend-circle" style="color: red;">⬤</span> Existing 33/11kV SS</div>
        <div class="legend-item"><span class="legend-circle" style="color: rgb(3, 160, 37);">⬤</span> GSS</div>
        <div class="legend-item"><span class="legend-circle" style="color: blue;">⬤</span> Proposed 33/11kV SS</div>
        <div class="legend-item"><span
                style="border-top: 2px solid rgb(255, 0, 0); width: 20px; display: inline-block;"></span> Existing 33kV
            Feeder</div>
        <div class="legend-item"><span style="border-top: 2px dashed blue; width: 20px; display: inline-block;"></span>
            Proposed 33kV Feeder</div>
    </div>

    <div id="status-message"></div>
    <div id="map"></div>

    <div id="controls-stack">
        <div id="search-container">
            <input id="search-box" oninput="handleSearchInput(event)" placeholder="Search Substation..." type="text">
            <ul id="search-results"></ul>
        </div>
        <div id="top-actions-container">
            <button class="action-button" onclick="locateMe()" title="Find my location">
                <i class="fa-solid fa-location-crosshairs"></i> <span>Locate Me</span>
            </button>
            <button class="action-button" onclick="downloadMapImage()" title="Export Map to PDF">
                <i class="fa-solid fa-file-pdf"></i> <span>Download PDF</span>
            </button>
        </div>
    </div>

    <div id="zoom-level-display"></div>

    <!-- Report Modal -->
    <div id="report-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"
                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                <h3 id="report-title" style="margin: 0; font-size: 20px; font-weight: 700;">Report</h3>
                <div class="modal-actions" style="display: flex; align-items: center; gap: 12px;">
                    <button id="export-csv-btn"
                        style="padding: 10px 18px; font-size: 13px; font-weight: 600; cursor: pointer; background-color: #10b981; color: white; border: none; border-radius: 8px; transition: all 0.2s; display: flex; align-items: center; gap: 8px;"><i
                            class="fas fa-file-csv"></i> Export CSV</button>
                    <span class="modal-close"><i class="fa-solid fa-xmark"></i></span>
                </div>
            </div>
            <div id="report-table-container">
                <!-- Report table will be generated here -->
            </div>
        </div>
    </div>
    <script>
        // Global variables
        const csvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT8hYE6YBbfVQDJhgB3cIWqrrGrjMQAQ22mcmCJTOa995gCH-xBAfsAPpBvNYS1KlYIFMRHM59iGB7K/pub?output=csv';
        // IMPORTANT: Replace this URL with the one you published for your "Taps" sheet
        const tapsCsvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT8hYE6YBbfVQDJhgB3cIWqrrGrjMQAQ22mcmCJTOa995gCH-xBAfsAPpBvNYS1KlYIFMRHM59iGB7K/pub?gid=2098159409&single=true&output=csv';
        const geojsonUrl = 'https://raw.githubusercontent.com/shuklaneerajdev/IndiaStateTopojsonFiles/master/WestBengal.geojson';
        let map, worldPolygon, stateLayer, maskLayer;
        let selectedFilters = { Region: new Set(), Division: new Set(), Remarks: new Set() };
        let allData = []; // Store all data for filtering
        let allTapsData = []; // Store all tap data
        let substationMap = {}; // Stores {SubstationName: {lat, lng, marker}}
        let loadingDataComplete = false;
        let allLineLabels = []; // Store all connection line labels for toggling
        let allMarkers = []; // Store all substation markers for toggling labels

        // Show status message and update progress bar
        function showStatus(message, duration = 3000, progress = null) {
            const statusEl = document.getElementById('status-message');
            const progressBar = document.getElementById('progress-bar');
            const loadingText = document.getElementById('loading-text');

            if (loadingText) loadingText.textContent = message; // Update loading text

            if (progress !== null && progressBar) {
                progressBar.style.width = `${progress}%`;
                progressBar.textContent = `${Math.round(progress)}%`; // Display percentage
            }

            statusEl.style.display = 'inline-flex';
            statusEl.classList.add('show');

            // Always hide the status message after a duration unless explicitly set to 0
            if (duration > 0) {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                    statusEl.classList.remove('show');
                }, duration);
            } else if (progress === 100) {
                // For the final load, hide it after a 3-second delay
                setTimeout(() => {
                    statusEl.style.display = 'none';
                    statusEl.classList.remove('show');
                }, 3000);
            }
        }

        // Initialize map
        function initMap() {
            map = L.map('map', {
                preferCanvas: true, // Optimized for image/PDF capture
                zoomControl: false, // Removed default +/- zoom buttons
                minZoom: 7,
                zoomSnap: 0.25,       // Allow fractional zoom
                zoomDelta: 0.25,      // Zoom in/out by 0.25
                zoomAnimation: true,
                zoomAnimationThreshold: 10,
                wheelPxPerZoomLevel: 120,
                inertia: true,
                inertiaDeceleration: 2000,
                dragging: true,       // Ensure dragging works
                touchZoom: true,      // Allow pinch zoom
                tap: false            // Prevent 300ms delay on mobile
            }).setView([23.5, 87.5], 9);

            // Google Maps (Roadmap) tile layer
            const googleStreets = L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                attribution: 'Map data &copy; Google'
            });

            // Google Satellite layer
            const googleSat = L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                attribution: 'Map data &copy; Google'
            });

            // Google Hybrid layer
            const googleHybrid = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                attribution: 'Map data &copy; Google'
            });

            // OpenStreetMap fallback tile layer
            const openStreetMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            });

            // "No map" option - a blank tile layer
            const noMap = L.tileLayer('', {
                attribution: 'No Map Selected',
                maxZoom: 20 // Still allow zooming even if no tiles are loaded
            });

            // Add Google Hybrid as default
            googleHybrid.addTo(map);

            // Optional: Add a layer control to switch between map types
            const baseMaps = {
                "Google Maps": googleStreets,
                "Google Satellite": googleSat,
                "Google Hybrid": googleHybrid,
                "OpenStreetMap": openStreetMap,
                "No Map": noMap // Added "No Map" option
            };

            L.control.layers(baseMaps).addTo(map);

            // Add Leaflet.PolylineMeasure control
            if (typeof L.control.polylineMeasure !== 'undefined') {
                L.control.polylineMeasure({
                    position: 'bottomright', // Moved to avoid sidebar overlap
                    unit: 'kilometres', // Default unit
                    showBearings: false, // Do not show bearings
                    clearMeasurementsOnStop: true, // Clear measurements when tool is deactivated
                    showClearControl: true, // Show a clear button
                    showUnitControl: true // Show unit selection control
                }).addTo(map);
                console.log("Leaflet.PolylineMeasure control added successfully.");
            } else {
                console.error("Leaflet.PolylineMeasure plugin not loaded. Distance measurement tool will not be available.");
            }

            // Add a popup on map click to show coordinates in DMS format
            // Coordinate popup handler
            map.on('click', function (e) {
                // Do not show coordinate popup if a marker was clicked (markers have own popup)
                if (e.originalEvent.target.closest('.leaflet-marker-icon')) {
                    return;
                }

                const lat = e.latlng.lat;
                const lng = e.latlng.lng;

                const dmsLat = decimalToDMS(lat, true);
                const dmsLng = decimalToDMS(lng, false);
                const coordinates = `${dmsLat} ${dmsLng}`;

                const popupContent = `
        <div style="font-family: Arial, sans-serif; font-size: 12px; text-align: center;">
            <b>Coordinates</b><br>${coordinates}<br>
            <button onclick="navigator.clipboard.writeText('${coordinates}')" 
                style="margin-top: 5px; font-size: 10px; padding: 2px 4px; cursor: pointer;">
                Copy
            </button>
        </div>`;

                L.popup()
                    .setLatLng(e.latlng)
                    .setContent(popupContent)
                    .openOn(map);
            });


            return map;
        }

        // --- Navigation Controls ---
        function locateMe() {
            if (!map) return;

            showStatus("Locating you...", 2000, 50);

            map.locate({ setView: true, maxZoom: 16 });

            map.once('locationfound', function (e) {
                showStatus("Location found!", 2000, 100);
                L.circle(e.latlng, e.accuracy).addTo(map)
                    .bindPopup("You are within " + Math.round(e.accuracy) + " meters from this point").openPopup();
            });

            map.once('locationerror', function (e) {
                console.error(e.message);
                showStatus("Location access denied.", 3000, 0);
            });
        }

        // Convert DMS coordinates to decimal
        function dmsToDecimal(dms) {
            if (!dms || typeof dms !== 'string') return NaN;

            let parts = dms.match(/[NSWE]?\d+°\d+\.\d+'/g);
            if (!parts) return NaN;

            let degrees = parseFloat(parts[0].match(/\d+/)[0]);
            let minutes = parseFloat(parts[0].match(/\d+\.\d+/g)[0]);
            let decimal = degrees + minutes / 60;

            if (dms.includes('S') || dms.includes('W')) decimal *= -1;
            return decimal;
        }

        // Convert decimal coordinates to Degrees/Decimal Minutes format
        function decimalToDMS(decimal, isLat) {
            const hemisphere = isLat ? (decimal >= 0 ? 'N' : 'S') : (decimal >= 0 ? 'E' : 'W');
            const absDecimal = Math.abs(decimal);
            const degrees = Math.floor(absDecimal);
            const minutes = (absDecimal - degrees) * 60;

            // Format minutes to 3 decimal places
            const formattedMinutes = minutes.toFixed(3);

            return `${hemisphere}${degrees}°${formattedMinutes}'`;
        }

        // Fetch and parse CSV data
        async function fetchCSV(url) {
            try {
                showStatus("Fetching substation data...", 0, 10); // 10% progress
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch CSV: ${response.status}`);
                }

                const csvText = await response.text();
                showStatus("Processing substation data...", 0, 25); // 25% progress

                return new Promise((resolve) => {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            if (results.data && results.data.length > 0) {
                                // Resolve with all parsed data; validation will happen in the calling function
                                resolve(results.data);
                            } else {
                                console.error("CSV parsing returned no data");
                                showStatus("Error: No data found in CSV", 5000, 40);
                                resolve([]);
                            }
                        },
                        error: (error) => {
                            console.error("CSV parsing error:", error);
                            showStatus("Error parsing data", 5000, 40);
                            resolve([]);
                        }
                    });
                });
            } catch (error) {
                console.error("Error fetching CSV:", error);
                showStatus("Error loading data. Please check console.", 5000, 10);
                return [];
            }
        }

        // Load GeoJSON for West Bengal state boundary
        async function loadStateGeoJSON() {
            try {
                showStatus("Loading state boundaries...", 0, 50); // 50% progress
                const response = await fetch(geojsonUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch GeoJSON: ${response.status}`);
                }

                const data = await response.json();

                // Create world polygon for masking
                worldPolygon = {
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[
                            [-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]
                        ]]
                    }
                };

                // Add state boundaries to map
                stateLayer = L.geoJSON(data, {
                    interactive: false, // Make non-clickable
                    style: {
                        color: "black",
                        weight: 1.5,
                        fillColor: "white", // Add a white fill to mute the base map.
                        fillOpacity: 0.3    // Default clarity is higher (less opaque).
                    }
                }).addTo(map);

                // Process for mask layer
                data.features.forEach(feature => {
                    if (feature.geometry.type === "Polygon") {
                        worldPolygon.geometry.coordinates.push(feature.geometry.coordinates[0]);
                    } else if (feature.geometry.type === "MultiPolygon") {
                        feature.geometry.coordinates.forEach(polygon => {
                            worldPolygon.geometry.coordinates.push(polygon[0]);
                        });
                    }
                });

                // Add mask layer
                maskLayer = L.geoJSON(worldPolygon, {
                    interactive: false, // Make non-clickable
                    style: {
                        color: "#333", // Darker border for the mask
                        weight: 1,
                        fillColor: "#333", // Dark grey color for the mask
                        fillOpacity: 0.7 // Adjust opacity for a darker effect
                    }
                }).addTo(map);

                showStatus("State boundaries loaded.", 0, 60); // 60% progress
                return true;
            } catch (error) {
                console.error("Error loading GeoJSON:", error);
                showStatus("Error loading state boundaries", 5000, 50);
                return false;
            }
        }

        // Create filter options
        function createFilterOptions(data) {
            let filterContainer = document.getElementById("filter-options");
            filterContainer.innerHTML = "";

            const buttonElement = document.querySelector('#filter-container button');
            if (buttonElement) {
                buttonElement.remove();
            }

            let uniqueValues = { Region: new Set(), Division: new Set(), Remarks: new Set() };
            let valueCounts = { Region: {}, Division: {}, Remarks: {} };

            data.forEach(entry => {
                ['Region', 'Division', 'Remarks'].forEach(category => {
                    if (entry[category] && entry[category].trim()) {
                        const value = entry[category].trim();
                        uniqueValues[category].add(value);
                        valueCounts[category][value] = (valueCounts[category][value] || 0) + 1;
                    }
                });
            });

            // Find TCL value case-insensitively
            const tclValue = Array.from(uniqueValues.Region).find(r => r.toUpperCase() === 'TCL');

            // Helper to create a filter item UI element
            const createItemUI = (category, value, count) => {
                let filterItem = document.createElement("div");
                filterItem.classList.add("filter-item");
                let checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.checked = true;
                checkbox.dataset.category = category;
                checkbox.value = value;
                let label = document.createElement("label");
                label.textContent = `${value} (${count})`;
                filterItem.appendChild(checkbox);
                filterItem.appendChild(label);

                let reportIcon = document.createElement("span");
                reportIcon.classList.add("report-icon");
                reportIcon.innerHTML = '<i class="fas fa-chart-bar"></i>';
                reportIcon.title = `View report for ${value}`;
                reportIcon.onclick = () => showReportModal(category, value);
                filterItem.appendChild(reportIcon);

                if (value !== 'All') {
                    selectedFilters[category].add(value); // Add real values to the filter set
                }
                return filterItem;
            };

            // Handle TCL separately if it exists
            if (tclValue) {
                const tclItem = createItemUI('Region', tclValue, valueCounts.Region[tclValue]);
                const tclCheckbox = tclItem.querySelector('input');
                tclCheckbox.addEventListener('change', function () {
                    if (this.checked) { selectedFilters['Region'].add(this.value); }
                    else { selectedFilters['Region'].delete(this.value); }
                    applyFilters();
                });
                filterContainer.appendChild(tclItem);
                let hr = document.createElement('hr');
                hr.style.cssText = 'margin: 10px 0; border: 0; border-top: 1px solid #ccc;';
                filterContainer.appendChild(hr);
            }

            // Add Tapping Sources filter as a single item
            if (allTapsData.length > 0) {
                let filterItem = document.createElement("div");
                filterItem.classList.add("filter-item");

                let checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.checked = true;
                checkbox.id = "toggle-tapping-sources"; // Give it an ID for easy access

                let label = document.createElement("label");
                label.textContent = `Tapping Sources (${allTapsData.length})`;

                let reportIcon = document.createElement("span");
                reportIcon.classList.add("report-icon");
                reportIcon.innerHTML = '<i class="fas fa-chart-bar"></i>';
                reportIcon.title = `View Tapping Sources Report`;
                reportIcon.onclick = () => showTappingReportModal();

                filterItem.appendChild(checkbox);
                filterItem.appendChild(label);
                filterItem.appendChild(reportIcon);

                checkbox.addEventListener('change', applyFilters);

                filterContainer.appendChild(filterItem);
            }

            // Handle categories
            ['Region', 'Division', 'Remarks'].forEach(category => {
                // For Region, filter out TCL since it's handled separately
                const valuesToDisplay = Array.from(uniqueValues[category])
                    .filter(v => category !== 'Region' || (tclValue && v.toUpperCase() !== tclValue.toUpperCase()))
                    .sort();

                if (valuesToDisplay.length > 0) {
                    const categoryDiv = document.createElement("div");
                    categoryDiv.className = "filter-category";
                    categoryDiv.textContent = category;
                    filterContainer.appendChild(categoryDiv);

                    const individualItems = valuesToDisplay.map(value => createItemUI(category, value, valueCounts[category][value]));
                    const individualCheckboxes = individualItems.map(item => item.querySelector('input'));

                    const allItem = createItemUI(category, 'All', valuesToDisplay.length);
                    const allCheckbox = allItem.querySelector('input');

                    allCheckbox.addEventListener('change', function () {
                        const isChecked = this.checked;
                        individualCheckboxes.forEach(cb => {
                            if (cb.checked !== isChecked) {
                                cb.checked = isChecked;
                                isChecked ? selectedFilters[category].add(cb.value) : selectedFilters[category].delete(cb.value);
                            }
                        });
                        applyFilters();
                    });
                    filterContainer.appendChild(allItem);

                    individualItems.forEach((item, index) => {
                        const checkbox = individualCheckboxes[index];
                        checkbox.addEventListener('change', function () {
                            this.checked ? selectedFilters[category].add(this.value) : selectedFilters[category].delete(this.value);
                            allCheckbox.checked = individualCheckboxes.every(cb => cb.checked);
                            applyFilters();
                        });
                        filterContainer.appendChild(item);
                    });
                }
            });
        }

        // Show a detailed report in a modal
        function showReportModal(category, value) {
            const modal = document.getElementById('report-modal');
            const titleEl = document.getElementById('report-title');
            const tableContainer = document.getElementById('report-table-container');

            // Filter data for the report
            const reportData = allData.filter(entry => {
                if (value === 'All') {
                    // For 'All', include everything in that category, respecting the TCL separation for Region
                    if (category === 'Region') {
                        return entry.Region && entry.Region.trim().toUpperCase() !== 'TCL';
                    }
                    return entry[category] && entry[category].trim();
                }
                // For specific values
                return entry[category] && entry[category].trim() === value;
            });

            if (reportData.length === 0) {
                alert(`No data available for ${category}: ${value}`);
                return;
            }

            // Group the filtered data by the 'Remarks' column
            const groupedByRemarks = reportData.reduce((acc, entry) => {
                const remark = (entry.Remarks || 'Uncategorized').trim();
                if (!acc[remark]) {
                    acc[remark] = [];
                }
                acc[remark].push(entry);
                return acc;
            }, {});

            // Generate table HTML
            let tableHtml = '<table id="report-table"><thead><tr><th>Sl. No.</th><th>Region</th><th>Division</th><th>Substation</th><th>Capacity (MVA)</th><th>Peak Load</th><th>Connectivity</th></tr></thead><tbody>';

            // Sort remarks alphabetically for consistent order
            const sortedRemarks = Object.keys(groupedByRemarks).sort();

            sortedRemarks.forEach(remark => {
                let slNo = 1; // Reset serial number for each group
                // Add a header row for the remark group
                tableHtml += `
                <tr>
                    <td colspan="7" style="background-color: #e9ecef; font-weight: bold; text-align: left; padding-left: 10px;">${remark} (${groupedByRemarks[remark].length})</td>
                </tr>
            `;

                // Sort substations within the group by Region, then Division, then Substation name
                const substationsInGroup = groupedByRemarks[remark].sort((a, b) => {
                    const regionCompare = (a.Region || "").localeCompare(b.Region || "");
                    if (regionCompare !== 0) return regionCompare;

                    const divisionCompare = (a.Division || "").localeCompare(b.Division || "");
                    if (divisionCompare !== 0) return divisionCompare;

                    return (a.Substation || "").localeCompare(b.Substation || "");
                });

                substationsInGroup.forEach(ss => {
                    const currentSSName = (ss.Substation || '').trim();
                    if (!currentSSName) return; // Skip if substation has no name

                    const allConnections = []; // Array to hold connection objects {text: '...', isProposed: true/false}

                    // Helper to find a substation's data entry. Memoized for performance.
                    const memoizedGetSubstationEntry = (() => {
                        const cache = new Map();
                        return (name) => {
                            if (cache.has(name)) return cache.get(name);
                            const entry = allData.find(d => (d.Substation || '').trim() === name.trim());
                            cache.set(name, entry);
                            return entry;
                        };
                    })();

                    // 1. Find connections FROM the current substation (outgoing)
                    if (ss['Connected to']) {
                        const connections = ss['Connected to'].split(':').map(s => s.trim()).filter(Boolean);
                        const rls = (ss['RL'] || '').split(':').map(s => s.trim());
                        const peakLoads = (ss['PeakLoad'] || '').toString().split(':').map(s => s.trim());
                        const lineIsProposed = (ss['LineStyle'] || '').toLowerCase() === 'dashed';

                        connections.forEach((conn, index) => {
                            const rl = rls[index] || 'N/A';
                            const targetSSEntry = memoizedGetSubstationEntry(conn);
                            const ssIsProposed = targetSSEntry && (targetSSEntry.Comment || '').toLowerCase() === 'blue';

                            const isProposed = lineIsProposed || ssIsProposed;
                            let statusText = isProposed ? 'Proposed' : (peakLoads[index] || 'N/A');

                            allConnections.push({
                                text: `${conn} (${rl}, ${statusText})`,
                                isProposed: isProposed
                            });
                        });
                    }

                    // 2. Find connections TO the current substation from all other substations (incoming)
                    allData.forEach(otherEntry => {
                        const otherSSName = (otherEntry.Substation || '').trim();
                        // Avoid processing the current SS's own row again, as its outgoing connections are already handled.
                        if (otherSSName && otherSSName !== currentSSName && otherEntry['Connected to']) {
                            const otherConnections = otherEntry['Connected to'].split(':').map(s => s.trim()).filter(Boolean);
                            const otherRLs = (otherEntry['RL'] || '').split(':').map(s => s.trim());
                            const otherPeakLoads = (otherEntry['PeakLoad'] || '').toString().split(':').map(s => s.trim());
                            const lineIsProposed = (otherEntry['LineStyle'] || '').toLowerCase() === 'dashed';
                            otherConnections.forEach((targetConn, index) => {
                                if (targetConn === currentSSName) {
                                    const rl = otherRLs[index] || 'N/A';
                                    const sourceSSEntry = otherEntry;
                                    const ssIsProposed = (sourceSSEntry.Comment || '').toLowerCase() === 'blue';

                                    const isProposed = lineIsProposed || ssIsProposed;
                                    let statusText = isProposed ? 'Proposed' : (otherPeakLoads[index] || 'N/A');

                                    allConnections.push({
                                        text: `${otherSSName} (${rl}, ${statusText})`,
                                        isProposed: isProposed
                                    });
                                }
                            });
                        }
                    });

                    // 3. Find tap connections TO the current substation
                    allTapsData.forEach(tap => {
                        const tappedSS = (tap.TappedSubstation || '').trim();
                        if (tappedSS === currentSSName) {
                            const sourceStart = (tap.SourceFeederStart || 'N/A').trim();
                            const sourceEnd = (tap.SourceFeederEnd || 'N/A').trim();
                            const isProposed = (tap.LineStyle || '').toLowerCase() === 'dashed';

                            const proposedText = isProposed ? ' (Proposed)' : '';
                            const tapText = `Tapped from ${sourceStart}-${sourceEnd} Feeder${proposedText}`;

                            allConnections.push({ text: tapText, isProposed: isProposed });
                        }
                    });

                    // 4. Build the final HTML string from all collected connections
                    let connectivityHtml = 'N/A';
                    if (allConnections.length > 0) {
                        // Sort the connections alphabetically for consistent display
                        const sortedConnections = allConnections.sort((a, b) => a.text.localeCompare(b.text));

                        const proposedCount = sortedConnections.filter(c => c.isProposed).length;
                        const existingCount = sortedConnections.length - proposedCount;

                        let connectionItems = sortedConnections.map(c => c.text);
                        connectivityHtml = connectionItems.join(', ');

                        // Add the summary
                        const summaryHtml = `<br><span style="font-style: italic; color: #0056b3; font-weight: bold;">Existing: ${existingCount}</span>, <span style="font-style: italic; color: #c82333; font-weight: bold;">Proposed: ${proposedCount}</span>`;
                        connectivityHtml += summaryHtml;
                    }

                    tableHtml += `
                    <tr>
                        <td>${slNo++}</td>
                        <td>${ss.Region || 'N/A'}</td>
                        <td>${ss.Division || 'N/A'}</td>
                        <td>${ss.Substation || 'N/A'}</td>
                        <td>${ss.MVA || 'N/A'}</td>
                        <td>${ss['Para-2'] || 'N/A'}</td>
                        <td>${connectivityHtml}</td>
                    </tr>
                `;
                });
            });
            tableHtml += '</tbody></table>';

            // Update modal content and show it
            let reportTitle;
            if (value === 'All') {
                reportTitle = `All ${category}: SS, Loading & Connectivities`;
            } else if (category === 'Region' && value.toUpperCase() === 'TCL') {
                reportTitle = `TCL: SS, Loading & Connectivities`;
            } else {
                reportTitle = `${value} ${category}: SS, Loading & Connectivities`;
            }
            titleEl.textContent = reportTitle;
            tableContainer.innerHTML = tableHtml;
            modal.classList.add('show');
        }

        function exportTableToCSV(filename) {
            const table = document.getElementById("report-table");
            if (!table) {
                console.error("Report table not found for CSV export.");
                return;
            }

            const rows = table.querySelectorAll("tr");
            let csv = [];

            rows.forEach(row => {
                const rowData = [];
                const cells = row.querySelectorAll("th, td");

                if (cells.length === 1 && cells[0].hasAttribute('colspan')) {
                    let headerText = cells[0].textContent.trim();
                    headerText = `"${headerText.replace(/"/g, '""')}"`;
                    rowData.push(headerText);
                } else {
                    cells.forEach(cell => {
                        let cellText = cell.innerText.replace(/\r?\n|\r/g, " | "); // Replace newlines with a separator
                        cellText = cellText.replace(/"/g, '""');
                        if (cellText.includes(',') || cellText.includes('"')) {
                            cellText = `"${cellText}"`;
                        }
                        rowData.push(cellText);
                    });
                }
                csv.push(rowData.join(","));
            });

            const csvContent = csv.join("\n");
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function showTappingReportModal() {
            const modal = document.getElementById('report-modal');
            const titleEl = document.getElementById('report-title');
            const tableContainer = document.getElementById('report-table-container');

            if (allTapsData.length === 0) {
                alert('No tapping source data available.');
                return;
            }

            // Create a lookup map for substation data for efficiency
            const substationDataMap = new Map();
            allData.forEach(entry => {
                if (entry.Substation) {
                    substationDataMap.set(entry.Substation.trim(), entry);
                }
            });

            let tableHtml = '<table id="report-table"><thead><tr><th>Sl. No.</th><th>Tapping Source Feeder</th><th>Tapped Substation</th><th>Division</th><th>Status</th></tr></thead><tbody>';
            let slNo = 1;

            allTapsData.sort((a, b) => (a.SourceFeederStart || "").localeCompare(b.SourceFeederStart || "")).forEach(tap => {
                const sourceStart = (tap.SourceFeederStart || 'N/A').trim();
                const sourceEnd = (tap.SourceFeederEnd || 'N/A').trim();
                const feederName = `${sourceStart}-${sourceEnd} Feeder`;
                const tappedSS = (tap.TappedSubstation || 'N/A').trim();
                const status = (tap.LineStyle || '').toLowerCase() === 'dashed' ? 'Proposed' : 'Existing';

                // Get division from the lookup map
                const tappedSSData = substationDataMap.get(tappedSS);
                const division = tappedSSData ? (tappedSSData.Division || 'N/A') : 'N/A';

                tableHtml += `
                <tr>
                    <td>${slNo++}</td>
                    <td>${feederName}</td>
                    <td>${tappedSS}</td>
                    <td>${division}</td>
                    <td>${status}</td>
                </tr>
            `;
            });

            tableHtml += '</tbody></table>';

            titleEl.textContent = 'Tapping Sources Report';
            tableContainer.innerHTML = tableHtml;
            modal.classList.add('show');
        }

        function updateSSLabelVisibility() {
            const showAll = document.getElementById('toggle-ss-labels').checked;
            const showGSSOnly = document.getElementById('toggle-gss-labels').checked;

            allMarkers.forEach(marker => {
                // First, check if the marker itself is visible on the map
                if (marker.options.opacity > 0) {
                    if (showAll) {
                        // Master switch is on
                        if (showGSSOnly) {
                            // GSS only mode
                            if (marker.options.isGSS) {
                                marker.openTooltip();
                            } else {
                                marker.closeTooltip();
                            }
                        } else {
                            // Show all labels mode
                            marker.openTooltip();
                        }
                    } else {
                        // Master switch is off, hide all labels
                        marker.closeTooltip();
                    }
                } else {
                    // Marker is not visible, ensure its tooltip is closed
                    marker.closeTooltip();
                }
            });
        }

        // Modified applyFilters function to handle connections properly without disturbing the map layers
        function applyFilters() {
            const showProposed = document.getElementById('toggle-proposed').checked;

            // Initialize counts for connections within this function call
            let solidConnectionCount = 0;
            let dashedConnectionCount = 0;
            let tapConnectionCount = 0;

            // Create a map to track substations and their visibility
            let substationVisibility = {};
            let visibleMarkers = new Set();
            let visibleLines = new Set();
            let mapLayersToPreserve = new Set();

            // Make sure we track the layers we want to preserve
            if (stateLayer) mapLayersToPreserve.add(stateLayer);
            if (maskLayer) mapLayersToPreserve.add(maskLayer);
            map.eachLayer(layer => {
                if (layer instanceof L.TileLayer) {
                    mapLayersToPreserve.add(layer);
                }
            });

            // Filter data based on selected filters
            let filteredData = allData.filter(entry => {
                const isProposedSS = (entry.Comment || '').trim().toLowerCase() === 'blue';
                if (!showProposed && isProposedSS) {
                    return false; // Exclude proposed SS if toggle is off
                }

                return (!entry.Region || !entry.Region.trim() || selectedFilters.Region.has(entry.Region.trim())) &&
                    (!entry.Division || !entry.Division.trim() || selectedFilters.Division.has(entry.Division.trim())) &&
                    (!entry.Remarks || !entry.Remarks.trim() || selectedFilters.Remarks.has(entry.Remarks.trim()));
            });

            // Build map of substation names that should be visible
            filteredData.forEach(entry => {
                if (entry.Substation) {
                    substationVisibility[entry.Substation.trim()] = true;
                }
            });

            // Now update visibility of markers and lines without removing base layers
            map.eachLayer(layer => {
                // Skip base map layers that should always remain visible
                if (mapLayersToPreserve.has(layer)) {
                    return;
                }

                if (layer instanceof L.Marker) {
                    // For markers (substations)
                    const stationName = layer.options.substationName;
                    const isVisible = stationName && substationVisibility[stationName];

                    // Update visibility without removing/adding layers
                    if (isVisible) {
                        if (!layer._isVisible) { // Check to avoid redundant operations
                            layer.setOpacity(1);
                            layer.options.interactive = true;
                            layer._isVisible = true;
                        }
                    } else {
                        if (layer._isVisible !== false) { // Check to avoid redundant operations
                            layer.setOpacity(0);
                            layer.options.interactive = false;
                            // Always hide the tooltip when the marker is hidden
                            layer.closeTooltip();
                            layer._isVisible = false;
                        }
                    }
                }
                else if (layer instanceof L.Polyline) {
                    // Skip the state boundary lines
                    if (stateLayer && stateLayer._layers && layer._leaflet_id in stateLayer._layers) {
                        return;
                    }

                    // For connection lines between substations
                    let shouldBeVisible = false;
                    const isProposedLine = layer.options && layer.options.dashArray;

                    if (!showProposed && isProposedLine) {
                        shouldBeVisible = false;
                    } else {
                        // Check if it's a regular connection or a tap connection
                        if (layer._substations) { // Regular connection
                            shouldBeVisible = layer._substations.every(name => substationVisibility[name]);
                        } else if (layer._tapInfo) { // Tap connection
                            const { tapped, source } = layer._tapInfo;
                            const tappingCheckbox = document.getElementById('toggle-tapping-sources');
                            const areTapsVisible = tappingCheckbox ? tappingCheckbox.checked : true;
                            shouldBeVisible = substationVisibility[tapped] && areTapsVisible;
                        }
                        else if (layer._latlngs && layer._latlngs.length >= 2) {
                            // Fallback for lines without metadata (should be rare)
                            let isConnectingVisibleMarkers = false;

                            for (let marker of visibleMarkers) {
                                let markerPos = marker.getLatLng();
                                let firstPoint = layer._latlngs[0];
                                let lastPoint = layer._latlngs[layer._latlngs.length - 1];

                                // Check if this line connects to this marker (approximate)
                                if ((Math.abs(markerPos.lat - firstPoint.lat) < 0.0001 &&
                                    Math.abs(markerPos.lng - firstPoint.lng) < 0.0001) ||
                                    (Math.abs(markerPos.lat - lastPoint.lat) < 0.0001 &&
                                        Math.abs(markerPos.lng - lastPoint.lng) < 0.0001)) {
                                    isConnectingVisibleMarkers = true;
                                    break;
                                }
                            }

                            shouldBeVisible = isConnectingVisibleMarkers;
                        }
                    }

                    // Update visibility without removing/adding layers
                    if (shouldBeVisible) {
                        if (!layer._isVisible) {
                            layer.setStyle({ opacity: 1 });
                            // Show tooltips attached to this line, only if the main toggle is checked
                            if (layer._tooltips && document.getElementById('toggle-labels').checked) {
                                layer._tooltips.forEach(tooltip => {
                                    if (!map.hasLayer(tooltip)) map.addLayer(tooltip);
                                });
                            }
                            layer._isVisible = true;
                        }

                        // Count visible connections by style for summary
                        if (layer.options && layer.options.dashArray) {
                            dashedConnectionCount++;
                        } else {
                            solidConnectionCount++;
                        }

                        // If it's a tap, increment the tap counter
                        if (layer._tapInfo) {
                            tapConnectionCount++;
                        }

                    } else {
                        if (layer._isVisible !== false) {
                            layer.setStyle({ opacity: 0 });
                            // Always hide tooltips when the parent line is hidden
                            if (layer._tooltips) {
                                layer._tooltips.forEach(tooltip => {
                                    if (map.hasLayer(tooltip)) map.removeLayer(tooltip);
                                });
                            }
                            layer._isVisible = false;
                        }
                    }
                }
                // Also check for standalone tooltips (L.Tooltip instances directly added to the map)
                else if (layer instanceof L.Tooltip) {
                    // Find parent layer of the tooltip
                    let parentFound = false;
                    map.eachLayer(potentialParent => {
                        if (potentialParent._tooltip === layer && potentialParent._isVisible === false) {
                            // If parent is not visible, hide this tooltip
                            map.removeLayer(layer);
                            parentFound = true;
                        }
                    });

                    // If no parent found, might be an orphaned tooltip
                    if (!parentFound && layer._source && !layer._source._isVisible) {
                        map.removeLayer(layer);
                    }
                }
            });

            // Update connection counts in window object for summary use
            window.connectionCounts = {
                solid: solidConnectionCount,
                dashed: dashedConnectionCount,
                taps: tapConnectionCount
            };

            showStatus(`Displaying ${filteredData.length} substations`);

            // Update label visibility based on current filter and toggle states
            updateSSLabelVisibility();

            // Ensure state boundaries and mask remain visible
            restoreMapBorders();
        }

        // Restore state boundaries
        function restoreMapBorders() {

            if (maskLayer) {
                maskLayer.bringToBack();
            }
        }

        // Plot tap connections from the Taps sheet
        function plotTaps(tapsData, substationMap) {
            if (!tapsData || tapsData.length === 0) {
                console.log("No tap data to plot.");
                return;
            }

            let tapsAdded = 0;
            tapsData.forEach(tap => {
                const tappedSubstation = tap.TappedSubstation ? tap.TappedSubstation.trim() : null;
                const sourceStart = tap.SourceFeederStart ? tap.SourceFeederStart.trim() : null;
                const sourceEnd = tap.SourceFeederEnd ? tap.SourceFeederEnd.trim() : null;
                const tapLat = dmsToDecimal(tap.TapPointLatitude);
                const tapLng = dmsToDecimal(tap.TapPointLongitude);

                // Ensure all required data is present and valid
                if (tappedSubstation && sourceStart && sourceEnd && !isNaN(tapLat) && !isNaN(tapLng) && substationMap[tappedSubstation]) {
                    const to = substationMap[tappedSubstation];
                    const from = [tapLat, tapLng];

                    const isDashed = tap.LineStyle === "dashed";
                    const color = tap.Colour ? tap.Colour.trim() : "green";

                    let tapLine = L.polyline([from, [to.lat, to.lng]], {
                        color: color,
                        weight: 3,
                        dashArray: isDashed ? "5,5" : null,
                        opacity: 0.9
                    }).addTo(map);

                    // Attach metadata for filtering
                    tapLine._tapInfo = {
                        tapped: tappedSubstation,
                        source: [sourceStart, sourceEnd]
                    };

                    tapLine.bringToFront();
                    tapsAdded++;
                } else {
                    console.warn("Skipping invalid tap entry:", tap);
                }
            });

            // Update the global taps count for the summary card
            if (window.connectionCounts) {
                window.connectionCounts.taps = tapsAdded;
            }

            console.log(`Added ${tapsAdded} tap connections to the map.`);
        }

        // Plot map data (substations and connections)
        function plotMapData(data) {
            substationMap = {}; // Reset substationMap on each plot
            let connectionMap = {};
            let markersAdded = 0;
            let connectionsAdded = 0;
            // Add counters for connection types
            let solidConnections = 0;
            let dashedConnections = 0;

            // First pass: create all substation markers
            data.forEach(entry => {
                let lat = dmsToDecimal(entry.LATITUDE);
                let lng = dmsToDecimal(entry.LONGITUDE);

                if (!isNaN(lat) && !isNaN(lng) && entry.Substation) {
                    let markerColor = (entry.Comment && ["black", "white", "red", "blue", "green", "yellow", "purple", "orange"].includes(entry.Comment.trim().toLowerCase()))
                        ? entry.Comment.trim().toLowerCase()
                        : "black";

                    let symbol = entry.Symbol ? entry.Symbol.trim() : "⚡";
                    let fontSize = entry.SymbolSize && !isNaN(entry.SymbolSize) ? parseInt(entry.SymbolSize) : 18;
                    let size = fontSize * 1.2;
                    let iconSize = [size, size];
                    let iconAnchor = [size / 2, size / 2];

                    let marker = L.marker([lat, lng], {
                        icon: L.divIcon({
                            className: "custom-symbol",
                            html: `<div style="
                        width: ${size}px; 
                        height: ${size}px; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        border-radius: 50%; 
                        font-size: ${fontSize}px; 
                        font-weight: bold; 
                        color: ${markerColor};
                        text-align: center;">
                        ${symbol}
                    </div>`,
                            iconSize: iconSize,
                            iconAnchor: iconAnchor,
                        })
                    }).addTo(map)
                        .bindTooltip(entry.Substation, { permanent: true, direction: "top", className: "leaflet-tooltip" })

                    // Add a custom property to the marker for robust filtering
                    marker.options.substationName = entry.Substation.trim();
                    marker.options.isGSS = (entry.Substation || '').toUpperCase().includes("GSS");

                    marker.closeTooltip(); // Hide permanent tooltip by default
                    allMarkers.push(marker); // Store for label toggling

                    // Create Google Street View URL and popup content
                    const streetViewUrl = `https://www.google.com/maps?q=&layer=c&cbll=${lat},${lng}&cbp=12,0,0,0,0`;
                    const popupContent = `
                    <div style="font-family: Arial, sans-serif; font-size: 12px; min-width: 150px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <b style="font-size: 14px;">${entry.Substation}</b>
                            <a href="${streetViewUrl}" target="_blank" title="Open 3D Street View" style="color: #337ab7; text-decoration: none; font-size: 16px; margin-left: 10px;"><i class="fas fa-street-view"></i></a>
                        </div>
                        Capacity: ${entry['MVA']}<br>Para-2: ${entry['Para-2'] || 'N/A'}<br>Para-3: ${entry['Para-3'] || 'N/A'}
                    </div>`;
                    marker.bindPopup(popupContent);

                    substationMap[entry.Substation.trim()] = { lat, lng, marker }; // Store with trimmed name
                    markersAdded++;
                } else {
                    console.warn(`Skipping substation "${entry.Substation}" due to invalid coordinates: LATITUDE=${entry.LATITUDE}, LONGITUDE=${entry.LONGITUDE}`);
                }
            });

            // Second pass: create connections between substations
            data.forEach(entry => {
                if (entry['Connected to']) {
                    let connections = entry['Connected to'].split(':').map(s => s.trim());
                    let labels = entry['RL'] ? entry['RL'].split(':').map(s => s.trim()) : [];
                    let conductorSizes = entry['ConductorSize'] ? String(entry['ConductorSize']).split(':').map(s => s.trim()) : [];
                    let peakLoads = entry['PeakLoad'] ? String(entry['PeakLoad']).split(':').map(s => s.trim()) : [];

                    connections.forEach((target, index) => {
                        if (substationMap[target] && substationMap[entry.Substation.trim()]) { // Use trimmed name
                            let from = substationMap[entry.Substation.trim()];
                            let to = substationMap[target];

                            let key = [entry.Substation.trim(), target].sort().join("-"); // Use trimmed name for key
                            if (!connectionMap[key]) {
                                connectionMap[key] = { count: 0, labels: new Set() };
                            }
                            let offsetIndex = connectionMap[key].count++;

                            let dx = to.lng - from.lng;
                            let dy = to.lat - from.lat;
                            let length = Math.sqrt(dx * dx + dy * dy);

                            if (length > 0) {
                                let offsetAmount = 0.0020 * offsetIndex;
                                let perpX = (-dy / length) * offsetAmount;
                                let perpY = (dx / length) * offsetAmount;

                                let fromOffset = [from.lat + perpY, from.lng + perpX];
                                let toOffset = [to.lat + perpY, to.lng + perpX];

                                const isDashed = entry['LineStyle'] === "dashed";

                                let combinedLine = L.polyline([
                                    [from.lat, from.lng], fromOffset, toOffset, [to.lat, to.lng]
                                ], {
                                    color: entry['Colour'] ? entry['Colour'].trim() : "blue",
                                    weight: 3,
                                    dashArray: isDashed ? "5,5" : null,
                                    opacity: 0.9
                                }).addTo(map);

                                // Attach feeder data and click event for popup
                                const feederInfo = {
                                    conductor: conductorSizes[index] || "N/A",
                                    load: peakLoads[index] || "N/A",
                                    source: entry.Substation.trim(),
                                    target: target
                                };

                                combinedLine.on('click', function (e) {
                                    const info = feederInfo;
                                    const popupContent = `
                                    <div style="font-family: Arial, sans-serif; font-size: 12px; text-align: left; min-width: 150px;">
                                        <b style="text-align: center; display: block;">Feeder Details</b>
                                        <b>From:</b> ${info.source}<br>
                                        <b>To:</b> ${info.target}<br>
                                        <b>Conductor:</b> ${info.conductor}<br>
                                        <b>Peak Load:</b> ${info.load}
                                    </div>`;
                                    L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map);

                                    // Prevent the map's click event (which shows coordinates) from firing
                                    L.DomEvent.stopPropagation(e);
                                });

                                // Store the connected substations with the line for filtering
                                combinedLine._substations = [entry.Substation.trim(), target]; // Use trimmed name

                                // Track connection type
                                if (isDashed) {
                                    dashedConnections++;
                                } else {
                                    solidConnections++;
                                }

                                combinedLine.bringToFront();
                                connectionsAdded++;

                                let label = labels[index] || "";
                                if (label) {
                                    let label1Lat = fromOffset[0] + (2 / 3) * (toOffset[0] - fromOffset[0]);
                                    let label1Lng = fromOffset[1] + (2 / 3) * (toOffset[1] - fromOffset[1]);

                                    let label2Lat = toOffset[0] + (2 / 3) * (fromOffset[0] - toOffset[0]);
                                    let label2Lng = toOffset[1] + (2 / 3) * (fromOffset[1] - toOffset[1]);

                                    let labelTooltip1 = L.tooltip({
                                        permanent: true,
                                        direction: "center",
                                        className: "line-label"
                                    })
                                        .setContent(label)
                                        .setLatLng([label1Lat, label1Lng]);

                                    let labelTooltip2 = L.tooltip({
                                        permanent: true,
                                        direction: "center",
                                        className: "line-label"
                                    })
                                        .setContent(label)
                                        .setLatLng([label2Lat, label2Lng]);
                                    allLineLabels.push(labelTooltip1, labelTooltip2);

                                    // Store tooltips with the line for visibility control
                                    combinedLine._tooltips = [labelTooltip1, labelTooltip2];
                                }
                            }
                        }
                    });
                }
            });

            // Store connection counts globally
            window.connectionCounts = {
                solid: solidConnections,
                dashed: dashedConnections,
                taps: 0 // Initialize taps, will be updated by plotTaps
            };

            console.log(`Added ${markersAdded} markers and ${connectionsAdded} connections to the map`);
            console.log(`Connection types: ${solidConnections} solid (existing), ${dashedConnections} dashed (proposed)`);
            showStatus(`Added ${markersAdded} substations and ${connectionsAdded} connections`, 0, 90); // 90% progress
        }

        // Handle search functionality
        function handleSearchInput(event) {
            const query = event.target.value.trim().toLowerCase();
            const searchResultsContainer = document.getElementById("search-results");

            // Clear previous results
            searchResultsContainer.innerHTML = "";

            if (query.length < 2) {
                searchResultsContainer.style.display = "none";
                return;
            }

            let matchingStations = [];
            // Iterate through allData to find matches, then check if a marker exists for it
            allData.forEach(entry => {
                const stationName = entry.Substation ? entry.Substation.trim() : '';
                if (stationName.toLowerCase().includes(query) && substationMap[stationName]) { // Check if marker exists
                    matchingStations.push({
                        name: stationName,
                        marker: substationMap[stationName].marker // Directly get the marker if it exists
                    });
                }
            });

            matchingStations.sort((a, b) => a.name.localeCompare(b.name));
            matchingStations = matchingStations.slice(0, 10);

            if (matchingStations.length > 0) {
                searchResultsContainer.style.display = "block";

                matchingStations.forEach(match => {
                    let li = document.createElement("li");
                    li.textContent = match.name;
                    li.addEventListener("click", () => {
                        document.getElementById("search-box").value = match.name;
                        searchResultsContainer.style.display = "none";
                        focusSubstation(match.name); // Pass the exact name
                    });
                    searchResultsContainer.appendChild(li);
                });
            } else {
                searchResultsContainer.style.display = "none";
            }
        }

        // Focus map on searched substation
        function focusSubstation(name) {
            let searchResultsContainer = document.getElementById("search-results");
            searchResultsContainer.innerHTML = "";
            searchResultsContainer.style.display = "none";

            if (!name || name.length < 2) {
                showStatus("Please enter at least 2 characters to search");
                return;
            }

            const targetSubstationName = name.trim();
            const substationInfo = substationMap[targetSubstationName]; // Directly get info from map

            if (substationInfo && substationInfo.marker) {
                let marker = substationInfo.marker;
                let latlng = marker.getLatLng();
                map.flyTo(latlng, 14, { duration: 1.5, easeLinearity: 0.3 });
                setTimeout(() => marker.openPopup(), 1500);
                showStatus(`Found: ${targetSubstationName}`);
            } else {
                showStatus(`Substation "${targetSubstationName}" not found on map. It might have invalid coordinates or be filtered out.`, 5000);
            }
        }

        // Update legend from data
        function updateLegend(data) {
            // This uses the static legend in HTML for now
            // Could be enhanced to dynamically create from data if needed
        }

        // Function to make an element draggable
        function makeDraggable(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = elmnt.querySelector("h3"); // Assuming h3 is the header/handle

            if (header) {
                // if present, the header is where you move the DIV from:
                header.onmousedown = dragMouseDown;
            } else {
                // otherwise, move the DIV from anywhere inside the DIV:
                elmnt.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // get the mouse cursor position at startup:
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // call a function whenever the cursor moves:
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                // calculate the new cursor position:
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                // set the element's new position:
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
                // Unset right/bottom to prevent conflicts when dragging elements
                // that are initially positioned with `right` or `bottom` in CSS.
                elmnt.style.right = 'auto';
                elmnt.style.bottom = 'auto';
            }

            function closeDragElement() {
                // stop moving when mouse button is released:
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // Function to make an element vertically resizable
        function makeResizable(elmnt) {
            const handle = elmnt.querySelector("#resize-handle-y");
            if (!handle) return;

            handle.onmousedown = function (e) {
                e.preventDefault();
                let startY = e.clientY;
                let startHeight = parseInt(document.defaultView.getComputedStyle(elmnt).height, 10);

                function doDrag(e) {
                    const newHeight = startHeight + e.clientY - startY;
                    // Set min and max height constraints
                    const minHeight = 150;
                    const maxHeight = window.innerHeight - elmnt.offsetTop - 20; // 20px buffer from bottom

                    if (newHeight > minHeight && newHeight < maxHeight) {
                        elmnt.style.height = newHeight + 'px';
                    }
                }

                function stopDrag() {
                    document.documentElement.removeEventListener('mousemove', doDrag, false);
                    document.documentElement.removeEventListener('mouseup', stopDrag, false);
                }

                document.documentElement.addEventListener('mousemove', doDrag, false);
                document.documentElement.addEventListener('mouseup', stopDrag, false);
            };
        }

        // Initialize the app
        async function initApp() {
            try {
                showStatus("Initializing map...", 0, 0); // 0% progress
                // Initialize map
                initMap();

                // Load state boundaries first
                await loadStateGeoJSON(); // Progress updated inside this function

                // Fetch CSV data with retries
                let retries = 0;
                let maxRetries = 3;
                let success = false;

                while (!success && retries < maxRetries) {
                    try {
                        let rawData = await fetchCSV(csvUrl); // Fetch raw data

                        // Filter for entries with valid coordinates before storing
                        allData = rawData.filter(entry =>
                            entry.LATITUDE &&
                            entry.LONGITUDE &&
                            !isNaN(dmsToDecimal(entry.LATITUDE)) &&
                            !isNaN(dmsToDecimal(entry.LONGITUDE))
                        );
                        showStatus(`Loaded ${allData.length} substations`, 0, 40); // 40% progress
                        success = true;
                    } catch (error) {
                        retries++;
                        showStatus(`Error loading data. Retrying (${retries}/${maxRetries})...`, 0, 10 + (retries * 5)); // Increment progress on retry
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before retrying
                    }
                }

                if (!success) {
                    showStatus("Failed to load substation data after multiple attempts", 5000, 100);
                    throw new Error("Failed to load data after multiple retries");
                }

                // Calculate the center of the network to focus the map
                if (allData.length > 0) {
                    const bounds = L.latLngBounds();
                    allData.forEach(entry => {
                        const lat = dmsToDecimal(entry.LATITUDE);
                        const lng = dmsToDecimal(entry.LONGITUDE);
                        // The data is already pre-filtered for valid coordinates, but we double-check.
                        if (!isNaN(lat) && !isNaN(lng)) {
                            bounds.extend([lat, lng]);
                        }
                    });
                    // Set the map view to the center of all substations at the desired zoom level
                    if (bounds.isValid()) map.setView(bounds.getCenter(), 9);
                }

                // Fetch Taps data
                if (tapsCsvUrl && tapsCsvUrl !== 'YOUR_TAPS_SHEET_PUBLISHED_CSV_URL_HERE') {
                    showStatus("Fetching tapping point data...", 0, 65); // 65% progress
                    allTapsData = await fetchCSV(tapsCsvUrl); // This now correctly fetches all tap rows
                }

                // Create filter options
                showStatus("Creating filter options...", 0, 70); // 70% progress
                createFilterOptions(allData);

                // Plot initial data
                plotMapData(allData); // Progress updated inside this function

                // Plot taps data after substations are mapped
                plotTaps(allTapsData, substationMap);
                // Summary card removed, no need to update stats

                // Update legend 
                showStatus("Updating legend...", 0, 99); // 99% progress
                updateLegend(allData);

                // Remove loading screen
                loadingDataComplete = true;
                showStatus("Map loaded successfully!", 3000, 100); // 100% progress

                // Smooth fade out of the initial loading screen
                setTimeout(() => {
                    const screen = document.getElementById("loading-screen");
                    if (screen) {
                        screen.style.opacity = "0";
                        setTimeout(() => {
                            screen.style.visibility = "hidden";
                        }, 500);
                    }
                }, 1200);

            } catch (error) {
                console.error("Error initializing application:", error);
                document.getElementById("loading-text").textContent = "Error loading map data. Please try again later.";
                // document.getElementById("loading-icon").style.animation = "fade 2s infinite"; // Removed rotating animation
                document.getElementById("progress-bar").style.width = "0%"; // Reset progress on error
                document.getElementById("progress-bar").textContent = "Error";
                document.getElementById("progress-container").style.backgroundColor = "#ffdddd"; // Indicate error
            }
        }

        // Handle clicks outside of search results to close dropdown
        document.addEventListener("click", function (event) {
            let searchContainer = document.getElementById("search-container");
            let searchResults = document.getElementById("search-results");

            if (!searchContainer.contains(event.target)) {
                searchResults.style.display = "none";
            }
        });


        async function downloadMapImage() {
            console.log("downloadMapImage() called");

            // Show download overlay
            const downloadOverlay = document.getElementById('download-overlay');
            downloadOverlay.style.display = 'flex';

            // Small delay to ensure overlay is visible before heavy processing
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                console.log("Step 1: Checking SS labels...");
                // 0. Force-enable SS labels only (not feeder labels)
                const ssLabelCheckbox = document.getElementById('toggle-ss-labels');
                const originalSSState = ssLabelCheckbox ? ssLabelCheckbox.checked : false;

                if (ssLabelCheckbox && !ssLabelCheckbox.checked) {
                    ssLabelCheckbox.checked = true;
                    ssLabelCheckbox.dispatchEvent(new Event('change'));
                }

                console.log("Step 2: Filtering markers...");
                // 1. Determine the MINIMUM bounds of the network (no extra padding for consistent sizing)
                // allMarkers contains actual Leaflet marker objects, visibility is via opacity
                const visibleMarkers = allMarkers.filter(m => m.options && m.options.opacity > 0);
                console.log("Visible markers count:", visibleMarkers.length);

                if (visibleMarkers.length === 0) {
                    showStatus("No data selected to export", 3000, 100);
                    console.log("No visible markers, returning early");
                    return;
                }

                console.log("Step 3: Calculating bounds...");
                // Calculate bounds directly from markers (they are Leaflet markers)
                const group = new L.featureGroup(visibleMarkers);
                let bounds = group.getBounds();
                // Small padding just for labels (5%)
                bounds = bounds.pad(0.05);

                // 2. Calculate DEVICE-INDEPENDENT pixel dimensions for Zoom Level 11
                // Use Web Mercator formula: pixels = (256 * 2^zoom) / 360 * degreesLng
                const TARGET_ZOOM = 11;
                const TILE_SIZE = 256;
                const scale = TILE_SIZE * Math.pow(2, TARGET_ZOOM);

                // Convert bounds to pixel coordinates (consistent regardless of device)
                function latLngToPixel(lat, lng, zoom) {
                    const s = TILE_SIZE * Math.pow(2, zoom);
                    const x = (lng + 180) / 360 * s;
                    // Mercator Y projection
                    const latRad = lat * Math.PI / 180;
                    const y = (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * s;
                    return { x, y };
                }

                const topLeft = latLngToPixel(bounds.getNorth(), bounds.getWest(), TARGET_ZOOM);
                const bottomRight = latLngToPixel(bounds.getSouth(), bounds.getEast(), TARGET_ZOOM);

                let targetWidth = Math.ceil(Math.abs(bottomRight.x - topLeft.x));
                let targetHeight = Math.ceil(Math.abs(bottomRight.y - topLeft.y));

                // Add fixed padding for SS labels (100px each side)
                targetWidth += 200;
                targetHeight += 200;

                // --- Borderless Aspect Ratio Logic ---
                // Determine orientation based on network shape
                const isLandscape = targetWidth >= targetHeight;
                const headerHeightMM = 20;
                const a3WidthMM = 420;
                const a3HeightMM = 297;

                // Content area in mm (leaving space for header)
                const contentW_MM = isLandscape ? a3WidthMM : a3HeightMM;
                const contentH_MM = (isLandscape ? a3HeightMM : a3WidthMM) - headerHeightMM;
                const targetRatio = contentW_MM / contentH_MM;

                // Adjust target pixels to match A3 aspect ratio exactly
                const currentRatio = targetWidth / targetHeight;
                if (currentRatio > targetRatio) {
                    // Map is wider than A3 content area, increase height
                    targetHeight = Math.ceil(targetWidth / targetRatio);
                } else {
                    // Map is taller than A3 content area, increase width
                    targetWidth = Math.ceil(targetHeight * targetRatio);
                }

                // Safety Clamp: Don't let it crash the browser with 20k pixels
                const MAX_DIMENSION = 8000;
                if (targetWidth > MAX_DIMENSION || targetHeight > MAX_DIMENSION) {
                    const ratio = Math.min(MAX_DIMENSION / targetWidth, MAX_DIMENSION / targetHeight);
                    targetWidth *= ratio;
                    targetHeight *= ratio;
                    console.warn(`Map too large for Zoom 11.5, scaled down by ${ratio.toFixed(2)}`);
                    showStatus(`Area too large for full detail. Scaling to fit...`, 2000, 10);
                }

                console.log(`Resizing map to: ${targetWidth}px x ${targetHeight}px for Zoom ${TARGET_ZOOM}`);
                showStatus("Resizing view for high complexity...", 10, 20);

                // 3. Prepare UI for Clean Capture
                const mapContainer = document.getElementById('map');
                const originalStyle = {
                    width: mapContainer.style.width,
                    height: mapContainer.style.height,
                    position: mapContainer.style.position,
                    zIndex: mapContainer.style.zIndex
                };

                // Hide overlays
                const hideElements = ['search-container', 'filter-container', 'toggle-filter-table-container', 'zoom-level-display', 'loading-screen', 'leaflet-control-container', 'top-actions-container'];
                hideElements.forEach(id => {
                    const el = document.getElementById(id) || document.querySelector(`.${id}`);
                    if (el) el.style.opacity = '0';
                });

                // 4. Resize Map Container (Temporary)
                // We make it huge but potentially overflow hidden on body so it doesn't break page scroll too much ???
                // Actually, if we set it absoluteTop 0, Left 0, it just covers everything or goes off screen.
                mapContainer.style.width = `${targetWidth}px`;
                mapContainer.style.height = `${targetHeight}px`;
                mapContainer.style.zIndex = '-1'; // Hide behind if needed, or just let it overlay

                // Trigger Leaflet Update
                map.invalidateSize();
                map.setView(bounds.getCenter(), TARGET_ZOOM, { animate: false });

                // 5. Critical Wait: Allow tiles to load
                // At zoom 11.5 with a large area, network download might take time
                let waitTime = 2500;
                // Simple heuristic: larger area = longer wait
                if (targetWidth > 3000) waitTime = 4000;

                showStatus("Rendering detailed map tiles...", 20, 60);
                await new Promise(resolve => setTimeout(resolve, waitTime));

                // 6. Capture at 1.5x scale for optimal balance
                showStatus("Capturing High-Resolution Map...", 60, 80);
                const canvas = await html2canvas(mapContainer, {
                    useCORS: true,
                    allowTaint: true,
                    scale: 1.5, // 1.5x resolution - optimal balance between quality and file size
                    logging: false,
                    backgroundColor: '#f8fafc', // Light background for better contrast
                    width: targetWidth,
                    height: targetHeight,
                    scrollX: 0,
                    scrollY: 0,
                    windowWidth: targetWidth,
                    windowHeight: targetHeight,
                    removeContainer: false
                });

                // 7. Cleanup & Download
                // Restore Styles
                mapContainer.style.width = originalStyle.width;
                mapContainer.style.height = originalStyle.height;
                mapContainer.style.position = originalStyle.position;
                mapContainer.style.zIndex = originalStyle.zIndex;

                // Restore UI
                hideElements.forEach(id => {
                    const el = document.getElementById(id) || document.querySelector(`.${id}`);
                    if (el) el.style.opacity = '1';
                });

                // Restore View (Optional, but nice to go back to what user was looking at)
                map.invalidateSize();
                map.fitBounds(bounds);

                // Save as PDF
                showStatus("Generating Professional PDF...", 80, 95);

                const { jsPDF } = window.jspdf;

                // Determine PDF orientation (must match the logic above)
                const orientation = canvas.width >= canvas.height ? 'landscape' : 'portrait';

                // Create PDF with appropriate size and compression
                const doc = new jsPDF({
                    orientation: orientation,
                    unit: 'mm',
                    format: 'a3',
                    compress: true // Enable compression for smaller file size
                });

                // Get page dimensions
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const headerHeight = 22; // Slightly larger for better spacing

                // Professional gradient header with refined styling
                doc.setFillColor(37, 99, 235);
                doc.rect(0, 0, pageWidth, headerHeight, 'F');
                
                // Add subtle accent line
                doc.setFillColor(59, 130, 246);
                doc.rect(0, headerHeight - 1, pageWidth, 1, 'F');

                // Title
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(20);
                doc.setFont("helvetica", "bold");
                doc.text("Power Map: Malda Zone", 12, 14);

                // Metadata section with better formatting
                doc.setFontSize(9);
                doc.setFont("helvetica", "normal");
                const dateStr = new Date().toLocaleDateString('en-IN', {
                    day: '2-digit',
                    month: 'short',
                    year: 'numeric'
                });
                const timeStr = new Date().toLocaleTimeString('en-IN', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                doc.text(`Generated: ${dateStr} ${timeStr}`, pageWidth - 60, 14);

                // Convert canvas to optimized image
                // Use JPEG with 0.85 quality for good balance between clarity and size
                const imgData = canvas.toDataURL('image/jpeg', 0.85);
                
                // Add the map image with subtle border
                const mapMargin = 2;
                doc.addImage(
                    imgData, 
                    'JPEG', 
                    mapMargin, 
                    headerHeight + mapMargin, 
                    pageWidth - (2 * mapMargin), 
                    pageHeight - headerHeight - (2 * mapMargin),
                    undefined,
                    'MEDIUM' // MEDIUM compression for optimal quality/size balance
                );

                // Add professional footer
                const footerY = pageHeight - 4;
                doc.setFontSize(7);
                doc.setTextColor(100, 116, 139);
                doc.text('Power Map Pro - Network Infrastructure Analysis', 12, footerY);
                doc.text(`Page 1 of 1`, pageWidth - 30, footerY);

                // Save the PDF with optimized filename
                const selectedRegion = Array.from(selectedFilters.Region)[0] || 'MaldaZone';
                const timestamp = new Date().toISOString().split('T')[0].replace(/-/g, '');
                doc.save(`PowerMap_${selectedRegion}_${timestamp}.pdf`);

                // Restore original SS label state
                if (ssLabelCheckbox) {
                    ssLabelCheckbox.checked = originalSSState;
                    ssLabelCheckbox.dispatchEvent(new Event('change'));
                }

                // Hide download overlay
                downloadOverlay.style.display = 'none';
                showStatus("PDF Downloaded Successfully!", 3000, 100);

            } catch (error) {
                console.error("Detailed Map Capture failed:", error);

                // Restore UI in case of error
                const hideElements = ['search-container', 'filter-container', 'toggle-filter-table-container', 'zoom-level-display', 'loading-screen', 'leaflet-control-container', 'top-actions-container'];
                hideElements.forEach(id => {
                    const el = document.getElementById(id) || document.querySelector(`.${id}`);
                    if (el) el.style.opacity = '1';
                });
                const mapContainer = document.getElementById('map');
                mapContainer.style.width = '100%';
                mapContainer.style.height = '100vh';
                map.invalidateSize();

                // Hide download overlay on error
                document.getElementById('download-overlay').style.display = 'none';
                showStatus("Capture failed. Try selecting fewer features.", 5000, 100);
            }
        }


        // Initialize the application and attach event listeners once the DOM is fully loaded
        window.onload = async function () {
            // Initialize Typed.js for loading animation
            if (typeof Typed !== 'undefined') {
                new Typed('#typed-element', {
                    strings: ['Loading Power Map...', 'Please wait a moment.'],
                    typeSpeed: 50,
                    backSpeed: 30,
                    loop: true,
                    smartBackspace: true,
                });
            }

            await initApp(); // Ensure main app initialization is complete

            // Make floating panels draggable
            // makeDraggable(document.getElementById('filter-container'));
            // makeResizable(document.getElementById('filter-container'));

            // Initialize filter container state
            const filterContainer = document.getElementById('filter-container');
            const toggleContainer = document.getElementById('toggle-filter-table-container');
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                filterContainer.classList.add('collapsed');
                toggleContainer.classList.add('collapsed');
                const icon = document.getElementById('toggle-filter-table').querySelector('i');
                icon.classList.remove('fa-chevron-left');
                icon.classList.add('fa-chevron-right');
            }

            // Add event listener for filter table toggle icon
            document.getElementById('toggle-filter-table').addEventListener('click', function () {
                const filterContainer = document.getElementById('filter-container');
                const toggleContainer = document.getElementById('toggle-filter-table-container');
                const icon = this.querySelector('i');

                if (filterContainer.classList.contains('collapsed')) {
                    filterContainer.classList.remove('collapsed');
                    toggleContainer.classList.remove('collapsed');
                    icon.classList.remove('fa-chevron-right');
                    icon.classList.add('fa-chevron-left');
                } else {
                    filterContainer.classList.add('collapsed');
                    toggleContainer.classList.add('collapsed');
                    icon.classList.remove('fa-chevron-left');
                    icon.classList.add('fa-chevron-right');
                }
            });

            // Step 4: Handle label toggle checkbox
            document.getElementById('toggle-labels').addEventListener('change', function () {
                const show = this.checked;
                map.eachLayer(function (layer) {
                    // Check if it's a polyline with our custom tooltips property and is currently visible
                    if (layer instanceof L.Polyline && layer._tooltips && (layer.options.opacity > 0 || layer._isVisible === true)) {
                        layer._tooltips.forEach(tooltip => {
                            if (show) {
                                if (!map.hasLayer(tooltip)) {
                                    map.addLayer(tooltip);
                                }
                            } else {
                                if (map.hasLayer(tooltip)) {
                                    map.removeLayer(tooltip);
                                }
                            }
                        });
                    }
                });
            });

            // Handle SS label toggle checkbox
            document.getElementById('toggle-ss-labels').addEventListener('change', updateSSLabelVisibility);
            document.getElementById('toggle-gss-labels').addEventListener('change', updateSSLabelVisibility);

            // Handle Proposed SS/Lines toggle
            document.getElementById('toggle-proposed').addEventListener('change', applyFilters);

            // Add event listener for the mask opacity slider
            document.getElementById('mask-opacity-slider').addEventListener('input', function (event) {
                const newOpacity = event.target.value;
                if (stateLayer) {
                    stateLayer.setStyle({
                        fillOpacity: parseFloat(newOpacity)
                    });
                }
            });

            // Add zoom level display logic
            const zoomDisplay = document.getElementById('zoom-level-display');
            if (map && zoomDisplay) {
                const updateZoomLevel = () => {
                    const zoomLevel = map.getZoom();
                    zoomDisplay.innerHTML = `Zoom: ${zoomLevel.toFixed(2)}`;
                };
                map.on('zoomend', updateZoomLevel);
                updateZoomLevel(); // Initial call to set the zoom level
            }

            // Report Modal event listeners
            const modal = document.getElementById('report-modal');
            const closeBtn = document.querySelector('.modal-close');
            const exportCsvBtn = document.getElementById('export-csv-btn');

            if (modal && closeBtn && exportCsvBtn) {
                closeBtn.onclick = () => {
                    modal.classList.remove('show');
                };

                exportCsvBtn.onclick = () => {
                    const reportTitle = document.getElementById('report-title').textContent.trim();
                    // Generate a clean filename
                    const filename = `${reportTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.csv`;
                    exportTableToCSV(filename);
                };

                // Close modal if user clicks on the overlay
                window.addEventListener('click', (event) => {
                    if (event.target == modal) {
                        modal.classList.remove('show');
                    }
                });
            }
        };
    </script>
</body>


</html>
