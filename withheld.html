<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Withheld NSC</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --primary: #4361ee;
      --secondary: #3f37c9;
      --success: #4cc9f0;
      --light: #f8f9fa;
      --dark: #212529;
      --gray: #6c757d;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f7fa;
      color: var(--dark);
      line-height: 1.6;
      padding: 0;
      margin: 0;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px;
    }
    
header {
  background-color: var(--dark);
  color: white;
  padding: 0.5rem 1rem; /* reduced */
  box-shadow: var(--box-shadow);
  margin-bottom: 0.5rem;
  position: sticky;
  top: 0;
  width: 100%;
  z-index: 100;
}

header h1 {
  font-size: 1.5rem;
  margin: 0;
}


    .dashboard-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .stat-card {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 10px;
      text-align: center;
      transition: var(--transition);
      cursor: pointer;
      border-left: 4px solid var(--primary);
    }
    
    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
    }
    
    .stat-card[data-range="total"] {
      border-left-color: var(--primary);
    }
    
    .stat-card[data-range="7"] {
      border-left-color: #4cc9f0;
    }
    
    .stat-card[data-range="30"] {
      border-left-color: #f72585;
    }
    
    .stat-card[data-range="90"] {
      border-left-color: #7209b7;
    }
    
    .stat-card h3 {
      font-size: 0.95rem;
      margin-bottom: 6px;
      color: var(--gray);
    }
    
    .stat-card p {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--dark);
      margin: 0;
    }

    .stat-card .icon {
      font-size: 1.2rem;
      margin-bottom: 6px;
      color: var(--primary);
    }
    
    .panel {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 10px;
      margin-bottom: 30px;
    }

    .panel:first-of-type {
  padding: 12px 16px;
  margin-bottom: 16px;
}
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    
    .panel-header h2 {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0;
    }
    
    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
      min-width: 200px;
      flex: 1;
    }
    
    .filter-group label {
      font-size: 0.8rem;
      margin-bottom: 3px;
      color: var(--gray);
      font-weight: 500;
    }
    
    .filter-group select {
      padding: 6px 8px;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background-color: white;
      font-size: 0.9rem;
      color: var(--dark);
      width: 100%;
      transition: var(--transition);
    }
    
    .filter-group select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
    }
    
    .chart-container {
      height: 400px;
      margin-bottom: 0;
      position: relative;
    }
    
    .details table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 0.95rem;
    }
    
    .details th {
      background-color: #f8f9fa;
      padding: 12px 15px;
      text-align: left;
      font-weight: 600;
      color: var(--dark);
      border-bottom: 2px solid #dee2e6;
    }
    
    .details td {
      padding: 12px 15px;
      border-bottom: 1px solid #dee2e6;
    }
    
    .details tr:hover {
      background-color: #f8f9fa;
    }
    
    .toggle-row {
      cursor: pointer;
      font-weight: 500;
    }
    
    .toggle-row td:last-child {
      text-align: right;
    }
    
    .toggle-btn {
      background-color: var(--light);
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      color: var(--primary);
      font-size: 0.8rem;
      transition: var(--transition);
    }
    
    .toggle-btn:hover {
      background-color: #e9ecef;
    }
    
    .nested td:first-child {
      padding-left: 30px;
    }
    
    .spinner-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 200px;
    }
    
    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid var(--primary);
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @media (max-width: 768px) {
      .filters {
        flex-direction: column;
        margin-bottom: 6px;
      }
      
      .filter-group {
        width: 100%;
      }
      
      .chart-container {
        height: 300px;
      }
      
      .details {
        overflow-x: auto;
      }
      
      header h1 {
        font-size: 1.5rem;
      }
    }
    
    .no-data-message {
      text-align: center;
      padding: 20px;
      color: var(--gray);
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    /* Add this to your style tag */
.stat-card.expanded {
  grid-column: span 2;
}

@media (min-width: 600px) {
  .stat-card.expanded {
    grid-column: span 2;
  }
}
.details table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
  margin: 5px 0;
}

.details th,
.details td {
  padding: 6px 8px;
  text-align: left;
  border-bottom: 1px solid #dee2e6;
}

.details tr:hover {
  background-color: #eef2ff;
}

.details .division-row {
  cursor: pointer;
  background-color: #f0f4ff;
  font-weight: 600;
}

.details .ccc-table {
  background-color: #f0f4ff; /* light pastel blue for better readability */
  margin-top: 5px;
  margin-bottom: 10px;
  border: 1px solid #dee2e6;
}
.details .ccc-table table {
  font-size: 0.75rem;
  margin-left: 10px;
  width: calc(100% - 20px);
  border-collapse: collapse;
  background-color: #ffe6e6; /* light red background */
  border: 1px solid #cc0000;
}

.details .ccc-table table th,
.details .ccc-table table td {
  border: 1px solid #cc0000;
  padding: 4px 6px;
  color: #660000;
}

.details .ccc-table {
  background-color: #fff0f0;
  margin-top: 5px;
  margin-bottom: 10px;
  border: 1px solid #cc0000;
  border-radius: 4px;
}

.ccc-table {
  background-color: #ffe6e6;
  font-size: 0.75rem;
  border: 1px solid #cc0000;
}

.ccc-table.visible {
  display: table-row;
}
/* CCC-wise table enhancements */
#details .table-responsive table {
  border: 1px solid #ccc;
  border-radius: 6px;
  overflow: hidden;
}

#details .table-responsive th {
  background-color: #f0f4ff;
  color: #333;
  font-weight: 600;
  padding: 8px;
}

#details .table-responsive td {
  padding: 8px;
  border-bottom: 1px solid #e0e0e0;
}

#details .table-responsive tbody tr:nth-child(even) {
  background-color: #f9fbff;
}

#details .table-responsive tbody tr:hover {
  background-color: #eef3ff;
}
header {
  position: sticky;
  top: 0;
  width: 100%;
  z-index: 100;
}

  </style>
</head>
<body>
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
  </div>

  <header>
    <div class="container">
<h1 style="margin: 0; font-size: 1.5rem;">
  Witheld NSC <span id="update-date" style="font-size: 0.9rem; font-weight: normal; color: #ccc; margin-left: 10px;">(Loading...)</span>
</h1>


    </div>
  </header>

  <div class="container">
    <div class="panel">
  <div class="filters">
    <div class="filter-group">
      <select id="region">
        <option value="">All Regions</option>
      </select>
    </div>

    <div class="filter-group">
      <select id="division">
        <option value="">All Divisions</option>
      </select>
    </div>

    <div class="filter-group">
      <select id="support">
        <option value="">All CCCs</option>
      </select>
    </div>
  </div>
</div>



    <div class="dashboard-stats">
      <div class="stat-card" data-range="total">
        <div class="icon"><i class="fas fa-database"></i></div>
        <h3>Total Records</h3>
        <p id="total-count">0</p>
        <div class="details" id="details-total"></div>
      </div>
    
      <div class="stat-card" data-range="7">
        <div class="icon"><i class="fas fa-calendar-week"></i></div>
        <h3>Last 7 Days</h3>
        <p id="count-7">0</p>
        <div class="details" id="details-7"></div>
      </div>
    
      <div class="stat-card" data-range="30">
        <div class="icon"><i class="fas fa-calendar-alt"></i></div>
        <h3>Last 1 Month</h3>
        <p id="count-30">0</p>
        <div class="details" id="details-30"></div>
      </div>
    
      <div class="stat-card" data-range="90">
        <div class="icon"><i class="fas fa-calendar-check"></i></div>
        <h3>Last 3 Months</h3>
        <p id="count-90">0</p>
        <div class="details" id="details-90"></div>
      </div>
    </div>
    

    <div class="panel">
      <div class="panel-header">
        <h2>Witheld Trend</h2>
      </div>
      <div class="chart-container">
        <canvas id="timelineChart"></canvas>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
const dataUrl = "data/nsc.json";
    let rawData = [];
    let filteredData = [];

    const regionSelect = document.getElementById('region');
    const divisionSelect = document.getElementById('division');
    const supportSelect = document.getElementById('support');

    const totalCountEl = document.getElementById('total-count');
    const count7El = document.getElementById('count-7');
    const count30El = document.getElementById('count-30');
    const count90El = document.getElementById('count-90');

    const detailsDiv = document.getElementById('details');
    const detailsTitle = document.getElementById('detailsTitle');
    const loadingOverlay = document.getElementById('loadingOverlay');

    let chart;
    
    // Set up date formats
    const dateOptions = { year: 'numeric', month: 'short' };
    const dateFormatter = new Intl.DateTimeFormat('en-US', dateOptions);

    // Initialize
    fetchData();

    regionSelect.addEventListener('change', () => {
  updateDependentFilters();
  applyFilters();
});

divisionSelect.addEventListener('change', () => {
  updateDependentFilters();
  applyFilters();
});

supportSelect.addEventListener('change', () => {
  updateDependentFilters();
  applyFilters();
});


document.querySelectorAll('.stat-card').forEach(card => {
  card.addEventListener('click', () => {
    const isExpanded = card.classList.contains('expanded');

    // Reset all cards
    document.querySelectorAll('.stat-card').forEach(c => {
      c.classList.remove('expanded');
      c.style.backgroundColor = 'white';
    });

    // Toggle current card
    if (!isExpanded) {
      card.classList.add('expanded');
      card.style.backgroundColor = '#f0f4ff';
      showDetails(card.dataset.range);
    } else {
      // If collapsing, reset detail area
      document.querySelectorAll('.details').forEach(d => d.innerHTML = '');
    }
  });
});



    async function fetchData() {
      try {
const response = await fetch(dataUrl);
if (!response.ok) throw new Error('Failed to fetch data');
rawData = await response.json();

        // Set update date from second row
// Get all valid dates from 'TODAY' column
const allTodayDates = rawData
  .map(row => parseDate(row['TODAY']))
  .filter(date => date instanceof Date && !isNaN(date.getTime()));

// Find max/latest date
const maxTodayDate = allTodayDates.length
  ? new Date(Math.max(...allTodayDates.map(d => d.getTime())))
  : null;

if (maxTodayDate) {
  const formatted = maxTodayDate.toLocaleDateString('en-GB', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
  document.getElementById('update-date').textContent = `Updated on ${formatted}`;
} else {
  document.getElementById('update-date').textContent = `Updated date unavailable`;
}


        // Build regionMap: REGION -> DIVISION -> SUPPORT
regionMap = {};
rawData.forEach(item => {
  const region = item['REGION'];
  const division = item['DIVN_NAME'];
  const support = item['SUPP_OFF'];

  if (!regionMap[region]) regionMap[region] = {};
  if (!regionMap[region][division]) regionMap[region][division] = new Set();
  regionMap[region][division].add(support);
});

populateFilters();
updateDependentFilters(); // Add this here
applyFilters();

      } catch (error) {
        console.error('Error fetching data:', error);
        detailsTarget.innerHTML = `<div class="no-data-message">
          <p>Error loading data. Please try again later.</p>
        </div>`;
      } finally {
        loadingOverlay.style.display = 'none';
      }
    }



function parseDate(dateStr) {
  if (!dateStr || typeof dateStr !== 'string') return null;

  // Match dd/mm/yyyy
  const match = dateStr.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
  if (match) {
    const [, dd, mm, yyyy] = match;
    return new Date(`${yyyy}-${mm}-${dd}T00:00:00`);
  }

  return null;
}




    function populateFilters() {
  const regions = new Set();
  rawData.forEach(item => {
    if (item['REGION']) regions.add(item['REGION']);
  });
  populateSelect(regionSelect, [...regions].sort());
}

function populateSelect(selectElement, items, currentValue) {
  const firstOption = selectElement.options[0].cloneNode(true);
  selectElement.innerHTML = '';
  selectElement.appendChild(firstOption);

  items.forEach(item => {
    const option = document.createElement('option');
    option.value = item;
    option.textContent = item;
    if (item === currentValue) {
      option.selected = true;
    }
    selectElement.appendChild(option);
  });
}


function updateDependentFilters() {
  const selectedRegion = regionSelect.value;
  const selectedDivision = divisionSelect.value;
  const selectedSupport = supportSelect.value;

  // Step 1: Base the filtering on full raw data
  let possibleDivisions = new Set();
  let possibleSupports = new Set();

  rawData.forEach(item => {
    if (!selectedRegion || item['REGION'] === selectedRegion) {
      if (item['DIVN_NAME']) possibleDivisions.add(item['DIVN_NAME']);

      if (!selectedDivision || item['DIVN_NAME'] === selectedDivision) {
        if (item['SUPP_OFF']) possibleSupports.add(item['SUPP_OFF']);
      }
    }
  });

  // Step 2: Update only Division and Support selects
  populateSelect(divisionSelect, [...possibleDivisions].sort(), selectedDivision);
  populateSelect(supportSelect, [...possibleSupports].sort(), selectedSupport);
}



    function applyFilters() {
      const region = regionSelect.value;
      const division = divisionSelect.value;
      const support = supportSelect.value;

      filteredData = rawData.filter(item => {
        return (!region || item['REGION'] === region) &&
               (!division || item['DIVN_NAME'] === division) &&
               (!support || item['SUPP_OFF'] === support);
      });

      updateCards();
      updateChart();
      
      // Reset details
// Re-show details if a card is currently expanded
const expandedCard = document.querySelector('.stat-card.expanded');
if (expandedCard) {
  showDetails(expandedCard.dataset.range);
}

      
      // Reset card highlighting
      document.querySelectorAll('.stat-card').forEach(c => 
        c.style.backgroundColor = 'white');
    }

    function updateCards() {
  const todayValues = rawData
    .map(item => parseDate(item['TODAY']))
    .filter(date => date instanceof Date && !isNaN(date.getTime()));

  const today = todayValues.length
    ? new Date(Math.max(...todayValues.map(d => d.getTime())))
    : new Date();

  let count7 = 0;
  let count30 = 0;
  let count90 = 0;

  filteredData.forEach(item => {
    const date = item['SCN_WITHELD_DATE'];
    if (date instanceof Date && !isNaN(date.getTime())) {
      const diff = (today - date) / (1000 * 60 * 60 * 24);
      if (diff >= 0 && diff <= 7) count7++;
      if (diff >= 0 && diff <= 30) count30++;
      if (diff >= 0 && diff <= 90) count90++;
    }
  });

  animateCounter(totalCountEl, parseInt(totalCountEl.textContent), filteredData.length);
  animateCounter(count7El, parseInt(count7El.textContent), count7);
  animateCounter(count30El, parseInt(count30El.textContent), count30);
  animateCounter(count90El, parseInt(count90El.textContent), count90);
}




    function animateCounter(element, start, end) {
      const duration = 1000; // Animation duration in milliseconds
      const frameDuration = 1000 / 60; // Approx. 60 FPS
      const totalFrames = Math.round(duration / frameDuration);
      const increment = (end - start) / totalFrames;
      
      let frame = 0;
      let currentCount = start;
      
      const animate = () => {
        frame++;
        currentCount += increment;
        
        if (frame === totalFrames) {
          element.textContent = end;
        } else {
          element.textContent = Math.floor(currentCount);
          requestAnimationFrame(animate);
        }
      };
      
      animate();
    }

function updateChart() {
  const validDates = filteredData
    .map(item => item['SCN_WITHELD_DATE'])
    .filter(date => date instanceof Date && !isNaN(date.getTime()));

  if (validDates.length === 0) {
    if (chart) chart.destroy();
    return;
  }

  // Count records per month
// Count records per month
const monthCounts = {};
validDates.forEach(date => {
  const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
  monthCounts[key] = (monthCounts[key] || 0) + 1;
});


  // Build full month range
  const minDate = new Date(Math.min(...validDates.map(d => d.getTime())));
  const maxDate = new Date(Math.max(...validDates.map(d => d.getTime())));
  const fullRange = [];
  let current = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
  const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);

  while (current <= end) {
    const key = `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`;
    fullRange.push(key);
    current.setMonth(current.getMonth() + 1);
  }

  // Trim leading zero-count months
  let startIndex = 0;
  while (startIndex < fullRange.length && (!monthCounts[fullRange[startIndex]] || monthCounts[fullRange[startIndex]] === 0)) {
    startIndex++;
  }

  const trimmedLabels = fullRange.filter(key => monthCounts[key]);
  const trimmedData = trimmedLabels.map(key => monthCounts[key] || 0);

  if (chart) chart.destroy();

  const barColors = trimmedLabels.map(label => {
  const year = parseInt(label.split('-')[0]);
  return year % 2 === 0 ? 'rgba(67, 97, 238, 1)' : 'rgba(255, 160, 160, 1.0)'; // light red
});

const barHoverColors = trimmedLabels.map(label => {
  const year = parseInt(label.split('-')[0]);
  return year % 2 === 0 ? 'rgba(67, 97, 238, 1)' : 'rgba(255, 160, 160, 1.0)';
});
const barBorderColors = trimmedLabels.map(label => {
  const year = parseInt(label.split('-')[0]);
  return year % 2 === 0 ? 'rgba(67, 97, 238, 1)' : 'rgba(255, 99, 132, 1)'; // red border for red bars
});

chart = new Chart(document.getElementById('timelineChart'), {
  type: 'bar',
  data: {
    labels: trimmedLabels,
    datasets: [{
  label: 'Withheld Count',
  data: trimmedData,
  backgroundColor: barColors,
  borderColor: barBorderColors,
  borderWidth: 1,
  borderRadius: 4,
  hoverBackgroundColor: barHoverColors
}]

  },

    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
x: {
  grid: { display: false },
    ticks: {
  callback: function(value, index, ticks) {
    const [year, month] = this.getLabelForValue(value).split('-');
    return month === '01' ? year : '';
  },

    color: '#333',
    autoSkip: false,
    minRotation: 90,
    maxRotation: 90,
    font: {
      size: 10,
      weight: 'normal'
    }
  },
  title: {
    display: true,
    text: 'Year',
    font: {
      weight: 'bold'
    }
  }
},

        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Count',
            font: { weight: 'bold' }
          },
          ticks: { precision: 0 }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            title: function(context) {
              const [year, month] = context[0].label.split('-');
              const date = new Date(parseInt(year), parseInt(month) - 1, 1);
              return date.toLocaleString('default', { month: 'long', year: 'numeric' });
            },
            label: function(context) {
              return `Count: ${context.raw}`;
            }
          }
        }
      },
      animation: {
        duration: 1000,
        easing: 'easeInOutQuad'
      }
    }
  });
}
function generateSubRowsCCC(groupKey, container, data) {
  const groupedByCCC = {};
  data.forEach(d => {
    const ccc = d['SUPP_OFF'] || 'Unknown CCC';
    groupedByCCC[ccc] = (groupedByCCC[ccc] || 0) + 1;
  });

  const total = data.length;
  let html = `
    <div class="table-responsive">
<table class="table table-sm table-bordered mb-0 ccc-table">

        <thead class="table-light">
          <tr>
            <th>CCC</th>
            <th class="text-end">Count</th>
            <th class="text-end">%</th>
          </tr>
        </thead>
        <tbody>
  `;

  const sorted = Object.entries(groupedByCCC).sort((a, b) => b[1] - a[1]);
  for (const [ccc, count] of sorted) {
    const percent = ((count / total) * 100).toFixed(1);
    html += `
<tr onclick="event.stopPropagation()">
  <td>${ccc}</td>
  <td class="text-end">${count}</td>
  <td class="text-end">${percent}%</td>
</tr>
    `;
  }

  html += `</tbody></table></div>`;
  container.innerHTML = html;

// Prevent CCC rows from collapsing the division row
container.querySelectorAll('tr').forEach(row => {
  row.addEventListener('click', e => e.stopPropagation());
});

}


function showDetails(range) {
  // Clear all existing detail sections
  document.querySelectorAll('.details').forEach(d => d.innerHTML = '');

  const detailsTarget = document.getElementById(`details-${range}`);

  const todayValues = rawData
    .map(item => parseDate(item['TODAY']))
    .filter(date => date instanceof Date && !isNaN(date.getTime()));

  const today = todayValues.length
    ? new Date(Math.max(...todayValues.map(d => d.getTime())))
    : new Date();

  let data = [];

  filteredData.forEach(item => {
    const date = item['SCN_WITHELD_DATE'];
    if (!(date instanceof Date) || isNaN(date.getTime())) return;

    const diff = (today - date) / (1000 * 60 * 60 * 24);
    if (
      range === 'total' ||
      (range === '7' && diff <= 7) ||
      (range === '30' && diff <= 30) ||
      (range === '90' && diff <= 90)
    ) {
      data.push(item);
    }
  });

  if (data.length === 0) {
    detailsTarget.innerHTML = `<div class="no-data-message">
      <p>No data available for this range</p>
    </div>`;
    return;
  }

  // Group by division
  const divnMap = {};
  data.forEach(item => {
    const divn = item['DIVN_NAME'] || 'Unknown';
    if (!divnMap[divn]) divnMap[divn] = [];
    divnMap[divn].push(item);
  });

  const total = data.length;
  const sortedDivns = Object.entries(divnMap)
    .map(([divn, items]) => ({ divn, count: items.length, items }))
    .sort((a, b) => b.count - a.count); // sort high to low

  let detailsHTML = `
    <table class="table table-hover">
      <thead>
        <tr>
          <th>Division</th>
          <th class="text-end">Count</th>
          <th class="text-end">%</th>
        </tr>
      </thead>
      <tbody>
  `;

  sortedDivns.forEach(({ divn, count, items }) => {
    const percent = ((count / total) * 100).toFixed(1);
    const rowId = `row-${range}-${btoa(divn).replace(/=/g, '')}`;

    detailsHTML += `
      <tr class="division-row" data-group="${divn}" data-rowid="${rowId}" style="cursor:pointer;">
        <td><i class="fas fa-chevron-right me-2"></i>${divn}</td>
        <td class="text-end">${count}</td>
        <td class="text-end">${percent}%</td>
      </tr>
      <tr id="${rowId}" class="sub-row" style="display:none;">
        <td colspan="3"><div id="${rowId}-subdata"></div></td>
      </tr>
    `;
  });

  detailsHTML += `</tbody></table>`;
  detailsTarget.innerHTML = detailsHTML;

  // Attach expand/collapse listener
  detailsTarget.querySelectorAll('.division-row').forEach(row => {
    row.addEventListener('click', function (e) {
      e.stopPropagation(); // prevent card collapse

      const rowId = this.dataset.rowid;
      const icon = this.querySelector('i');
      const subRow = document.getElementById(rowId);
      const subContainer = document.getElementById(`${rowId}-subdata`);
      const divn = this.dataset.group;
      const divisionData = divnMap[divn];

      if (subRow.style.display === 'none') {
        generateSubRowsCCC(divn, subContainer, divisionData);
        subRow.style.display = '';
        icon.classList.remove('fa-chevron-right');
        icon.classList.add('fa-chevron-down');
      } else {
        subRow.style.display = 'none';
        subContainer.innerHTML = '';
        icon.classList.remove('fa-chevron-down');
        icon.classList.add('fa-chevron-right');
      }
    });
  });
}




  </script>
</body>
</html>
