<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meter Utilization Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <style>
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --bg: #f1f3f4;
      --card: #ffffff;
      --text: #2d3748;
      --text-muted: #718096;
      --border: #e2e8f0;
      --radius: 6px;
      --shadow: 0 2px 8px rgba(0,0,0,0.08);
      --spacing: 8px;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      font-size: 14px;
      color: var(--text);
      line-height: 1.4;
      min-height: 100vh;
      padding: var(--spacing);
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .header {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 12px 16px;
      text-align: center;
    }
    h1 { font-size: 20px; font-weight: 600; margin-bottom: 4px; }
    .subtitle { opacity: 0.9; font-size: 13px; }
    .controls {
      padding: 12px;
      background: #fafafa;
      border-bottom: 1px solid var(--border);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: var(--spacing);
    }
    select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 13px;
      background: white;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    select:focus {
      outline: none;
      border-color: var(--primary);
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      background: #fafafa;
    }
    .tab {
      flex: 1;
      padding: 10px 8px;
      text-align: center;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      color: var(--text-muted);
      transition: all 0.2s;
      border-bottom: 2px solid transparent;
      min-width: 0; /* Ensures flex items don't overflow on small screens */
    }
    .tab.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
      background: white;
    }
    .content {
      padding: 12px;
      /* min-height: 300px; */
      max-height: 65vh;
      overflow-y: auto;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .chart-container {
      position: relative;
      height: 280px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
    }
    /* Set default alignment for all td elements to center */
    td {
      text-align: center;
    }
    th {
      background: #fafafa;
      font-weight: 600;
      color: var(--text-muted);
      position: sticky;
      top: -1px; /* -1px to avoid gap with container */
      font-size: 12px;
    }
    tr:hover {
      background: #f9f9f9;
    }
    .location-summary:hover {
      background: #e8f4fd !important;
      transform: translateX(2px);
      transition: all 0.2s;
    }
    .detail-row:hover, #natConnTableBody tr:hover {
      background: #f0f0f0 !important;
    }
    .loading {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }
    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid var(--primary);
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @media (max-width: 768px) {
      body { padding: 4px; }
      .controls { 
        grid-template-columns: repeat(2, 1fr);
        padding: 8px;
        gap: 6px;
      }
      .control-group { min-width: 0; }
      h1 { font-size: 16px; }
      .subtitle { font-size: 11px; }
      .chart-container { height: 200px; }
      .content { padding: 8px; }
      .header { padding: 8px 12px; }
      .tab { padding: 8px 6px; font-size: 11px; }
      th, td { padding: 4px 6px; }
      table { font-size: 10px; }
      th { font-size: 9px; }
    }
    @media (max-width: 480px) {
      .controls { grid-template-columns: 1fr; }
      .chart-container { height: 180px; }
    }
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.6);
    }
    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 90%;
      max-width: 1100px;
      border-radius: var(--radius);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
    .modal-header h2 {
      font-size: 18px;
      color: var(--text);
    }
    .close-button {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close-button:hover,
    .close-button:focus {
      color: black;
      text-decoration: none;
    }
    #modalTableContainer { max-height: 60vh; overflow-y: auto; }
    /* Styles for download button */
    .table-header {
      display: flex;
      justify-content: flex-end;
      padding-bottom: 10px;
    }
    .download-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background-color: var(--primary);
      color: white;
      font-size: 13px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-weight: 600;
    }
    .download-btn:hover {
      background-color: var(--secondary);
    }
    .modal-title-group {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    /* Override for the first column (Location/Details/NAT_OF_CONN) to keep it left-aligned */
    #dataTable tbody td:first-child,
    #dataTable tfoot td:first-child {
        text-align: left;
    }
    #natConnTable tbody td:first-child,
    #natConnTable tfoot td:first-child {
        text-align: left;
    }
    
    /* Ensure header cells are centered, except the first one */
    #dataTable thead th, #natConnTable thead th {
        text-align: center;
    }
    #dataTable thead th:first-child, #natConnTable thead th:first-child {
        text-align: left;
    }
    
    /* Override for the first data cell of the detail rows to indent it */
    .detail-row td:first-child {
        text-align: left;
        padding-left: 40px !important;
    }
    /* Override for modal table, only the first column should be left-aligned */
    #consumerDetailTable td:first-child {
        text-align: left;
    }
    /* Ensure the location/summary row has left-aligned text content */
    .location-summary td:first-child {
        text-align: left !important;
        padding-left: 12px !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Progress of Smart Metering</h1>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>Hierarchy Level</label>
        <select id="hierarchyLevel">
          <option value="region">Region-wise</option>
          <option value="division">Division-wise</option>
          <option value="ccc">CCC-wise</option>
        </select>
      </div>
      <div class="control-group">
        <label>Filter By</label>
        <select id="filterSelect">
          <option value="all">All</option>
        </select>
      </div>
      <div class="control-group">
        <label>Meter Type</label>
        <select id="meterType">
          <option value="all">All Types</option>
        </select>
      </div>
      <div class="control-group">
        <label>Connection Phase</label>
        <select id="connPhase">
          <option value="all">All Phases</option>
        </select>
      </div>
      <div class="control-group">
        <label>Installation Status</label>
        <select id="installStatus">
          <option value="all">All</option>
          <option value="installed">Smart Meter Installed</option>
          <option value="pending">Smart Meter Pending</option>
        </select>
      </div>
    </div>

    <div class="tabs">
      <div id="hierarchyTabBtn" class="tab active" onclick="switchTab('hierarchy')">Office-wise</div>
      <div id="natConnTabBtn" class="tab" onclick="switchTab('natConn')">Nature-wise</div>
    </div>

    <div class="content">
      <!-- 1. Hierarchy/Office Wise Table Content (Existing) -->
      <div id="hierarchyTab" class="tab-content active">
        <div class="loading" id="loading">
          <div class="spinner"></div>
          <div>Loading data...</div>
        </div>
        <div class="table-header">
          <button id="downloadSummaryBtn" class="download-btn">Download CSV</button>
        </div>
        <div>
          <table id="dataTable">
            <thead>
              <tr>
                <th style="width: 35%">Location / Details</th>
                <th style="width: 13%">Target</th>
                <th style="width: 13%">Work Orders</th>
                <th style="width: 13%">Pending WO</th>
                <th style="width: 13%">Meters Installed</th>
                <th style="width: 13%">Achieved (%)</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody><tfoot id="tableFooter"></tfoot>
          </table>
        </div>
      </div>
      
      <!-- 2. NAT_OF_CONN Wise Table Content (New) -->
      <div id="natConnTab" class="tab-content">
        <div class="table-header">
          <button id="downloadNatConnSummaryBtn" class="download-btn">Download CSV</button>
        </div>
        <div>
          <table id="natConnTable">
            <thead>
              <tr>
                <th style="width: 35%">Nature of Connection</th>
                <th style="width: 13%">Target</th>
                <th style="width: 13%">Work Orders</th>
                <th style="width: 13%">Pending WO</th>
                <th style="width: 13%">Meters Installed</th>
                <th style="width: 13%">Achieved (%)</th>
              </tr>
            </thead>
            <tbody id="natConnTableBody"></tbody><tfoot id="natConnTableFooter"></tfoot>
          </table>
        </div>
      </div>

    </div>
  </div>

  <!-- Detail Modal -->
  <div id="detailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title-group">
          <h2 id="modalTitle">Consumer Details</h2>
          <button id="downloadDetailBtn" class="download-btn">Download CSV</button>
        </div>
        <span class="close-button">&times;</span>
      </div>
      <div id="modalTableContainer">
        <!-- Consumer detail table will be injected here -->
      </div>
    </div>
  </div>


  <script>
    const HIER = {
      "6610000": { name: "MALDA REGION", divisions: {
        "6611000": { name: "MALDA DIVISION", cccs: {"6611101":"MANIKCHAK","6611102":"GOLAPGANJ","6611103":"BAISHNABNAGAR","6611104":"KALIACHAK","6611105":"MOTHABARI","6611106":"SUJAPUR","6611107":"RATHBARI","6611108":"FULBARI","6611109":"MOKDUMPUR"}},
        "6612000": { name: "CHANCHAL DIVISION", cccs: {"6612101":"BHALUKA","6612102":"SAMSI","6612103":"PARANPUR","6612104":"CHANCHAL","6612105":"MALATIPUR","6612106":"HARISHCHANDRAPUR","6612107":"KUSHIDA"}},
        "6613000": { name: "GAZOLE DIVISION", cccs: {"6613101":"GAZOL","6613102":"AIHO","6613103":"PANDUA","6613104":"BAMONGOLA","6613105":"OLD MALDA"}}
      }},
      "6620000": { name: "UTTAR DINAJPUR REGION", divisions: {
        "6621000": { name: "RAIGANJ DIVISION", cccs: {"6621101":"ITAHAR","6621102":"HEMTABAD","6621103":"KALIYAGANJ","6621104":"RAIGANJ","6621105":"BIRNAGAR","6621106":"KARANDIGHI"}},
        "6622000": { name: "ISLAMPUR DIVISION", cccs: {"6622101":"ISLAMPUR","6622102":"CHOPRA","6622103":"DALKHOLA","6622104":"GOALPOKHER","6622105":"KANKI"}}
      }},
      "6630000": { name: "DAKSHIN DINAJPUR REGION", divisions: {
        "6631000": { name: "BALURGHAT DIVISION", cccs: {"6631101":"BALURGHAT","6631102":"TAPAN","6631103":"KUMARGANJ","6631104":"HILI","6631105":"PATIRAM"}},
        "6632000": { name: "BUNIADPUR DIVISION", cccs: {"6632101":"BUNIADPUR","6632102":"KUSMANDI","6632103":"HARIRAMPUR","6632104":"GANGARAMPUR"}}
      }}
    };

    let rawData = [];
    let currentSummaryData = []; // Data for Hierarchy tab
    let currentNatConnData = []; // Data for NAT_OF_CONN tab
    let currentConsumerData = []; // Data for detail modal
    let currentActiveTab = 'hierarchy'; // State to track active tab

    // --- Tab Switching Logic ---
    function switchTab(tabId) {
      document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
      document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));

      document.getElementById(tabId + 'Tab').classList.add('active');
      document.getElementById(tabId + 'TabBtn').classList.add('active');
      
      currentActiveTab = tabId;
      updateVisualization();
      
      // Removed the logic that disabled hierarchy filters, so all controls remain active.
    }

    // --- Data Fetching & Initialization ---

    function getHierarchyInfo(cccCode) {
      for (const [regCode, region] of Object.entries(HIER)) {
        for (const [divCode, division] of Object.entries(region.divisions)) {
          if (division.cccs[cccCode]) {
            return {
              region: { code: regCode, name: region.name },
              division: { code: divCode, name: division.name },
              ccc: { code: cccCode, name: division.cccs[cccCode] }
            };
          }
        }
      }
      return null;
    }

    function isNumeric(val) {
      const trimmedVal = val ? String(val).trim() : '';
      return trimmedVal && trimmedVal !== '0';
    }

    Papa.parse('https://docs.google.com/spreadsheets/d/e/2PACX-1vSWjwUI4EUgEABlcggpdOS-WSPKY8my-5T0cLxT4h8tNz_IreQy6jUYKBnB5yc0n-fcs8FpVbwo6Qay/pub?gid=0&single=true&output=tsv', {
      download: true,
      header: true,
      delimiter: '\t',
      skipEmptyLines: true,
      complete: function(results) {
        if (results.data.length > 0 && results.data[0].Date) {
          const dateStr = results.data[0].Date; 
          const parts = dateStr.split('/');
          const dateObj = parts.length === 3 ? new Date(parts[2], parts[1] - 1, parts[0]) : new Date(dateStr);

          if (!isNaN(dateObj.getTime())) {
            const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = months[dateObj.getMonth()];
            const day = dateObj.getDate();
            const year = dateObj.getFullYear();
            const formattedDate = `${month}, ${day}, ${year}`;

            const headerTitle = document.querySelector('.header h1');
            if (headerTitle) {
              headerTitle.textContent = `Progress of Smart Metering (${formattedDate})`;
            }
          }
        }

        rawData = results.data.map(row => {
          const info = getHierarchyInfo(row.CCC_CODE);
          return {
            ...row,
            hierarchy: info,
            hasNewMeter: isNumeric(row.NEW_METER_NO),
            hasWorkOrder: isNumeric(row.WORK_ORDER),
            natOfConn: row.NAT_OF_CONN || 'UNSPECIFIED' // Normalize NAT_OF_CONN
          };
        }).filter(row => row.hierarchy);

        populateFilters();
        updateFilterOptions(); // Initial call to populate filter by options
        updateVisualization();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('hierarchyTab').classList.add('active');
        document.getElementById('hierarchyTabBtn').classList.add('active');
      }
    });

    function populateFilters() {
      const meterTypes = [...new Set(rawData.map(r => r['Meter Type']).filter(Boolean))];
      const phases = [...new Set(rawData.map(r => r.CONN_PHASE).filter(Boolean))];

      const meterSelect = document.getElementById('meterType');
      meterTypes.forEach(type => {
        const opt = document.createElement('option');
        opt.value = type;
        opt.textContent = type;
        meterSelect.appendChild(opt);
      });

      const phaseSelect = document.getElementById('connPhase');
      phases.forEach(phase => {
        const opt = document.createElement('option');
        opt.value = phase;
        opt.textContent = phase;
        phaseSelect.appendChild(opt);
      });
    }

    function updateFilterOptions() {
      const level = document.getElementById('hierarchyLevel').value;
      const filterSelect = document.getElementById('filterSelect');
      filterSelect.innerHTML = '<option value="all">All</option>';

      if (level === 'region') {
          Object.entries(HIER).forEach(([code, region]) => {
            const opt = document.createElement('option');
            opt.value = code;
            opt.textContent = region.name;
            filterSelect.appendChild(opt);
          });
      } else if (level === 'division') {
          Object.values(HIER).forEach(region => {
            Object.entries(region.divisions).forEach(([code, division]) => {
              const opt = document.createElement('option');
              opt.value = code;
              opt.textContent = division.name;
              filterSelect.appendChild(opt);
            });
          });
      } else if (level === 'ccc') {
          Object.values(HIER).forEach(region => {
            Object.values(region.divisions).forEach(division => {
              Object.entries(division.cccs).forEach(([code, name]) => {
                const opt = document.createElement('option');
                opt.value = code;
                opt.textContent = name;
                filterSelect.appendChild(opt);
              });
            });
          });
      }
    }

    // --- Core Filtering Logic (Now includes all 5 filters) ---

    function getAllFilteredData() {
      const level = document.getElementById('hierarchyLevel').value;
      const filter = document.getElementById('filterSelect').value;
      const meterType = document.getElementById('meterType').value;
      const phase = document.getElementById('connPhase').value;
      const installStatus = document.getElementById('installStatus').value;

      return rawData.filter(row => {
        // 1. Meter Type, Phase, and Installation Status Filters
        if (meterType !== 'all' && row['Meter Type'] !== meterType) return false;
        if (phase !== 'all' && row.CONN_PHASE !== phase) return false;

        if (installStatus === 'installed' && !row.hasNewMeter) return false;
        // "Pending" means a work order exists, but a new meter is not yet installed.
        if (installStatus === 'pending' && !(row.hasWorkOrder && !row.hasNewMeter)) return false;
        
        // 2. Hierarchy Filters (Applies to the data as a filter regardless of the active tab)
        if (filter !== 'all') {
            if (level === 'region' && row.hierarchy.region.code !== filter) return false;
            if (level === 'division' && row.hierarchy.division.code !== filter) return false;
            if (level === 'ccc' && row.hierarchy.ccc.code !== filter) return false;
        }

        return true;
      });
    }

    // --- Aggregation Functions ---

    function getHierarchySummaryData() {
      const level = document.getElementById('hierarchyLevel').value;
      // Filtered data now includes all 5 filters
      const filtered = getAllFilteredData();

      const grouped = {};
      filtered.forEach(row => {
        let key, name;
        if (level === 'region') {
          key = row.hierarchy.region.code;
          name = row.hierarchy.region.name;
        } else if (level === 'division') {
          key = row.hierarchy.division.code;
          name = row.hierarchy.division.name;
        } else {
          key = row.hierarchy.ccc.code;
          name = row.hierarchy.ccc.name;
        }

        // Group by Location + Meter Type + Phase for detailed rows
        const subKey = `${key}|${row['Meter Type']}|${row.CONN_PHASE}`;
        if (!grouped[subKey]) {
          grouped[subKey] = {
            locationKey: key,
            location: name,
            meterType: row['Meter Type'] || 'N/A',
            phase: row.CONN_PHASE || 'N/A',
            target: 0,
            workOrders: 0,
            metersInstalled: 0
          };
        }
        if (row.hasWorkOrder) grouped[subKey].workOrders++;
        if (row.hasNewMeter) grouped[subKey].metersInstalled++;
        grouped[subKey].target++;
      });

      return Object.values(grouped).map(item => ({
        ...item,
        pendingWorkOrders: item.target - item.workOrders,
        utilization: item.target > 0 ? ((item.metersInstalled / item.target) * 100).toFixed(1) : 0
      }));
    }
    
    function getNatOfConnSummaryData() {
      // Filtered data now includes all 5 filters, including Hierarchy Level/Filter By
      const filtered = getAllFilteredData();

      const grouped = {};
      filtered.forEach(row => {
        const natConn = row.natOfConn;
        
        if (!grouped[natConn]) {
          grouped[natConn] = {
            natOfConn: natConn,
            target: 0,
            workOrders: 0,
            metersInstalled: 0
          };
        }
        
        if (row.hasWorkOrder) grouped[natConn].workOrders++;
        if (row.hasNewMeter) grouped[natConn].metersInstalled++;
        grouped[natConn].target++;
      });

      return Object.values(grouped).map(item => ({
        ...item,
        pendingWorkOrders: item.target - item.workOrders,
        utilization: item.target > 0 ? ((item.metersInstalled / item.target) * 100).toFixed(1) : 0
      })).sort((a, b) => b.target - a.target); // Sort by target descending
    }

    // --- Main Update Function ---

    function updateVisualization() {
      if (currentActiveTab === 'hierarchy') {
        currentSummaryData = getHierarchySummaryData();
        updateHierarchyTable(currentSummaryData);
      } else if (currentActiveTab === 'natConn') {
        currentNatConnData = getNatOfConnSummaryData();
        updateNatOfConnTable(currentNatConnData);
      }
    }

    // --- Table Rendering Functions ---

    function updateHierarchyTable(data) {
      const tbody = document.getElementById('tableBody');
      const tfoot = document.getElementById('tableFooter');
      tbody.innerHTML = '';
      tfoot.innerHTML = '';
      
      // Calculate grand totals
      const grandTotalTarget = data.reduce((sum, row) => sum + row.target, 0);
      const grandTotalWorkOrders = data.reduce((sum, row) => sum + row.workOrders, 0);
      const grandTotalInstalled = data.reduce((sum, row) => sum + row.metersInstalled, 0);
      const grandTotalPending = grandTotalTarget - grandTotalWorkOrders;
      const grandTotalUtilization = grandTotalTarget > 0 ? ((grandTotalInstalled / grandTotalTarget) * 100).toFixed(1) : 0;

      // Group data by location (for expandable rows)
      const grouped = {};
      data.forEach(row => {
        if (!grouped[row.location]) {
          grouped[row.location] = [];
        }
        grouped[row.location].push(row);
      });

      const sortedLocations = Object.keys(grouped).sort();

      sortedLocations.forEach((location) => {
        const locationData = grouped[location];
        const totalTarget = locationData.reduce((sum, row) => sum + row.target, 0);
        const totalWorkOrders = locationData.reduce((sum, row) => sum + row.workOrders, 0);
        const totalInstalled = locationData.reduce((sum, row) => sum + row.metersInstalled, 0);
        const totalPending = totalTarget - totalWorkOrders;
        const avgUtilization = totalTarget > 0 ? ((totalInstalled / totalTarget) * 100).toFixed(1) : 0;
        
        // Create summary row for location
        const summaryRow = document.createElement('tr');
        summaryRow.className = 'location-summary';
        summaryRow.style.backgroundColor = '#f8f9fa';
        summaryRow.style.fontWeight = '600';
        summaryRow.style.cursor = 'pointer';
        summaryRow.style.borderLeft = '3px solid var(--primary)';
        summaryRow.dataset.location = location;
        summaryRow.dataset.expanded = 'false';
        
        summaryRow.innerHTML = `
          <td style="padding: 8px 12px;">
            <span class="expand-icon" style="margin-right: 8px; transition: transform 0.2s;">‚ñ∂</span>
            üìç ${location}
          </td>
          <td>${totalTarget}</td>
          <td>${totalWorkOrders}</td>
          <td>${totalPending}</td>
          <td>${totalInstalled}</td>
          <td style="font-weight: 600; color: var(--primary);">${avgUtilization}%</td>
        `;
        
        summaryRow.addEventListener('click', function() {
          toggleLocationDetails(this);
        });
        
        tbody.appendChild(summaryRow);
        
        // Add detail rows (initially hidden)
        locationData.forEach(row => {
          const detailRow = document.createElement('tr');
          detailRow.className = 'detail-row';
          detailRow.style.display = 'none';
          detailRow.style.backgroundColor = '#fafafa';
          detailRow.style.cursor = 'pointer';
          detailRow.dataset.parent = location;
          
          detailRow.innerHTML = `
            <td style="font-size: 12px;">
              ${row.meterType} / ${row.phase}
            </td>
            <td style="font-size: 12px;">${row.target}</td>
            <td style="font-size: 12px;">${row.workOrders}</td>
            <td style="font-size: 12px;">${row.pendingWorkOrders}</td>
            <td style="font-size: 12px;">${row.metersInstalled}</td>
            <td style="font-size: 12px; font-weight: 600;">${row.utilization}%</td>
          `;
          
          detailRow.addEventListener('click', () => {
            openConsumerModal({ location: row.location, meterType: row.meterType, phase: row.phase, grouping: 'hierarchy' });
          });

          tbody.appendChild(detailRow);
        });
      });

      // Add the grand total row to the footer
      const totalRow = document.createElement('tr');
      totalRow.style.backgroundColor = '#e9ecef';
      totalRow.style.fontWeight = 'bold';
      totalRow.style.color = 'var(--text)';

      totalRow.innerHTML = `
        <td style="padding: 8px 12px; text-align: right;">Grand Total</td>
        <td>${grandTotalTarget}</td>
        <td>${grandTotalWorkOrders}</td>
        <td>${grandTotalPending}</td>
        <td>${grandTotalInstalled}</td>
        <td style="color: var(--primary);">${grandTotalUtilization}%</td>
      `;
      tfoot.appendChild(totalRow);
    }
    
    function updateNatOfConnTable(data) {
      const tbody = document.getElementById('natConnTableBody');
      const tfoot = document.getElementById('natConnTableFooter');
      tbody.innerHTML = '';
      tfoot.innerHTML = '';

      // Calculate grand totals
      const grandTotalTarget = data.reduce((sum, row) => sum + row.target, 0);
      const grandTotalWorkOrders = data.reduce((sum, row) => sum + row.workOrders, 0);
      const grandTotalInstalled = data.reduce((sum, row) => sum + row.metersInstalled, 0);
      const grandTotalPending = grandTotalTarget - grandTotalWorkOrders;
      const grandTotalUtilization = grandTotalTarget > 0 ? ((grandTotalInstalled / grandTotalTarget) * 100).toFixed(1) : 0;

      data.forEach(row => {
        const rowEl = document.createElement('tr');
        rowEl.style.cursor = 'pointer';
        
        rowEl.innerHTML = `
          <td style="font-weight: 600; padding-left: 12px;">${row.natOfConn}</td>
          <td>${row.target}</td>
          <td>${row.workOrders}</td>
          <td>${row.pendingWorkOrders}</td>
          <td>${row.metersInstalled}</td>
          <td style="font-weight: 600; color: var(--primary);">${row.utilization}%</td>
        `;
        
        rowEl.addEventListener('click', () => {
          openConsumerModal({ natOfConn: row.natOfConn, grouping: 'natConn' });
        });

        tbody.appendChild(rowEl);
      });
      
      // Add the grand total row to the footer
      const totalRow = document.createElement('tr');
      totalRow.style.backgroundColor = '#e9ecef';
      totalRow.style.fontWeight = 'bold';
      totalRow.style.color = 'var(--text)';

      totalRow.innerHTML = `
        <td style="padding: 8px 12px; text-align: right;">Grand Total</td>
        <td>${grandTotalTarget}</td>
        <td>${grandTotalWorkOrders}</td>
        <td>${grandTotalPending}</td>
        <td>${grandTotalInstalled}</td>
        <td style="color: var(--primary);">${grandTotalUtilization}%</td>
      `;
      tfoot.appendChild(totalRow);
    }
    
    function toggleLocationDetails(summaryRow) {
      const location = summaryRow.dataset.location;
      const isExpanded = summaryRow.dataset.expanded === 'true';
      const expandIcon = summaryRow.querySelector('.expand-icon');
      const detailRows = document.querySelectorAll(`tr.detail-row[data-parent="${location}"]`);
      
      if (isExpanded) {
        // Collapse
        detailRows.forEach(row => row.style.display = 'none');
        expandIcon.style.transform = 'rotate(0deg)';
        expandIcon.textContent = '‚ñ∂';
        summaryRow.dataset.expanded = 'false';
      } else {
        // Expand
        detailRows.forEach(row => row.style.display = 'table-row');
        expandIcon.style.transform = 'rotate(90deg)';
        expandIcon.textContent = '‚ñº';
        summaryRow.dataset.expanded = 'true';
      }
    }

    function openConsumerModal(groupInfo) {
      const modal = document.getElementById('detailModal');
      const modalTitle = document.getElementById('modalTitle');
      const tableContainer = document.getElementById('modalTableContainer');

      let modalBaseTitle = "Consumer Details";
      let consumers = [];

      // Determine which group of data to filter based on the active tab/grouping
      const allFilteredData = getAllFilteredData(); // Use the complete filter set
      
      if (groupInfo.grouping === 'hierarchy') {
        modalBaseTitle = `Consumers for ${groupInfo.location} (${groupInfo.meterType} / ${groupInfo.phase})`;
        
        consumers = allFilteredData.filter(r => {
          let locationMatch = false;
          // Find the location name based on the current hierarchy level
          const level = document.getElementById('hierarchyLevel').value;
          if (level === 'region') {
            locationMatch = r.hierarchy.region.name === groupInfo.location;
          } else if (level === 'division') {
            locationMatch = r.hierarchy.division.name === groupInfo.location;
          } else {
            locationMatch = r.hierarchy.ccc.name === groupInfo.location;
          }

          const meterTypeMatch = (r['Meter Type'] || 'N/A') === groupInfo.meterType;
          const phaseMatch = (r.CONN_PHASE || 'N/A') === groupInfo.phase;

          return locationMatch && meterTypeMatch && phaseMatch;
        });
      } else if (groupInfo.grouping === 'natConn') {
        modalBaseTitle = `Consumers for NAT_OF_CONN: ${groupInfo.natOfConn}`;
        
        // Since allFilteredData already has the filters applied, we only need to filter by NAT_OF_CONN
        consumers = allFilteredData.filter(r => r.natOfConn === groupInfo.natOfConn);
      }
      
      modalTitle.textContent = modalBaseTitle;
      
      // Store current consumer data for download
      currentConsumerData = consumers.map(c => ({
          'CON_ID': c.CON_ID || '',
          'CCC': c.hierarchy.ccc.name || '',
          'NAME': c.NAME || '',
          'NAT_OF_CONN': c.NAT_OF_CONN || '',
          'CONN_LOAD': c.CONN_LOAD || '',
          'CON_CLASS': c.CON_CLASS || '',
          'REPL_REASON': c.REPL_REASON || ''
      }));


      let tableHTML = `
        <table id="consumerDetailTable" style="font-size: 11px;">
          <thead>
            <tr>
              <th>CON_ID</th>
              <th>CCC</th>
              <th>NAME</th>
              <th>NAT_OF_CONN</th>
              <th>CONN_LOAD</th>
              <th>CON_CLASS</th>
              <th>REPL_REASON</th>
            </tr>
          </thead>
          <tbody>
      `;

      if (consumers.length > 0) {
        consumers.forEach(c => {
          tableHTML += `
            <tr>
              <td>${c.CON_ID || ''}</td>
              <td>${c.hierarchy.ccc.name || ''}</td>
              <td>${c.NAME || ''}</td>
              <td>${c.NAT_OF_CONN || ''}</td>
              <td>${c.CONN_LOAD || ''}</td>
              <td>${c.CON_CLASS || ''}</td>
              <td>${c.REPL_REASON || ''}</td>
            </tr>
          `;
        });
      } else {
        tableHTML += '<tr><td colspan="7" style="text-align: center; padding: 20px;">No consumer data found for this group.</td></tr>';
      }

      tableHTML += '</tbody></table>';
      tableContainer.innerHTML = tableHTML;

      modal.style.display = 'block';
    }
    
    // --- CSV Download Functionality ---

    function downloadTableAsCSV(data, filename) {
        if (!data || data.length === 0) {
            console.error("No data available to download.");
            return;
        }

        const csv = Papa.unparse(data);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });

        const link = document.createElement("a");
        if (link.download !== undefined) { 
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            console.error("Your browser does not support automatic CSV download.");
        }
    }

    function prepareSummaryDataForDownload(summaryData) {
        // This function remains for the Hierarchy table download
        const grouped = {};
        summaryData.forEach(row => {
            if (!grouped[row.location]) {
                grouped[row.location] = [];
            }
            grouped[row.location].push(row);
        });

        let csvData = [];
        const sortedLocations = Object.keys(grouped).sort();

        sortedLocations.forEach(location => {
            const locationData = grouped[location];
            const totalTarget = locationData.reduce((sum, row) => sum + row.target, 0);
            const totalWorkOrders = locationData.reduce((sum, row) => sum + row.workOrders, 0);
            const totalInstalled = locationData.reduce((sum, row) => sum + row.metersInstalled, 0);
            const totalPending = totalTarget - totalWorkOrders;
            const avgUtilization = totalTarget > 0 ? ((totalInstalled / totalTarget) * 100).toFixed(1) : 0;
            
            // Location Summary Row
            csvData.push({
                'Location': `TOTAL - ${location}`,
                'Grouping': 'SUMMARY',
                'Phase': 'SUMMARY',
                'Target': totalTarget,
                'Work_Orders': totalWorkOrders,
                'Pending_WO': totalPending,
                'Meters_Installed': totalInstalled,
                'Achieved_Percent': `${avgUtilization}%`
            });

            // Detail Rows
            locationData.forEach(row => {
                csvData.push({
                    'Location': row.location,
                    'Grouping': `${row.meterType} / ${row.phase}`,
                    'Phase': row.phase, // Redundant but keeping for column consistency
                    'Target': row.target,
                    'Work_Orders': row.workOrders,
                    'Pending_WO': row.pendingWorkOrders,
                    'Meters_Installed': row.metersInstalled,
                    'Achieved_Percent': `${row.utilization}%`
                });
            });
        });

        // Add Grand Total
        const grandTotalTarget = summaryData.reduce((sum, row) => sum + row.target, 0);
        const grandTotalWorkOrders = summaryData.reduce((sum, row) => sum + row.workOrders, 0);
        const grandTotalInstalled = summaryData.reduce((sum, row) => sum + row.metersInstalled, 0);
        const grandTotalPending = grandTotalTarget - grandTotalWorkOrders;
        const grandTotalUtilization = grandTotalTarget > 0 ? ((grandTotalInstalled / grandTotalTarget) * 100).toFixed(1) : 0;

        csvData.push({
            'Location': 'GRAND TOTAL',
            'Grouping': 'GRAND TOTAL',
            'Phase': 'GRAND TOTAL',
            'Target': grandTotalTarget,
            'Work_Orders': grandTotalWorkOrders,
            'Pending_WO': grandTotalPending,
            'Meters_Installed': grandTotalInstalled,
            'Achieved_Percent': `${grandTotalUtilization}%`
        });

        return csvData;
    }
    
    function prepareNatConnDataForDownload(natConnData) {
        // Simple download function for the flat NAT_OF_CONN table
        let csvData = natConnData.map(row => ({
            'NAT_OF_CONN': row.natOfConn,
            'Target': row.target,
            'Work_Orders': row.workOrders,
            'Pending_WO': row.pendingWorkOrders,
            'Meters_Installed': row.metersInstalled,
            'Achieved_Percent': `${row.utilization}%`
        }));
        
        // Add Grand Total
        const grandTotalTarget = natConnData.reduce((sum, row) => sum + row.target, 0);
        const grandTotalWorkOrders = natConnData.reduce((sum, row) => sum + row.workOrders, 0);
        const grandTotalInstalled = natConnData.reduce((sum, row) => sum + row.metersInstalled, 0);
        const grandTotalPending = grandTotalTarget - grandTotalWorkOrders;
        const grandTotalUtilization = grandTotalTarget > 0 ? ((grandTotalInstalled / grandTotalTarget) * 100).toFixed(1) : 0;

        csvData.push({
            'NAT_OF_CONN': 'GRAND TOTAL',
            'Target': grandTotalTarget,
            'Work_Orders': grandTotalWorkOrders,
            'Pending_WO': grandTotalPending,
            'Meters_Installed': grandTotalInstalled,
            'Achieved_Percent': `${grandTotalUtilization}%`
        });

        return csvData;
    }

    // --- Modal close logic and Event Listeners ---
    
    const modal = document.getElementById('detailModal');
    const closeBtn = document.querySelector('.close-button');
    closeBtn.onclick = () => { modal.style.display = "none"; };
    window.onclick = (event) => {
      if (event.target == modal) {
        modal.style.display = "none";
      }
    };

    document.getElementById('hierarchyLevel').addEventListener('change', () => {
      updateFilterOptions();
      updateVisualization();
    });
    document.getElementById('filterSelect').addEventListener('change', updateVisualization);
    document.getElementById('meterType').addEventListener('change', updateVisualization);
    document.getElementById('connPhase').addEventListener('change', updateVisualization);
    document.getElementById('installStatus').addEventListener('change', updateVisualization);

    // Download button event listeners
    document.getElementById('downloadSummaryBtn').addEventListener('click', () => {
        const dataToDownload = prepareSummaryDataForDownload(currentSummaryData);
        downloadTableAsCSV(dataToDownload, 'smart_metering_hierarchy_summary.csv');
    });
    
    document.getElementById('downloadNatConnSummaryBtn').addEventListener('click', () => {
        const dataToDownload = prepareNatConnDataForDownload(currentNatConnData);
        downloadTableAsCSV(dataToDownload, 'smart_metering_nat_conn_summary.csv');
    });

    document.getElementById('downloadDetailBtn').addEventListener('click', () => {
        downloadTableAsCSV(currentConsumerData, 'consumer_details.csv');
    });
    
  </script>
</body>
</html>
