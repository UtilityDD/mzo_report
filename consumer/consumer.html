<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />  <title>Consumer Summary Report</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-start:#fafbff;
      --bg-end:#f0f4f8;
      --bg-gradient:linear-gradient(135deg, #fafbff 0%, #f0f4f8 50%, #e8f2ff 100%);
      --card:#ffffff;
      --card-hover:#f8fafc;
      --card-secondary:#fbfcfd;
      --border:#e1e8ef;
      --border-light:#f1f5f9;
      --border-accent:#d1d9e6;
      --text-primary:#1a202c;
      --text-secondary:#4a5568;
      --text-muted:#718096;
      --text-light:#a0aec0;
      --accent:#4299e1;
      --accent-hover:#3182ce;
      --accent-light:rgba(66,153,225,0.1);
      --accent-gradient:linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
      --success:#48bb78;
      --success-light:rgba(72,187,120,0.1);
      --warning:#ed8936;
      --warning-light:rgba(237,137,54,0.1);
      --info:#4299e1;
      --info-light:rgba(66,153,225,0.1);
      --error:#e53e3e;
      --error-light:rgba(229,62,62,0.1);
      --shadow-sm:0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
      --shadow-md:0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
      --shadow-lg:0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
      --shadow-xl:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
    }
    
    *{box-sizing:border-box}
    
    html,body{
      height:100%;
      margin:0;
      font-family:'Inter',system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
      color:var(--text-primary);
      background:var(--bg-gradient);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      font-size:14px;
      line-height:1.5;
    }
    
    .app{
      display:grid;
      grid-template-columns:320px 1fr;
      gap:20px;
      padding:20px;
      min-height:100vh;
      max-width:2000px;
      margin:0 auto;
    }
    
    .sidebar{
      background:var(--card);
      padding:20px;
      border-radius:12px;
      border:1px solid var(--border);
      box-shadow:var(--shadow-lg);
      height:fit-content;
      position:sticky;
      top:20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .main{
      display:flex;
      flex-direction:column;
      gap:20px;
      min-width:0;
    }
    
    h1{
      margin:0 0 4px 0;
      font-size:24px;
      font-weight:700;
      letter-spacing:-0.025em;
      color:var(--text-primary);
    }
    
    .subtitle{
      font-size:14px;
      color:var(--text-muted);
      line-height:1.6;
      margin:0;
    }
    
    /* --- Filter Styles (Horizontal) --- */
    .filter-bar{
      background:var(--card);
      padding:16px 20px;
      border-radius:12px;
      border:1px solid var(--border);
      box-shadow:var(--shadow-md);
      position: sticky;
      top: 20px;
      z-index: 15;
    }
    
    .filters{
      display:flex;
      flex-wrap: nowrap;
      gap:16px;
      margin-top:0;
      align-items:flex-end;
      overflow-x: auto;
      padding-bottom: 8px;
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }
    
    .filters::-webkit-scrollbar {
      height: 6px;
    }
    
    .filters::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .filters::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }
    
    .filter-group{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 120px;
      flex-shrink: 0;
    }
    
    label{
      font-size:12px;
      font-weight:600;
      color:var(--text-secondary);
      text-transform:uppercase;
      letter-spacing:0.05em;
      margin-bottom:2px;
    }

    .button-group{
      display:flex;
      gap:8px;
      flex-shrink: 0;
    }
    
    button {
      padding:8px 16px;
      border-radius:8px;
      border:1px solid var(--border);
      background:var(--accent-gradient);
      color:white;
      font-size:13px;
      font-weight:500;
      cursor:pointer;
      transition:all 0.2s ease;
      outline:none;
      white-space:nowrap;
      box-shadow:var(--shadow-sm);
    }
    
    button:hover {
      background:var(--accent-hover);
      box-shadow:var(--shadow-md);
      transform:translateY(-1px);
    }
    
    button.muted-btn {
      background:var(--card-secondary);
      color:var(--text-secondary);
      border:1px solid var(--border);
      box-shadow:var(--shadow-sm);
    }
    
    button.muted-btn:hover {
      background:var(--card-hover);
      box-shadow:var(--shadow-md);
    }
    /* -------------------------------- */
    
    select,input{
      width:100%;
      padding:8px 12px;
      border-radius:8px;
      border:1px solid var(--border);
      background:var(--card);
      color:var(--text-primary);
      font-size:13px;
      transition:all 0.2s ease;
      outline:none;
    }
    
    select:focus,input:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px var(--accent-light);
    }
    
    select:hover,input:hover{
      border-color:var(--text-muted);
    }
    
    .kpi-row{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
      gap:16px;
    }
    
    .kpi{
      background:var(--card);
      padding:20px;
      border-radius:12px;
      border:1px solid var(--border);
      transition:all 0.2s ease;
    }
    
    .charts-and-builder{
      display:grid;
      grid-template-columns:1fr;
      gap:24px;
    }
    
    .card{
      background:var(--card);
      padding:20px;
      border-radius:12px;
      border:1px solid var(--border);
      box-shadow:var(--shadow-md);
      transition:all 0.3s ease;
    }
    
    .card:hover{
      box-shadow:var(--shadow-lg);
      transform:translateY(-2px);
    }
    
    .card-title{
      font-size:18px;
      font-weight:600;
      color:var(--text-primary);
      margin:0;
    }
    
    .card-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:16px;
      flex-wrap:wrap;
      gap:12px;
    }
    
    .export-btn{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 16px;
      border-radius:8px;
      border:1px solid var(--border);
      background:linear-gradient(135deg, var(--success) 0%, #38a169 100%);
      color:white;
      font-size:13px;
      font-weight:500;
      cursor:pointer;
      transition:all 0.2s ease;
      outline:none;
      white-space:nowrap;
      box-shadow:var(--shadow-sm);
    }
    
    .export-btn:hover{
      background:linear-gradient(135deg, #38a169 0%, #2f855a 100%);
      box-shadow:var(--shadow-md);
      transform:translateY(-1px);
    }
    
    .export-btn svg{
      width:16px;
      height:16px;
    }

    /* --- Field Selection Styles (Checkbox) --- */
    .field-list-wrap {
      border: 1px solid var(--border);
      border-radius: 8px;
      min-height: 200px;
      max-height: 70vh;
      overflow-y: auto;
      padding: 12px; 
      background: var(--card);
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }
    
    .field-list-wrap::-webkit-scrollbar {
      width: 6px;
    }
    
    .field-list-wrap::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .field-list-wrap::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }
    
    .field-list-wrap label {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 4px;
        cursor: pointer;
        text-transform: none;
        letter-spacing: normal;
        font-weight: 400;
        font-size: 13px;
        color: var(--text-primary);
        border-radius: 6px;
        transition: all 0.15s ease;
    }
    
    .field-list-wrap label:hover {
        background: var(--card-hover);
    }
    
    .field-list-wrap input[type="checkbox"] {
        width: 16px;
        height: 16px;
        margin: 0;
        accent-color: var(--accent);
    }

    .field-group-title {
        font-size: 13px; 
        font-weight: 600; 
        color: var(--accent); 
        margin-bottom: 8px; 
        margin-top: 16px; 
        border-bottom: 1px solid var(--border-light); 
        padding-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .field-group-title:first-child {
        margin-top: 0;
    }
    /* --- End Field Selection Styles --- */
    
    .right-col{
      display:flex;
      flex-direction:column;
      gap:24px;
    }
    
    .chart-canvas{
      width:100%!important;
      height:280px!important;
    }
    
    .pie-row{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:16px;
    }
    
    .table-wrap{
      overflow:auto;
      margin-top:0;
      border-radius:8px;
      border:1px solid var(--border);
      position: relative;
      box-shadow:var(--shadow-lg);
      background:var(--card);
    }
    
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      color:var(--text-primary);
      font-size:12px;
    }
    
    thead{
      position:sticky;
      top:0;
      background:var(--bg-end);
      z-index:10;
    }
    
    th{
      padding:10px 8px;
      text-align:left;
      font-size:10px;
      font-weight:700;
      color:var(--text-secondary);
      text-transform:uppercase;
      letter-spacing:0.05em;
      border-bottom:2px solid var(--border);
      border-right:1px solid var(--border-light);
      min-width: 80px;
      position: relative;
      background:var(--bg-end);
      white-space:nowrap;
    }
    
    /* Ensure measure columns (numbers) are right-aligned */
    th.measure-column,
    th.pivot-column {
      text-align: right;
    }
    
    /* Column type color separators */
    th.dimension-column {
      border-left: 4px solid var(--success);
      background: var(--success-light);
    }
    
    th.measure-column {
      border-left: 4px solid var(--warning);
      background: var(--warning-light);
    }
    
    th.pivot-group-column {
      border-left: 4px solid var(--accent);
      background: var(--accent-light);
    }
    
    th:last-child{
      border-right:none;
    }

    th.sortable {
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    th.sortable:hover {
      background: var(--card-hover);
    }

    th.sorted-asc::after, th.sorted-desc::after {
      content: '';
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      border: 3px solid transparent;
    }
    th.sorted-asc::after {
      border-bottom-color: var(--accent);
    }
    th.sorted-desc::after {
      border-top-color: var(--accent);
    }
    
    /* NEW: Pivot Grouping Styles */
    .pivot-group-header {
      background: var(--accent-light);
      color: var(--accent);
      border-bottom: 2px solid var(--accent);
      text-align: left !important;
      font-weight: 700;
      font-size: 11px;
    }
    thead tr:nth-child(2) th {
        border-top: 1px solid var(--border-light);
        border-bottom: 2px solid var(--border);
    }
    
    td{
      padding:8px 8px;
      font-size:12px;
      border-bottom:1px solid var(--border-light);
      border-right:1px solid var(--border-light);
      white-space: nowrap;
      text-align: left;
    }
    
    /* Ensure all numeric data is right-aligned */
    td.measure-column,
    td.pivot-column {
      text-align: right;
    }
    
    /* Column type color separators for data cells */
    td.dimension-column {
      border-left: 4px solid var(--success);
      background: rgba(72, 187, 120, 0.03);
    }
    
    td.measure-column {
      border-left: 4px solid var(--warning);
      background: rgba(237, 137, 54, 0.03);
    }
    
    td:last-child{
      border-right:none;
    }
    
    tbody tr:hover{
      background:var(--card-hover);
    }
    
    tbody tr:last-child td{
      border-bottom:none;
    }
    
    /* NEW: Distinctly styled pivot column cells */
    td.pivot-column {
      background-color: var(--accent-light);
      border-left: 4px solid var(--accent);
    }

    tfoot tr {
      background: var(--bg-end);
      border-top: 2px solid var(--border);
    }
    
    tfoot td {
      font-weight: 600;
      color: var(--text-primary);
      border-bottom: none;
      border-top: none;
      padding: 10px 8px;
      font-size: 12px;
      text-align: left;
    }
    
    /* Ensure footer numeric data is right-aligned */
    tfoot td.measure-column,
    tfoot td.pivot-column {
      text-align: right;
    }
    
    /* Footer column type separators */
    tfoot td.dimension-column {
      border-left: 4px solid var(--success);
      background: rgba(72, 187, 120, 0.1);
    }
    
    tfoot td.measure-column {
      border-left: 4px solid var(--warning);
      background: rgba(237, 137, 54, 0.1);
    }
    
    tfoot td.pivot-column {
        background-color: rgba(66,153,225,0.15);
        border-left: 4px solid var(--accent);
    }
    
    .pagination-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 4px;
      color: var(--text-secondary);
      font-size: 13px;
      margin-top: 12px;
      border-top: 1px solid var(--border-light);
      background: var(--card);
    }
    
    .pagination-controls button {
      padding: 8px 16px;
      margin-left: 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 12px;
      font-weight: 500;
    }
    
    .pagination-controls button:hover:not(:disabled) {
      background: var(--accent);
      color: white;
      box-shadow: var(--shadow-sm);
    }
    
    .pagination-controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: var(--border-light);
    }
    .empty-state{
      display:flex;
      align-items:center;
      justify-content:center;
      height:100%;
      min-height: 200px;
      color:var(--text-muted);
      font-size:14px;
      text-align: center;
      padding: 40px 20px;
    }
    
    /* Mobile-first responsive design */
    @media(max-width:480px){
      .app{
        grid-template-columns:1fr;
        padding:12px;
        gap:16px;
      }
      
      .sidebar{
        position:static;
        order: -1; 
        padding:16px;
      }
      
      .filter-bar{
        order: -2;
        padding: 12px 16px;
      }
      
      .filters {
        flex-direction: column;
        align-items: stretch;
        flex-wrap: wrap;
        overflow-x: hidden;
        padding-bottom: 0;
        gap: 12px;
      }
      
      .filter-group {
        min-width: 100%;
      }
      
      .button-group {
        flex-direction: column;
        gap: 8px;
      }
      
      .button-group button {
        flex: none;
        width: 100%;
      }
      
      h1{
        font-size:20px;
      }
      
      .card{
        padding:16px;
      }
      
      .sidebar{
        padding:16px;
      }
      
      th{
        padding:6px 4px;
        min-width: 60px;
        font-size: 9px;
      }
      
      td{
        padding:6px 4px;
        font-size: 11px;
      }
      
      .table-wrap {
        font-size: 10px;
      }
      
      .card-header{
        flex-direction:column;
        align-items:stretch;
        gap:12px;
      }
      
      .export-btn{
        justify-content:center;
        width:100%;
      }
    }
    
    @media(min-width:481px) and (max-width:768px){
      .app{
        grid-template-columns:1fr;
        padding:16px;
        gap:16px;
      }
      
      .sidebar{
        position:static;
        order: -1; 
      }
      
      .filter-bar{
        order: -2; 
      }
      
      .filters {
        flex-wrap: wrap;
        gap: 12px;
      }
      
      .filter-group {
        min-width: calc(50% - 6px);
        flex-grow: 1;
      }
      
      h1{
        font-size:22px;
      }
    }
    
    @media(min-width:769px) and (max-width:1024px){
      .app{
        grid-template-columns:280px 1fr;
        gap:18px;
      }
      
      .filters {
        flex-wrap: wrap;
        gap: 14px;
      }
      
      .filter-group {
        min-width: 110px;
        flex-grow: 1;
      }
    }
    
    @media(min-width:1025px) and (max-width:1200px){
      .app{
        grid-template-columns:300px 1fr;
      }
    }
  </style>
  <style>
    /* Spinner Styles */
    .spinner-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(248, 250, 252, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      border-radius: 8px;
      transition: opacity 0.2s ease;
      opacity: 0;
      pointer-events: none;
    }
    .spinner-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .spinner {
      border: 3px solid var(--border-light);
      border-top: 3px solid var(--accent);
      border-radius: 50%;
      width: 32px;
      height: 32px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Custom Report Fields</h1>
      <div class="subtitle">Select the fields below to add or remove columns from the table.</div>
      <div id="availableFieldsList" class="field-list-wrap">
        <div class="empty-state">Loading Fields...</div>
      </div>
    </aside>

    <main class="main">
      <div>
        <h1 id="pageTitle">Consumer Summary Report</h1>
        <p class="subtitle">An interactive dashboard for analyzing consumer data across regions, divisions, and CCCs.</p>
      </div>
      <div class="filter-bar">
        <div class="filters">
          <div class="filter-group">
            <label>Region</label>
            <select id="regionSelect"><option value="ALL">All Regions</option></select>
          </div>
          
          <div class="filter-group">
            <label>Division</label>
            <select id="divisionSelect"><option value="ALL">All Divisions</option></select>
          </div>
          
          <div class="filter-group">
            <label>CCC</label>
            <select id="cccSelect"><option value="ALL">All CCCs</option></select>
          </div>
          
          <div class="filter-group">
            <label>Base Class</label>
            <select id="baseClassSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Category</label>
            <select id="categorySelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Meter Type</label>
            <select id="meterSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Phase</label>
            <select id="phaseSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Govt Status</label>
            <select id="govtSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Connected By</label>
            <select id="connBySelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="button-group" style="min-width: 80px;">
            <button id="resetBtn" class="muted-btn" style="flex:1">Reset</button>
          </div>
        </div>
      </div>
      
      <div class="charts-and-builder">
        
        <div class="card custom-report-builder">
          <div class="card-header">
            <div class="card-title">Custom Report Table</div>
            <button id="exportBtn" class="export-btn">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
              </svg>
              Export CSV
            </button>
          </div>
          <div class="table-wrap">
            <div id="tableSpinner" class="spinner-overlay visible">
              <div class="spinner"></div>
            </div>
            <table id="dataTable">
              <thead>
                <tr><th colspan="5" style="text-align: center;">Use the side panel to select columns</th></tr>
              </thead>
              <tbody></tbody>
              <tfoot></tfoot>
            </table>
          </div>
          <div id="paginationControls" class="pagination-controls" style="display: none;">
            <span id="paginationInfo"></span>
            <div class="pagination-nav"></div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .spinner {
      border: 3px solid var(--border-light);
      border-top: 3px solid var(--accent);
      border-radius: 50%;
      width: 32px;
      height: 32px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>

  <script>
    try {
      // Hierarchy mapping... (unchanged)
      const HIER = {
        "6610000": { name: "MALDA REGION", divisions: {
          "6611000": { name: "MALDA DIVISION", cccs: {"6611101":"MANIKCHAK","6611102":"GOLAPGANJ","6611103":"BAISHNABNAGAR","6611104":"KALIACHAK","6611105":"MOTHABARI","6611106":"SUJAPUR","6611107":"RATHBARI","6611108":"FULBARI","6611109":"MOKDUMPUR"}},
          "6612000": { name: "CHANCHAL DIVISION", cccs: {"6612101":"BHALUKA","6612102":"SAMSI","6612103":"PARANPUR","6612104":"CHANCHAL","6612105":"MALATIPUR","6612106":"HARISHCHANDRAPUR","6612107":"KUSHIDA"}},
          "6613000": { name: "GAZOLE DIVISION", cccs: {"6613101":"GAZOL","6613102":"AIHO","6613103":"PANDUA","6613104":"BAMONGOLA","6613105":"OLD MALDA"}}
        }},
        "6620000": { name: "UTTAR DINAJPUR REGION", divisions: {
          "6621000": { name: "RAIGANJ DIVISION", cccs: {"6621101":"ITAHAR","6621102":"HEMTABAD","6621103":"KALIYAGANJ","6621104":"RAIGANJ","6621105":"BIRNAGAR","6621106":"KARANDIGHI"}},
          "6622000": { name: "ISLAMPUR DIVISION", cccs: {"6622101":"ISLAMPUR","6622102":"CHOPRA","6622103":"DALKHOLA","6622104":"GOALPOKHER","6622105":"KANKI"}}
        }},
        "6630000": { name: "DAKSHIN DINAJPUR REGION", divisions: {
          "6631000": { name: "BALURGHAT DIVISION", cccs: {"6631101":"BALURGHAT","6631102":"TAPAN","6631103":"KUMARGANJ","6631104":"HILI","6631105":"PATIRAM"}},
          "6632000": { name: "BUNIADPUR DIVISION", cccs: {"6632101":"BUNIADPUR","6632102":"KUSMANDI","6632103":"HARIRAMPUR","6632104":"GANGARAMPUR"}}
        }}
      };
      
      const CORE_DIMENSIONS_ORDER = ['regionName', 'divisionName', 'cccName'];

      // Define all available fields for the custom report builder
      // NOTE: This array is now initially empty and populated dynamically in loadData
      let ALL_FIELDS = [];

      // Initial field definitions (static measures/dimensions)
      const STATIC_FIELDS = [
        { key: 'regionName', label: 'Region Name', type: 'dimension' },
        { key: 'divisionName', label: 'Division Name', type: 'dimension' },
        { key: 'cccName', label: 'CCC Name', type: 'dimension' },
        { key: 'COUNT', label: 'Total', type: 'measure', format: 'number' },
        { key: 'LOAD', label: 'Load (kW)', type: 'measure', format: 'number' },
        { key: 'SD_LAKH', label: 'SD', type: 'measure', format: 'osd' },
        { key: 'OSD_LAKH', label: 'OSD', type: 'measure', format: 'osd' },
        { key: 'Average_Load_per_Consumer', label: 'Avg Load/Cons', type: 'measure', format: 'decimal' },
        { key: 'Average_OSD_per_Consumer', label: 'Avg OSD/Cons', type: 'measure', format: 'decimal' }
        // OSB_GROUP field removed as per user request
      ];

      // Fields that MUST be generated as pivots
      const DYNAMIC_PIVOT_SPECS = [
          { key: 'BASE_CLASS', label: 'Base Class' }, 
          { key: 'CONN_PHASE', label: 'Phase' }, 
          { key: 'GOVT_STAT', label: 'Govt Status' }, 
          { key: 'CATEGORY', label: 'Category' },
          { key: 'TYPE_OF_METER', label: 'Meter Type' }, 
          { key: 'CONN_BY', label: 'Connected By' },
          { key: 'CONN_STAT', label: 'Connection Status' }
      ];


      // DOM references
      const regionSelect = document.getElementById('regionSelect');
      const divisionSelect = document.getElementById('divisionSelect');
      const cccSelect = document.getElementById('cccSelect');
      const baseClassSelect = document.getElementById('baseClassSelect');
      const categorySelect = document.getElementById('categorySelect');
      const meterSelect = document.getElementById('meterSelect');
      const phaseSelect = document.getElementById('phaseSelect');
      const govtSelect = document.getElementById('govtSelect');
      // const osbSelect = document.getElementById('osbSelect'); // Removed OSB Group
      const connBySelect = document.getElementById('connBySelect');
      const exportBtn = document.getElementById('exportBtn');
      const resetBtn = document.getElementById('resetBtn');
      const availableFieldsList = document.getElementById('availableFieldsList');
      const dataTable = document.getElementById('dataTable');
      const tableSpinner = document.getElementById('tableSpinner');

      let rawData = [];
      let filtered = [];

      let sortKey = null;
      let sortDirection = 'asc';

      let currentPage = 1;
      const ITEMS_PER_PAGE = 25;

      // Initialize selected columns with a default set of fields
      let selectedFields = [];
      
      /**
       * Ensures core geographical dimensions are ordered first (R, D, C)
       * and the 'COUNT' measure is always last.
       */
      function enforceDimensionOrder(fields) {
        let coreFields = [];
        let otherFields = [];
        let totalField = fields.find(f => f.key === 'COUNT');
        
        // 1. Separate fields
        fields.filter(f => f.key !== 'COUNT').forEach(f => {
            if (CORE_DIMENSIONS_ORDER.includes(f.key)) {
                coreFields.push(f);
            } else {
                otherFields.push(f);
            }
        });

        // 2. Sort core dimensions by the fixed R, D, C order
        coreFields.sort((a, b) => CORE_DIMENSIONS_ORDER.indexOf(a.key) - CORE_DIMENSIONS_ORDER.indexOf(b.key));

        // 3. Reconstruct the list: (R, D, C in order) + (other fields) + (COUNT)
        const newFields = [...coreFields, ...otherFields];
        
        // Re-add COUNT at the end if it was present
        if (totalField) {
            newFields.push(totalField);
        }
        return newFields;
      }
      
      // selectedFields is initialized after ALL_FIELDS is populated in loadData


      function mapHierarchy(ccc_code){
        for(const rKey of Object.keys(HIER)){
          const region = HIER[rKey];
          for(const dKey of Object.keys(region.divisions)){
            const div = region.divisions[dKey];
            if(div.cccs[ccc_code]){
              return { 
                regionCode: rKey, 
                regionName: region.name, 
                divisionCode: dKey, 
                divisionName: div.name, 
                cccCode: ccc_code, 
                cccName: div.cccs[ccc_code] 
              };
            }
          }
        }
        return null;
      }

      function updatePageTitleWithDate(){
        try {
          // Extract date from the first row of data (assuming Date column exists)
          if (rawData.length > 0) {
            const firstRow = rawData[0];
            let reportDate = '';
            
            // Try different possible date column names
            if (firstRow.Date) {
              reportDate = firstRow.Date;
            } else if (firstRow.DATE) {
              reportDate = firstRow.DATE;
            } else if (firstRow.date) {
              reportDate = firstRow.date;
            } else if (firstRow.REPORT_DATE) {
              reportDate = firstRow.REPORT_DATE;
            }
            
            // Format and update the title if date is found
            if (reportDate) {
              const pageTitle = document.getElementById('pageTitle');
              const formattedDate = formatDateString(reportDate);
              pageTitle.textContent = `Consumer Summary Report (${formattedDate})`;
            }
          }
        } catch (error) {
          console.warn('Could not extract date from data:', error);
          // Keep original title if date extraction fails
        }
      }

      function formatDateString(dateStr) {
        try {
          // Handle different date formats
          const date = new Date(dateStr);
          if (isNaN(date.getTime())) {
            // If not a valid date, return as is
            return dateStr;
          }
          
          // Format as readable date (e.g., "November 10, 2025")
          return date.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          });
        } catch (error) {
          // Return original string if formatting fails
          return dateStr;
        }
      }

      /**
       * Creates the pivot and pivot-measure field definitions dynamically 
       * based on unique values in the raw data.
       */
      function createPivotFields(pivotKey, pivotLabel) {
          // Find all unique, non-empty values for this pivot key
          const uniqueValues = Array.from(new Set(rawData.map(d => d[pivotKey]))).filter(Boolean).sort();
          
          if (uniqueValues.length === 0) return [];

          // 1. The main pivot field definition (used for the checkbox and group header)
          const pivotField = { 
              key: pivotKey, 
              label: pivotLabel, 
              type: 'pivot', 
              pivotValue: pivotKey, 
              pivotOptions: uniqueValues, 
              baseMeasure: 'COUNT' 
          };

          // 2. The derived measure fields (used for the detail columns)
          const pivotMeasures = uniqueValues.map(val => ({
              // Sanitize key by replacing non-alphanumeric with underscores for safe access
              key: `${pivotKey}_${val.toString().replace(/[^a-zA-Z0-9]/g, '_')}`, 
              label: val, // Use the value as the column header
              type: 'measure', 
              format: 'number', 
              isPivot: true, 
              pivotKey: pivotKey, 
              pivotVal: val
          }));
          
          return [pivotField, ...pivotMeasures];
      }


      async function loadData(url){
        try{
          const data = await d3.csv(url);
          rawData = data.map(r=>({
            ...r,
            CCC_CODE: (r.CCC_CODE||'').toString().trim(),
            COUNT: Number((r.COUNT||0).toString().replace(/,/g,''))||0,
            LOAD: Number((r.LOAD||0).toString().replace(/,/g,''))||0,
            SD_LAKH: Number((r.SD_LAKH||0).toString().replace(/,/g,''))||0,
            OSD_LAKH: Number((r.OSD_LAKH||0).toString().replace(/,/g,''))||0
          }));

          rawData.forEach(r=>{
            const m = mapHierarchy(r.CCC_CODE);
            if(m) {
              Object.assign(r,m);
            } else { 
              r.regionCode='UNKNOWN'; 
              r.regionName='UNKNOWN'; 
              r.divisionCode='UNKNOWN'; 
              r.divisionName='UNKNOWN'; 
              r.cccName = r.CCC_CODE; 
            }
            // Calculated fields are added to each row
            r.Average_Load_per_Consumer = r.COUNT ? r.LOAD / r.COUNT : 0;
            r.Average_OSD_per_Consumer = r.COUNT ? r.OSD_LAKH / r.COUNT : 0;
            r.Collection_Efficiency = r.SD_LAKH > 0 ? (1 - (r.OSD_LAKH / r.SD_LAKH)) : (r.SD_LAKH === 0 && r.OSD_LAKH === 0 ? 1 : null); 
          });

          // --- Dynamically create ALL_FIELDS array ---
          let dynamicFields = [];
          DYNAMIC_PIVOT_SPECS.forEach(spec => {
              dynamicFields.push(...createPivotFields(spec.key, spec.label));
          });

          // Combine static and dynamic fields
          ALL_FIELDS = [...STATIC_FIELDS, ...dynamicFields];
          
          // Set initial selected fields now that ALL_FIELDS is complete
          selectedFields = [
              ALL_FIELDS.find(f => f.key === 'regionName'),
              ALL_FIELDS.find(f => f.key === 'CONN_PHASE'), // Phase
              ALL_FIELDS.find(f => f.key === 'COUNT'),      // Total
          ].filter(Boolean); // Filter out any that might not be found

          selectedFields = enforceDimensionOrder(selectedFields);

          // Extract and update page title with date from data
          updatePageTitleWithDate();

          populateFilterOptions();
          initDragAndDrop(); // Renamed to initUI or similar, but keeping for compatibility
          applyFilters();
        }catch(err){
          alert('Failed to load CSV: '+err.message);
          console.error(err);
        }
      }

      function populateFilterOptions(){
        regionSelect.innerHTML = '<option value="ALL">All Regions</option>';
        divisionSelect.innerHTML = '<option value="ALL">All Divisions</option>';
        cccSelect.innerHTML = '<option value="ALL">All CCCs</option>';

        Object.keys(HIER).forEach(rKey=>{
          const opt = document.createElement('option'); 
          opt.value = rKey; 
          opt.textContent = HIER[rKey].name; 
          regionSelect.appendChild(opt);
        });

        function fill(selectEl, values){
          selectEl.innerHTML = '<option value="ALL">All</option>';
          Array.from(values).filter(Boolean).sort().forEach(v=>{ 
            const o = document.createElement('option'); 
            o.value = v; 
            o.textContent = v; 
            selectEl.appendChild(o); 
          });
        }

        fill(baseClassSelect, new Set(rawData.map(d=>d.BASE_CLASS)));
        fill(categorySelect, new Set(rawData.map(d=>d.CATEGORY)));
        fill(meterSelect, new Set(rawData.map(d=>d.TYPE_OF_METER)));
        fill(phaseSelect, new Set(rawData.map(d=>d.CONN_PHASE)));
        fill(govtSelect, new Set(rawData.map(d=>d.GOVT_STAT)));
        // OSB Group filter population removed
        fill(connBySelect, new Set(rawData.map(d=>d.CONN_BY)));

        regionSelect.onchange = onRegionChange;
        divisionSelect.onchange = onDivisionChange;
        cccSelect.onchange = applyFilters;
        baseClassSelect.onchange = applyFilters;
        categorySelect.onchange = applyFilters;
        meterSelect.onchange = applyFilters;
        phaseSelect.onchange = applyFilters;
        govtSelect.onchange = applyFilters;
        // osbSelect.onchange = applyFilters; // OSB Group listener removed
        connBySelect.onchange = applyFilters;

        onRegionChange();
      }

      function onRegionChange(){
        const r = regionSelect.value;
        divisionSelect.innerHTML = '<option value="ALL">All Divisions</option>';
        cccSelect.innerHTML = '<option value="ALL">All CCCs</option>';

        if(r === 'ALL'){
          Object.keys(HIER).forEach(rKey=>{
            const region = HIER[rKey];
            Object.keys(region.divisions).forEach(dKey=>{
              const opt = document.createElement('option'); 
              opt.value = dKey; 
              opt.textContent = region.divisions[dKey].name + ' — ' + region.name; 
              divisionSelect.appendChild(opt);
            });
          });
        } else {
          const region = HIER[r];
          Object.keys(region.divisions).forEach(dKey=>{
            const opt = document.createElement('option'); 
            opt.value = dKey; 
            opt.textContent = region.divisions[dKey].name; 
            divisionSelect.appendChild(opt);
          });
        }

        applyFilters();
      }

      function onDivisionChange(){
        const d = divisionSelect.value;
        cccSelect.innerHTML = '<option value="ALL">All CCCs</option>';

        if(d === 'ALL'){
          const r = regionSelect.value;
          if(r === 'ALL'){
            Object.keys(HIER).forEach(rKey=>{
              const region = HIER[rKey];
              Object.keys(region.divisions).forEach(dKey=>{
                const div = region.divisions[dKey];
                Object.keys(div.cccs).forEach(cKey=>{
                  const opt = document.createElement('option'); 
                  opt.value = cKey; 
                  opt.textContent = div.cccs[cKey] + ' — ' + div.name; 
                  cccSelect.appendChild(opt);
                });
              });
            });
          } else {
            const region = HIER[r];
            Object.keys(region.divisions).forEach(dKey=>{
              const div = region.divisions[dKey];
              Object.keys(div.cccs).forEach(cKey=>{
                const opt = document.createElement('option'); 
                opt.value = cKey; 
                opt.textContent = div.cccs[cKey]; 
                cccSelect.appendChild(opt);
              });
            });
          }
        } else {
          for(const rKey of Object.keys(HIER)){
            if(HIER[rKey].divisions[d]){
              const div = HIER[rKey].divisions[d];
              Object.keys(div.cccs).forEach(cKey=>{
                const opt = document.createElement('option'); 
                opt.value = cKey; 
                opt.textContent = div.cccs[cKey]; 
                cccSelect.appendChild(opt);
              });
              break;
            }
          }
        }

        applyFilters();
      }

      function resetFilters(){
        regionSelect.value='ALL';
        onRegionChange();
        divisionSelect.value='ALL';
        onDivisionChange();
        cccSelect.value='ALL';
        baseClassSelect.value='ALL';
        categorySelect.value='ALL';
        meterSelect.value='ALL';
        phaseSelect.value='ALL';
        govtSelect.value='ALL';
        // osbSelect.value='ALL'; // OSB Group reset removed
        connBySelect.value='ALL';
        applyFilters();
      }

      function applyFilters(){
        showSpinner();
        currentPage = 1; // Reset to first page on filter change

        const R = regionSelect.value;
        const D = divisionSelect.value;
        const C = cccSelect.value;

        filtered = rawData.filter(row=>{
          if(R !== 'ALL' && row.regionCode !== R) return false;
          if(D !== 'ALL' && row.divisionCode !== D) return false;
          if(C !== 'ALL' && row.cccCode !== C) return false;
          if(baseClassSelect.value !== 'ALL' && row.BASE_CLASS !== baseClassSelect.value) return false;
          if(categorySelect.value !== 'ALL' && row.CATEGORY !== categorySelect.value) return false;
          if(meterSelect.value !== 'ALL' && row.TYPE_OF_METER !== meterSelect.value) return false;
          if(phaseSelect.value !== 'ALL' && row.CONN_PHASE !== phaseSelect.value) return false;
          if(govtSelect.value !== 'ALL' && row.GOVT_STAT !== govtSelect.value) return false;
          // if(osbSelect.value !== 'ALL' && row.OSB_GROUP !== osbSelect.value) return false; // OSB Group filter removed
          if(connBySelect.value !== 'ALL' && row.CONN_BY !== connBySelect.value) return false;
          return true;
        });
        
        selectedFields = enforceDimensionOrder(selectedFields); // Re-enforce order on filter

        // Use a small timeout to allow the spinner to render before the blocking table render starts
        setTimeout(() => {
          renderCustomTable();
        }, 10);
      }

      function showSpinner() {
        tableSpinner.classList.add('visible');
      }

      function hideSpinner() {
        tableSpinner.classList.remove('visible');
      }
      
      function formatValue(value, format) {
        if (value === null || value === undefined) return '—';
        if (format === 'number') return Math.round(value).toLocaleString();
        if (format === 'decimal') return value.toFixed(2).toLocaleString();
        if (format === 'osd') {
          // Data is already in lakhs, so format appropriately
          const absValue = Math.abs(value);
          if (absValue >= 100) {
            // Convert to crores (100 lakhs = 1 crore)
            return (value / 100).toFixed(2) + ' ₹ Cr';
          } else if (absValue >= 1) {
            // Keep in lakhs
            return value.toFixed(2) + ' ₹ L';
          } else if (absValue >= 0.01) {
            // Convert to thousands (0.01 lakh = 1 thousand)
            return (value * 100).toFixed(0) + ' ₹ K';
          } else if (absValue > 0) {
            // Very small amounts in hundreds
            return (value * 100000).toFixed(0) + ' ₹';
          } else {
            return '0 ₹';
          }
        }
        if (format === 'percent') return (value * 100).toFixed(2) + '%';
        return value.toString();
      }
      
      /**
       * Expands any 'pivot' fields in the selected list into their respective 'measure' fields.
       * @param {Array} fields - The current selectedFields array.
       * @returns {Array} The final list of fields to be rendered.
       */
      function getFinalRenderFields(fields) {
          const finalFields = [];
          
          fields.forEach(field => {
              if (field.type === 'pivot') {
                  // Find all measure fields related to this pivot key (e.g., GOVT_STAT_YES, GOVT_STAT_NO)
                  const pivotMeasures = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === field.key);
                  finalFields.push(...pivotMeasures);
              } else {
                  finalFields.push(field);
              }
          });
          return finalFields;
      }

      // --- New Checkbox Column Management Logic ---
      
      function handleCheckboxChange(e) {
          const key = e.target.value;
          const isChecked = e.target.checked;
          const field = ALL_FIELDS.find(f => f.key === key);
          
          // Use a copy to manipulate
          let currentFields = [...selectedFields];
          
          if (isChecked) {
              // Add field, only if not already present
              if (field && !currentFields.some(f => f.key === key)) {
                  // Find a logical insertion point: dimensions first, then measures/pivots
                  const lastDimensionIndex = currentFields.findLastIndex(f => f.type === 'dimension' || f.type === 'pivot');
                  
                  if (field.type === 'dimension' || field.type === 'pivot') {
                      // Insert new dimension/pivot after the last existing dimension/pivot, respecting RDC order later
                      currentFields.splice(lastDimensionIndex + 1, 0, field);
                  } else {
                      // Insert new measure at the end, before COUNT (if COUNT exists)
                      const countIndex = currentFields.findIndex(f => f.key === 'COUNT');
                      if (countIndex > -1) {
                         currentFields.splice(countIndex, 0, field);
                      } else {
                         currentFields.push(field);
                      }
                  }
              }
          } else {
              // Remove field
              const index = currentFields.findIndex(f => f.key === key);
              if (index > -1) {
                  currentFields.splice(index, 1);
              }
          }
          
          // Always re-enforce the R, D, C order
          selectedFields = enforceDimensionOrder(currentFields);
          
          // Rerender
          currentPage = 1; 
          renderCustomTable();
      }
      
      function renderAvailableFields() {
        availableFieldsList.innerHTML = '';
        // Only show non-pivot-specific measures in the sidebar list
        const available = ALL_FIELDS.filter(f => !f.isPivot); 

        if (available.length === 0) {
            availableFieldsList.innerHTML = '<div class="empty-state">All available fields are in use.</div>';
            return;
        }

        // Helper function to check if a field is a core dimension
        const isCoreDimension = (field) => CORE_DIMENSIONS_ORDER.includes(field.key);

        // Group fields based on the user's request: Core Dimensions vs Everything Else
        const groups = { coreDimensions: [], otherFields: [] };
        available.forEach(field => {
            if (isCoreDimension(field)) {
                groups.coreDimensions.push(field);
            } else {
                // Everything else (other dimensions, pivots, and measures) goes here
                groups.otherFields.push(field);
            }
        });
        
        // Ensure fields in the side panel are displayed alphabetically within groups
        groups.coreDimensions.sort((a,b) => a.label.localeCompare(b.label));
        groups.otherFields.sort((a,b) => a.label.localeCompare(b.label));

        // Helper to render a group
        const renderGroup = (title, fields) => {
            if (fields.length === 0) return;
            
            const groupTitle = document.createElement('h3');
            groupTitle.className = 'field-group-title';
            groupTitle.textContent = title;
            availableFieldsList.appendChild(groupTitle);

            fields.forEach(field => {
                const label = document.createElement('label');
                
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.value = field.key;
                input.checked = selectedFields.some(f => f.key === field.key);
                input.addEventListener('change', handleCheckboxChange);

                label.appendChild(input);
                label.appendChild(document.createTextNode(field.label));
                
                availableFieldsList.appendChild(label);
            });
        };

        // Render groups based on the new logic
        renderGroup('Core Dimensions', groups.coreDimensions);
        renderGroup('Other Fields', groups.otherFields);
      }
      
      // --- End New Checkbox Column Management Logic ---

      function handleSort(e) {
          const newSortKey = e.currentTarget.dataset.key;
          const field = ALL_FIELDS.find(f => f.key === newSortKey);

          // Only sortable on dimension and measure fields
          if (!field || (field.type !== 'dimension' && field.type !== 'measure')) return;

          if (sortKey === newSortKey) {
              sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
          } else {
              sortKey = newSortKey;
              sortDirection = 'asc'; // Default to ascending for new column
          }
          
          currentPage = 1; // Reset to first page on sort change
          renderCustomTable();
      }


      function renderCustomTable(){
        const table = document.getElementById('dataTable');
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        const tfoot = table.querySelector('tfoot');
        const paginationControls = document.getElementById('paginationControls');
        thead.innerHTML = '';
        tbody.innerHTML = '';
        tfoot.innerHTML = '';
        
        // Re-render field list to ensure checkboxes match table state
        renderAvailableFields();

        // Fields for rendering (pivots expanded)
        const finalRenderFields = getFinalRenderFields(selectedFields);

        if(finalRenderFields.length === 0){
          // Reset sort state when table is empty
          sortKey = null;
          sortDirection = 'asc';

          thead.innerHTML = '<tr><th colspan="5" style="text-align: center;">Use the side panel to select columns</th></tr>';
          paginationControls.style.display = 'none';
          tfoot.innerHTML = '';
          hideSpinner();
          return;
        }

        // 1. Build Header
        const headerRowGroup = document.createElement('tr'); // First row for groups
        const headerRowDetail = document.createElement('tr'); // Second row for details (only for pivots)
        
        // Add Serial Number Header - spans both rows
        const snTh = document.createElement('th');
        snTh.textContent = 'SL. NO.';
        snTh.setAttribute('rowspan', 2); // Span two rows
        headerRowGroup.appendChild(snTh);

        // Note: We iterate over selectedFields (not expanded) to create the groups
        selectedFields.forEach(field => {
            const th = document.createElement('th');
            th.textContent = field.label;
            
            // Add column type classes for color separation
            if (field.type === 'dimension') {
                th.classList.add('dimension-column');
            } else if (field.type === 'measure') {
                th.classList.add('measure-column');
            }
            
            if (field.type === 'pivot') {
                th.classList.add('pivot-group-header', 'pivot-group-column');
                // Find the number of measures derived from this pivot
                const pivotMeasures = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === field.key);
                th.setAttribute('colspan', pivotMeasures.length);
                
                // Add detailed headers for the measures to the second row
                pivotMeasures.forEach(pm => {
                    const detailTh = document.createElement('th');
                    detailTh.textContent = pm.label;
                    detailTh.dataset.key = pm.key;
                    
                    // Sorting only applies to the detailed, un-grouped header cells
                    detailTh.classList.add('sortable');
                    // Apply pivot column style to the detail header
                    detailTh.classList.add('pivot-column'); 

                    detailTh.addEventListener('click', handleSort);
                    if (sortKey === pm.key) {
                        detailTh.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                    }
                    headerRowDetail.appendChild(detailTh);
                });

            } else {
                // Dimensions and Measures span both rows
                th.setAttribute('rowspan', 2);
                
                // Add sorting attributes directly to the main header
                const isSortable = field.type === 'dimension' || field.type === 'measure';
                if (isSortable) {
                    th.classList.add('sortable');
                    th.addEventListener('click', handleSort);
                    if (sortKey === field.key) {
                        th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                    }
                }
            }
            headerRowGroup.appendChild(th);
        });

        thead.appendChild(headerRowGroup);
        if (headerRowDetail.children.length > 0) {
            thead.appendChild(headerRowDetail);
        }

        
        // --- Aggregation & Rollup Logic (Remains the same) ---
        const groupingDimensions = selectedFields.filter(f => f.type === 'dimension');
        const pivotFields = selectedFields.filter(f => f.type === 'pivot');
        
        if (groupingDimensions.length === 0) {
            // Only measures (and pivot-derived measures), single aggregated row
            const totalAgg = {
                COUNT: d3.sum(filtered, d => d.COUNT),
                LOAD: d3.sum(filtered, d => d.LOAD),
                SD_LAKH: d3.sum(filtered, d => d.SD_LAKH),
                OSD_LAKH: d3.sum(filtered, d => d.OSD_LAKH),
                Average_Load_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_Load_per_Consumer) : 0,
                Average_OSD_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_OSD_per_Consumer) : 0,
            };
            
            // Add pivot aggregates if present
            if (pivotFields.length > 0) {
                pivotFields.forEach(pivotField => {
                    const pivotMeasures = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === pivotField.key);
                    pivotMeasures.forEach(pm => {
                        totalAgg[pm.key] = d3.sum(filtered.filter(d => d[pm.pivotKey] == pm.pivotVal), d => {
                            return d[pivotField.baseMeasure] || 0;
                        });
                    });
                });
            }

            const tr = document.createElement('tr');
            // Add serial number cell for the single aggregated row
            const snTd = document.createElement('td');
            snTd.textContent = 1;
            tr.appendChild(snTd);

            finalRenderFields.forEach(field => {
                const td = document.createElement('td');
                td.textContent = formatValue(totalAgg[field.key], field.format);
                
                // Apply classes based on column type
                if (field.isPivot) {
                    td.classList.add('pivot-column');
                } else if (field.type === 'dimension') {
                    td.classList.add('dimension-column');
                } else if (field.type === 'measure') {
                    td.classList.add('measure-column');
                }
                
                tr.appendChild(td);
            });
            if (finalRenderFields.length > 0) tbody.appendChild(tr);

        } else {
            // Dimensions and Measures (and potential pivot), aggregated data
            const dimKeys = groupingDimensions.map(d => d.key);
            const aggregatedData = d3.rollups(
                filtered,
                v => {
                    const obj = {};
                    // Use all measure fields from selectedFields
                    selectedFields.filter(f => f.type === 'measure' && !f.isPivot).forEach(m => {
                        if (m.key === 'COUNT' || m.key === 'LOAD' || m.key === 'SD_LAKH' || m.key === 'OSD_LAKH') {
                            obj[m.key] = d3.sum(v, d => d[m.key]);
                        } else if (m.key === 'Average_Load_per_Consumer' || m.key === 'Average_OSD_per_Consumer') {
                            obj[m.key] = d3.mean(v, d => v.filter(row => row.COUNT > 0).length > 0 ? d[m.key] : 0); 
                        } else if (m.key === 'OSB_GROUP') {
                            // This is a dimension, but in the finalRenderFields it's mixed. 
                            // Since it's a non-pivot dimension, it's already handled by the rollup key. 
                            // We need to ensure we don't try to aggregate it here.
                        }
                    });
                    
                    // Add pivot measures to the rollup object
                    if (pivotFields.length > 0) {
                        pivotFields.forEach(pivotField => {
                            const pivotMeasures = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === pivotField.key);
                            pivotMeasures.forEach(pm => {
                                // Find pivot value from filtered data based on pivot field.
                                obj[pm.key] = d3.sum(v.filter(d => d[pm.pivotKey] == pm.pivotVal), d => {
                                    return d[pivotField.baseMeasure] || 0;
                                });
                            });
                        });
                    }
                    
                    return obj;
                },
                ...dimKeys.map(key => d => d[key])
            );

            // 4. Transform rollups into flat array for table rendering
            const flatAggregatedData = [];
            function flatten(arr, currentDimensions) {
                if (!arr) return;
                arr.forEach(([key, value]) => {
                    const nextDimensions = [...currentDimensions, key];
                    if (Array.isArray(value)) {
                        flatten(value, nextDimensions);
                    } else {
                        const row = {};
                        dimKeys.forEach((k, i) => {
                            row[k] = nextDimensions[i];
                        });
                        Object.assign(row, value);
                        flatAggregatedData.push(row);
                    }
                });
            }
            flatten(aggregatedData, []);

            // 4a. Sort the data if a sortKey is set
            if (sortKey) {
                const sortField = ALL_FIELDS.find(f => f.key === sortKey);
                if (sortField) {
                    flatAggregatedData.sort((a, b) => {
                        let valA = a[sortKey];
                        let valB = b[sortKey];

                        if (valA == null) return 1;
                        if (valB == null) return -1;

                        let comparison = 0;
                        if (sortField.type === 'measure' || sortField.isPivot) {
                            comparison = valA - valB;
                        } else { // dimension
                            comparison = valA.toString().localeCompare(valB.toString());
                        }

                        return sortDirection === 'asc' ? comparison : -comparison;
                    });
                }
            }

            const totalItems = flatAggregatedData.length;
            const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
            const endIndex = startIndex + ITEMS_PER_PAGE;
            const paginatedData = flatAggregatedData.slice(startIndex, endIndex);

            // 5. Render rows
            paginatedData.forEach((row, index) => {
                const tr = document.createElement('tr');

                // Add serial number cell
                const snTd = document.createElement('td');
                snTd.textContent = startIndex + index + 1;
                tr.appendChild(snTd);

                finalRenderFields.forEach(field => {
                    const td = document.createElement('td');
                    let value = row[field.key];
                    td.textContent = formatValue(value, field.format);
                    
                    // Apply classes based on column type
                    if (field.isPivot) {
                        td.classList.add('pivot-column');
                    } else if (field.type === 'dimension') {
                        td.classList.add('dimension-column');
                    } else if (field.type === 'measure') {
                        td.classList.add('measure-column');
                    }

                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });

            renderPagination(totalItems);
        }
        
        // 6. Render Footer with Totals (if there are rows and measures)
        const hasMeasures = finalRenderFields.some(f => f.type === 'measure' || f.isPivot);
        if (tbody.children.length > 0 && hasMeasures) {
            const footerRow = document.createElement('tr');
            let totalLabelPlaced = false;

            // Add empty cell for Serial Number column
            footerRow.appendChild(document.createElement('td'));

            finalRenderFields.forEach(field => {
                const td = document.createElement('td');
                
                // Identify the position of the label for the grand total
                const isPivotGroupOrDimension = groupingDimensions.some(d => d.key === field.key) || pivotFields.some(p => p.key === field.key);

                if (isPivotGroupOrDimension) {
                    // Only place 'Grand Total' in the first non-RDC dimension/pivot column
                    if (!totalLabelPlaced && !CORE_DIMENSIONS_ORDER.includes(field.key)) {
                        td.textContent = 'Grand Total';
                        totalLabelPlaced = true;
                    } else if (CORE_DIMENSIONS_ORDER.includes(field.key) && !totalLabelPlaced) {
                       // Do nothing, leave empty for RDC columns
                    } else if (!totalLabelPlaced && field.type === 'dimension') {
                       // For any other dimension, if total label not placed
                       td.textContent = 'Grand Total';
                       totalLabelPlaced = true;
                    }
                } else if (field.type === 'measure' || field.isPivot) {
                    let totalValue;
                    // Sums and Pivot sums
                    if (['COUNT', 'LOAD', 'SD_LAKH', 'OSD_LAKH'].includes(field.key) || field.isPivot) {
                        if (field.isPivot) {
                            // Find the pivot field corresponding to this measure to get the base measure and pivot value
                            const pivotField = ALL_FIELDS.find(f => f.key === field.pivotKey);
                            totalValue = d3.sum(filtered.filter(d => d[field.pivotKey] === field.pivotVal), d => d[pivotField.baseMeasure] || 0);
                        } else {
                            totalValue = d3.sum(filtered, d => d[field.key] || 0);
                        }
                    } 
                    // Averages
                    else if (field.key === 'Average_Load_per_Consumer') {
                        const totalCount = d3.sum(filtered, d => d.COUNT);
                        totalValue = totalCount > 0 ? d3.sum(filtered, d => d.LOAD) / totalCount : 0;
                    } else if (field.key === 'Average_OSD_per_Consumer') {
                        const totalCount = d3.sum(filtered, d => d.COUNT);
                        totalValue = totalCount > 0 ? d3.sum(filtered, d => d.OSD_LAKH) / totalCount : 0;
                    } 
                    td.textContent = formatValue(totalValue, field.format);
                }

                // Apply classes based on column type in the footer
                if (field.isPivot) {
                    td.classList.add('pivot-column');
                } else if (field.type === 'dimension') {
                    td.classList.add('dimension-column');
                } else if (field.type === 'measure') {
                    td.classList.add('measure-column');
                }

                footerRow.appendChild(td);
            });
            tfoot.appendChild(footerRow);
        }
        
        if(tbody.children.length === 0 && finalRenderFields.length > 0) {
            tfoot.innerHTML = ''; // Also clear footer if no rows
            paginationControls.style.display = 'none';
            tbody.innerHTML = `<tr><td colspan="${finalRenderFields.length + 1}" class="empty-state">No data matches current filters for these columns.</td></tr>`;
        }

        hideSpinner();
      }

      function initDragAndDrop() {
        // Pagination listeners
        document.getElementById('paginationControls').addEventListener('click', e => {
            if (e.target.matches('.prev-btn')) {
                if (currentPage > 1) {
                    currentPage--;
                    renderCustomTable();
                }
            }
            if (e.target.matches('.next-btn')) {
                const totalItems = document.getElementById('paginationInfo').dataset.totalItems || 0;
                const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderCustomTable();
                }
            }
        });

        renderAvailableFields();
      }

      function renderPagination(totalItems) {
        const paginationControls = document.getElementById('paginationControls');
        const paginationInfo = document.getElementById('paginationInfo');
        const paginationNav = paginationControls.querySelector('.pagination-nav');

        paginationNav.innerHTML = '';
        paginationInfo.innerHTML = '';

        if (totalItems <= ITEMS_PER_PAGE) {
            paginationControls.style.display = 'none';
            return;
        }

        paginationControls.style.display = 'flex';
        const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
        
        // Clamp currentPage just in case
        if (currentPage > totalPages) currentPage = totalPages;
        if (currentPage < 1) currentPage = 1;

        paginationInfo.textContent = `Page ${currentPage} of ${totalPages} (${totalItems.toLocaleString()} rows)`;
        paginationInfo.dataset.totalItems = totalItems;

        const prevBtn = `<button class="prev-btn" ${currentPage === 1 ? 'disabled' : ''}>Previous</button>`;
        const nextBtn = `<button class="next-btn" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>`;
        
        paginationNav.innerHTML = `${prevBtn}${nextBtn}`;
      }

      function exportFilteredCSV(){
        // Get the fields exactly as they will appear in the table columns
        const finalRenderFields = getFinalRenderFields(selectedFields);

        if(finalRenderFields.length === 0){
             alert('Please select columns for the table before exporting.');
             return;
        }

        const groupingDimensions = selectedFields.filter(f => f.type === 'dimension');
        const pivotFields = selectedFields.filter(f => f.type === 'pivot');
        
        const exportKeys = finalRenderFields.map(f => f.key);
        // Special case: for pivot headers, we must use the combination of Pivot Label and Detail Label
        // Example: Phase (Group) + 1-ph (Detail) -> "Phase: 1-ph"
        const exportLabels = finalRenderFields.map(f => {
            if (f.isPivot) {
                const pivotGroup = ALL_FIELDS.find(p => p.key === f.pivotKey);
                return `${pivotGroup ? pivotGroup.label : f.pivotKey}: ${f.label}`;
            }
            return f.label;
        });
        
        let exportRows = [];

        if (groupingDimensions.length === 0) {
            const totalAgg = {
                COUNT: d3.sum(filtered, d => d.COUNT),
                LOAD: d3.sum(filtered, d => d.LOAD),
                SD_LAKH: d3.sum(filtered, d => d.SD_LAKH),
                OSD_LAKH: d3.sum(filtered, d => d.OSD_LAKH),
                Average_Load_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_Load_per_Consumer) : 0,
                Average_OSD_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_OSD_per_Consumer) : 0,
            };
            
            // Add pivot aggregates if present
            if (pivotFields.length > 0) {
                pivotFields.forEach(pivotField => {
                    const pivotMeasures = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === pivotField.key);
                    pivotMeasures.forEach(pm => {
                        totalAgg[pm.key] = d3.sum(filtered.filter(d => d[pm.pivotKey] == pm.pivotVal), d => {
                            return d[pivotField.baseMeasure] || 0;
                        });
                    });
                });
            }
            
            exportRows.push(totalAgg);

        } else {
            const dimKeys = groupingDimensions.map(d => d.key);
            const aggregatedData = d3.rollups(
                filtered,
                v => {
                    const obj = {};
                    // Use all measure fields from selectedFields
                    selectedFields.filter(f => f.type === 'measure' && !f.isPivot).forEach(m => {
                        if (m.key === 'COUNT' || m.key === 'LOAD' || m.key === 'SD_LAKH' || m.key === 'OSD_LAKH') {
                            obj[m.key] = d3.sum(v, d => d[m.key]);
                        } else if (m.key === 'Average_Load_per_Consumer' || m.key === 'Average_OSD_per_Consumer') {
                            obj[m.key] = d3.mean(v, d => v.filter(row => row.COUNT > 0).length > 0 ? d[m.key] : 0);
                        }
                    });

                    // Add pivot measures to the rollup object
                    if (pivotFields.length > 0) {
                        pivotFields.forEach(pivotField => {
                            const pivotMeasures = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === pivotField.key);
                            pivotMeasures.forEach(pm => {
                                obj[pm.key] = d3.sum(v.filter(d => d[pm.pivotKey] == pm.pivotVal), d => {
                                    return d[pivotField.baseMeasure] || 0;
                                });
                            });
                        });
                    }
                    
                    return obj;
                },
                ...dimKeys.map(key => d => d[key])
            );

            function flatten(arr, currentDimensions) {
                if (!arr) return;
                arr.forEach(([key, value]) => {
                    const nextDimensions = [...currentDimensions, key];
                    if (Array.isArray(value)) {
                        flatten(value, nextDimensions);
                    } else {
                        const row = {};
                        dimKeys.forEach((k, i) => {
                            row[k] = nextDimensions[i];
                        });
                        Object.assign(row, value);
                        exportRows.push(row);
                    }
                });
            }
            flatten(aggregatedData, []);
        }

        if(!exportRows.length){ 
          alert('No rows to export with current filters and columns'); 
          return; 
        }
        
        // Escape quotes and wrap values
        const csv = [exportLabels.join(',')]
          .concat(exportRows.map((r, index)=> {
              // Add a Serial Number column to the export for consistency
              const rowValues = [index + 1].concat(exportKeys.map(k => {
                  const field = ALL_FIELDS.find(f => f.key === k);
                  return JSON.stringify(formatValue(r[k], field.format || 'text'));
              }));
              return rowValues.join(',');
          }))
          .join('\n');
          
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); 
        a.href = url; 
        a.download = 'custom_ccc_report.csv'; 
        document.body.appendChild(a); 
        a.click(); 
        a.remove();
      }

      // Event listeners
      exportBtn.addEventListener('click', exportFilteredCSV);
      resetBtn.addEventListener('click', resetFilters);

      // Initial load
      loadData('https://docs.google.com/spreadsheets/d/e/2PACX-1vQT4ufTMHJGTUqNSqFSzz0q2x-ShM_WHlfSRxT4tVqA6GcaMK5g38PDLmcJR4JXuxLi-tKafW-Yxwdo/pub?gid=0&single=true&output=csv');

    } catch(e){
      console.error('Dashboard initialization failed:', e);
      document.body.innerHTML = '<div style="color:#ef4444;padding:24px;font-family:monospace"><strong>Dashboard Error:</strong><br><br>'+(e && e.stack ? e.stack : e) + '</div>';
    }
  </script>
</body>
</html>
