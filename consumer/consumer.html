<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CCC Hierarchical Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-start:#0a0e1a;
      --bg-end:#05080f;
      --card:#151921;
      --card-hover:#1a1f2b;
      --border:#1f2937;
      --text-primary:#f9fafb;
      --text-secondary:#9ca3af;
      --text-muted:#6b7280;
      --accent:#6366f1;
      --accent-hover:#4f46e5;
      --accent-light:rgba(99,102,241,0.1);
      --success:#10b981;
      --warning:#f59e0b;
    }
    
    *{box-sizing:border-box}
    
    html,body{
      height:100%;
      margin:0;
      font-family:'Inter',system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
      color:var(--text-primary);
      background:linear-gradient(135deg,var(--bg-start) 0%, var(--bg-end) 100%);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    
    .app{
      display:grid;
      grid-template-columns:280px 1fr;
      gap:24px;
      padding:24px;
      min-height:100vh;
      max-width:2000px;
      margin:0 auto;
    }
    
    .sidebar{
      background:var(--card);
      padding:24px;
      border-radius:16px;
      border:1px solid var(--border);
      height:fit-content;
      position:sticky;
      top:24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .main{
      display:flex;
      flex-direction:column;
      gap:24px;
      min-width:0;
    }
    
    h1{
      margin:0 0 4px 0;
      font-size:20px;
      font-weight:600;
      letter-spacing:-0.02em;
    }
    
    .subtitle{
      font-size:13px;
      color:var(--text-muted);
      line-height:1.5;
    }
    
    /* --- Filter Styles (Horizontal) --- */
    .filter-bar{
      background:var(--card);
      padding:16px 24px;
      border-radius:12px;
      border:1px solid var(--border);
    }
    
    .filters{
      display:flex;
      flex-wrap:wrap;
      gap:16px;
      margin-top:0;
      align-items:flex-end;
    }
    
    .filter-group{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 120px;
    }
    
    label{
      font-size:12px;
      font-weight:500;
      color:var(--text-secondary);
      text-transform:uppercase;
      letter-spacing:0.05em;
    }

    .button-group{
      display:flex;
      gap:8px;
    }
    /* -------------------------------- */
    
    select,input{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid var(--border);
      background:var(--bg-end);
      color:var(--text-primary);
      font-size:14px;
      transition:all 0.2s ease;
      outline:none;
    }
    
    .kpi-row{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
      gap:16px;
    }
    
    .kpi{
      background:var(--card);
      padding:20px;
      border-radius:12px;
      border:1px solid var(--border);
      transition:all 0.2s ease;
    }
    
    .charts-and-builder{
      display:grid;
      grid-template-columns:1fr 480px;
      gap:24px;
    }
    
    .card{
      background:var(--card);
      padding:24px;
      border-radius:12px;
      border:1px solid var(--border);
    }
    
    .card-title{
      font-size:15px;
      font-weight:600;
      color:var(--text-primary);
    }

    /* --- Drag and Drop Styles --- */
    .field-list-wrap {
      border: 1px solid var(--border);
      border-radius: 8px;
      min-height: 200px;
      max-height: 80vh;
      overflow-y: auto;
      padding: 8px;
      background: var(--bg-end);
    }
    
    .drag-item {
      padding: 8px 12px;
      border-radius: 6px;
      background: var(--card-hover);
      border: 1px solid var(--border);
      font-size: 14px;
      cursor: grab;
      font-weight: 500;
      transition: background 0.1s ease;
      user-select: none;
      margin-bottom: 4px;
    }
    
    .drag-item:hover {
      background: var(--text-primary);
      color: var(--card);
    }
    
    .drag-item.dragging {
      opacity: 0.4;
    }

    /* Table drop target styles */
    .table-drop-target {
        border: 2px dashed var(--accent);
        background: var(--accent-light);
    }

    .th-drop-left, .th-drop-right {
        position: relative;
    }
    .th-drop-left::before, .th-drop-right::after {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        width: 10px;
        background: var(--accent);
        opacity: 0.8;
        z-index: 20;
    }
    .th-drop-left::before { left: 0; }
    .th-drop-right::after { right: 0; }
    /* --- End Drag and Drop Styles --- */
    
    .right-col{
      display:flex;
      flex-direction:column;
      gap:24px;
    }
    
    .chart-canvas{
      width:100%!important;
      height:280px!important;
    }
    
    .pie-row{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:16px;
    }
    
    .table-wrap{
      overflow:auto;
      max-height: calc(100vh - 200px); 
      margin-top:16px;
      border-radius:8px;
      border:1px solid var(--border);
    }
    
    table{
      width:100%;
      border-collapse:collapse;
      color:var(--text-primary);
    }
    
    thead{
      position:sticky;
      top:0;
      background:var(--bg-end);
      z-index:10;
    }
    
    th{
      padding:12px;
      text-align:left;
      font-size:11px;
      font-weight:600;
      color:var(--text-secondary);
      text-transform:uppercase;
      letter-spacing:0.05em;
      border-bottom:1px solid var(--border);
      min-width: 100px;
      cursor: grab; 
    }
    
    td{
      padding:12px;
      font-size:13px;
      border-bottom:1px solid var(--border);
      white-space: nowrap;
    }
    
    .empty-state{
      display:flex;
      align-items:center;
      justify-content:center;
      height:100%;
      min-height: 150px;
      color:var(--text-muted);
      font-size:14px;
    }
    
    @media(max-width:1200px){
      .charts-and-builder{
        grid-template-columns:1fr;
      }
      .kpi-row{
        grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
      }
      .app{
        grid-template-columns:1fr;
      }
      .sidebar{
        position:static;
        order: -1; 
      }
      .filter-bar{
        order: -2; 
      }
    }
    
    @media(max-width:900px){
      .app{
        padding:16px;
        gap:16px;
      }
      .pie-row{
        grid-template-columns:1fr;
      }
    }
    
    @media(max-width:600px){
      .kpi-row{
        grid-template-columns:1fr;
      }
      h1{
        font-size:18px;
      }
      .card{
        padding:16px;
      }
      .sidebar{
        padding:16px;
      }
      .filter-bar{
        padding: 12px;
      }
      .filters {
        flex-direction: column;
        align-items: stretch;
      }
      .filter-group {
        min-width: 100%;
      }
      .button-group button {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Available Fields</h1>
      <div class="subtitle">Drag fields to the table header to add columns. Drag columns back here to remove.</div>
      <div id="availableFieldsList" class="field-list-wrap">
        <div class="empty-state">Loading Fields...</div>
      </div>
    </aside>

    <main class="main">
      <div class="filter-bar">
        <div class="filters">
          <div class="filter-group">
            <label>Region</label>
            <select id="regionSelect"><option value="ALL">All Regions</option></select>
          </div>
          
          <div class="filter-group">
            <label>Division</label>
            <select id="divisionSelect"><option value="ALL">All Divisions</option></select>
          </div>
          
          <div class="filter-group">
            <label>CCC</label>
            <select id="cccSelect"><option value="ALL">All CCCs</option></select>
          </div>
          
          <div class="filter-group">
            <label>Base Class</label>
            <select id="baseClassSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Category</label>
            <select id="categorySelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Meter Type</label>
            <select id="meterSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Phase</label>
            <select id="phaseSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Govt Status</label>
            <select id="govtSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>OSB Group</label>
            <select id="osbSelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="filter-group">
            <label>Connected By</label>
            <select id="connBySelect"><option value="ALL">All</option></select>
          </div>
          
          <div class="button-group" style="min-width: 120px;">
            <button id="resetBtn" class="muted-btn" style="flex:1">Reset</button>
            <button id="exportBtn" style="flex:1">Export</button>
          </div>
        </div>
      </div>
      
      <div class="kpi-row">
        <div class="kpi">
          <div class="label">Total Consumers</div>
          <div id="kpiCount" class="num">—</div>
        </div>
        <div class="kpi">
          <div class="label">Total Load (kW)</div>
          <div id="kpiLoad" class="num">—</div>
        </div>
        <div class="kpi">
          <div class="label">Total SD (₹ lakh)</div>
          <div id="kpiSD" class="num">—</div>
        </div>
        <div class="kpi">
          <div class="label">Total OSD (₹ lakh)</div>
          <div id="kpiOSD" class="num">—</div>
        </div>
      </div>

      <div class="charts-and-builder">
        
        <div class="card custom-report-builder">
          <div class="card-title">Custom Report Table</div>
          <div class="table-wrap">
            <table id="dataTable">
              <thead>
                <tr><th colspan="5" style="text-align: center;">Drag fields from the sidebar to create your report</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        
        <div class="right-col">
          <div class="card">
            <div class="card-title" style="margin-bottom:20px">Base Class Distribution (Count)</div>
            <canvas id="stackedBar" class="chart-canvas"></canvas>
          </div>

          <div class="pie-row">
            <div class="pie-card">
              <div class="card-title">Meter Type</div>
              <canvas id="pieMeter" class="pie-canvas"></canvas>
            </div>
            <div class="pie-card">
              <div class="card-title">Connection Phase</div>
              <canvas id="piePhase" class="pie-canvas"></canvas>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    try {
      // Hierarchy mapping... (unchanged)
      const HIER = {
        "6610000": { name: "MALDA REGION", divisions: {
          "6611000": { name: "MALDA DIVISION", cccs: {"6611101":"MANIKCHAK","6611102":"GOLAPGANJ","6611103":"BAISHNABNAGAR","6611104":"KALIACHAK","6611105":"MOTHABARI","6611106":"SUJAPUR","6611107":"RATHBARI","6611108":"FULBARI","6611109":"MOKDUMPUR"}},
          "6612000": { name: "CHANCHAL DIVISION", cccs: {"6612101":"BHALUKA","6612102":"SAMSI","6612103":"PARANPUR","6612104":"CHANCHAL","6612105":"MALATIPUR","6612106":"HARISHCHANDRAPUR","6612107":"KUSHIDA"}},
          "6613000": { name: "GAZOLE DIVISION", cccs: {"6613101":"GAZOL","6613102":"AIHO","6613103":"PANDUA","6613104":"BAMONGOLA","6613105":"OLD MALDA"}}
        }},
        "6620000": { name: "UTTAR DINAJPUR REGION", divisions: {
          "6621000": { name: "RAIGANJ DIVISION", cccs: {"6621101":"ITAHAR","6621102":"HEMTABAD","6621103":"KALIYAGANJ","6621104":"RAIGANJ","6621105":"BIRNAGAR","6621106":"KARANDIGHI"}},
          "6622000": { name: "ISLAMPUR DIVISION", cccs: {"6622101":"ISLAMPUR","6622102":"CHOPRA","6622103":"DALKHOLA","6622104":"GOALPOKHER","6622105":"KANKI"}}
        }},
        "6630000": { name: "DAKSHIN DINAJPUR REGION", divisions: {
          "6631000": { name: "BALURGHAT DIVISION", cccs: {"6631101":"BALURGHAT","6631102":"TAPAN","6631103":"KUMARGANJ","6631104":"HILI","6631105":"PATIRAM"}},
          "6632000": { name: "BUNIADPUR DIVISION", cccs: {"6632101":"BUNIADPUR","6632102":"KUSMANDI","6632103":"HARIRAMPUR","6632104":"GANGARAMPUR"}}
        }}
      };

      // Define all available fields for the custom report builder
      // GOVT_STAT is a 'pivot' type, and its resulting measures are defined below it.
      const ALL_FIELDS = [
        { key: 'regionName', label: 'Region Name', type: 'dimension' },
        { key: 'divisionName', label: 'Division Name', type: 'dimension' },
        { key: 'cccName', label: 'CCC Name', type: 'dimension' },
        { key: 'BASE_CLASS', label: 'Base Class', type: 'dimension' },
        { key: 'CATEGORY', label: 'Category', type: 'dimension' },
        { key: 'TYPE_OF_METER', label: 'Meter Type', type: 'dimension' },
        { key: 'CONN_PHASE', label: 'Phase', type: 'dimension' },
        
        { key: 'GOVT_STAT', label: 'Govt Status', type: 'pivot', pivotValue: 'GOVT_STAT', pivotOptions: ['YES', 'NO'], baseMeasure: 'COUNT' },
        { key: 'GOVT_STAT_YES', label: 'Govt Status (Yes)', type: 'measure', format: 'number', isPivot: true, pivotKey: 'GOVT_STAT', pivotVal: 'YES' },
        { key: 'GOVT_STAT_NO', label: 'Govt Status (No)', type: 'measure', format: 'number', isPivot: true, pivotKey: 'GOVT_STAT', pivotVal: 'NO' },
        
        { key: 'OSB_GROUP', label: 'OSB Group', type: 'dimension' },
        { key: 'CONN_BY', label: 'Connected By', type: 'dimension' },
        { key: 'COUNT', label: 'Count', type: 'measure', format: 'number' },
        { key: 'LOAD', label: 'Load (kW)', type: 'measure', format: 'number' },
        { key: 'SD_LAKH', label: 'SD (₹ Lakh)', type: 'measure', format: 'number' },
        { key: 'OSD_LAKH', label: 'OSD (₹ Lakh)', type: 'measure', format: 'number' },
        { key: 'Average_Load_per_Consumer', label: 'Avg Load/Cons', type: 'measure', format: 'decimal' },
        { key: 'Average_OSD_per_Consumer', label: 'Avg OSD/Cons', type: 'measure', format: 'decimal' },
        { key: 'Collection_Efficiency', label: 'Coll Efficiency', type: 'measure', format: 'percent' },
      ];

      // DOM references
      const regionSelect = document.getElementById('regionSelect');
      const divisionSelect = document.getElementById('divisionSelect');
      const cccSelect = document.getElementById('cccSelect');
      const baseClassSelect = document.getElementById('baseClassSelect');
      const categorySelect = document.getElementById('categorySelect');
      const meterSelect = document.getElementById('meterSelect');
      const phaseSelect = document.getElementById('phaseSelect');
      const govtSelect = document.getElementById('govtSelect');
      const osbSelect = document.getElementById('osbSelect');
      const connBySelect = document.getElementById('connBySelect');
      const exportBtn = document.getElementById('exportBtn');
      const resetBtn = document.getElementById('resetBtn');
      const availableFieldsList = document.getElementById('availableFieldsList');
      const dataTable = document.getElementById('dataTable');

      let rawData = [];
      let filtered = [];
      let stackedBarChart = null, pieMeterChart = null, piePhaseChart = null;

      // Initialize selected columns with a default set of fields
      let selectedFields = [
        ALL_FIELDS.find(f => f.key === 'divisionName'),
        ALL_FIELDS.find(f => f.key === 'cccName'),
        ALL_FIELDS.find(f => f.key === 'COUNT'),
        ALL_FIELDS.find(f => f.key === 'LOAD'),
        ALL_FIELDS.find(f => f.key === 'OSD_LAKH'),
      ];

      function mapHierarchy(ccc_code){
        for(const rKey of Object.keys(HIER)){
          const region = HIER[rKey];
          for(const dKey of Object.keys(region.divisions)){
            const div = region.divisions[dKey];
            if(div.cccs[ccc_code]){
              return { 
                regionCode: rKey, 
                regionName: region.name, 
                divisionCode: dKey, 
                divisionName: div.name, 
                cccCode: ccc_code, 
                cccName: div.cccs[ccc_code] 
              };
            }
          }
        }
        return null;
      }

      async function loadData(url){
        try{
          const data = await d3.csv(url);
          rawData = data.map(r=>({
            ...r,
            CCC_CODE: (r.CCC_CODE||'').toString().trim(),
            COUNT: Number((r.COUNT||0).toString().replace(/,/g,''))||0,
            LOAD: Number((r.LOAD||0).toString().replace(/,/g,''))||0,
            SD_LAKH: Number((r.SD_LAKH||0).toString().replace(/,/g,''))||0,
            OSD_LAKH: Number((r.OSD_LAKH||0).toString().replace(/,/g,''))||0
          }));

          rawData.forEach(r=>{
            const m = mapHierarchy(r.CCC_CODE);
            if(m) {
              Object.assign(r,m);
            } else { 
              r.regionCode='UNKNOWN'; 
              r.regionName='UNKNOWN'; 
              r.divisionCode='UNKNOWN'; 
              r.divisionName='UNKNOWN'; 
              r.cccName = r.CCC_CODE; 
            }
            // Calculated fields are added to each row
            r.Average_Load_per_Consumer = r.COUNT ? r.LOAD / r.COUNT : 0;
            r.Average_OSD_per_Consumer = r.COUNT ? r.OSD_LAKH / r.COUNT : 0;
            // Handle division by zero for efficiency calculation
            r.Collection_Efficiency = r.SD_LAKH > 0 ? (1 - (r.OSD_LAKH / r.SD_LAKH)) : (r.SD_LAKH === 0 && r.OSD_LAKH === 0 ? 1 : null); 
          });

          populateFilterOptions();
          initDragAndDrop();
          applyFilters();
        }catch(err){
          // This alert is what the user saw in the prompt, let's keep it to acknowledge the CSV issue
          // but the underlying D&D problem is fixed by moving the functions outside.
          alert('Failed to load CSV: '+err.message);
          console.error(err);
        }
      }

      function populateFilterOptions(){
        regionSelect.innerHTML = '<option value="ALL">All Regions</option>';
        divisionSelect.innerHTML = '<option value="ALL">All Divisions</option>';
        cccSelect.innerHTML = '<option value="ALL">All CCCs</option>';

        Object.keys(HIER).forEach(rKey=>{
          const opt = document.createElement('option'); 
          opt.value = rKey; 
          opt.textContent = HIER[rKey].name; 
          regionSelect.appendChild(opt);
        });

        function fill(selectEl, values){
          selectEl.innerHTML = '<option value="ALL">All</option>';
          Array.from(values).filter(Boolean).sort().forEach(v=>{ 
            const o = document.createElement('option'); 
            o.value = v; 
            o.textContent = v; 
            selectEl.appendChild(o); 
          });
        }

        fill(baseClassSelect, new Set(rawData.map(d=>d.BASE_CLASS)));
        fill(categorySelect, new Set(rawData.map(d=>d.CATEGORY)));
        fill(meterSelect, new Set(rawData.map(d=>d.TYPE_OF_METER)));
        fill(phaseSelect, new Set(rawData.map(d=>d.CONN_PHASE)));
        fill(govtSelect, new Set(rawData.map(d=>d.GOVT_STAT)));
        fill(osbSelect, new Set(rawData.map(d=>d.OSB_GROUP)));
        fill(connBySelect, new Set(rawData.map(d=>d.CONN_BY)));

        regionSelect.onchange = onRegionChange;
        divisionSelect.onchange = onDivisionChange;
        cccSelect.onchange = applyFilters;
        baseClassSelect.onchange = applyFilters;
        categorySelect.onchange = applyFilters;
        meterSelect.onchange = applyFilters;
        phaseSelect.onchange = applyFilters;
        govtSelect.onchange = applyFilters;
        osbSelect.onchange = applyFilters;
        connBySelect.onchange = applyFilters;

        onRegionChange();
      }

      function onRegionChange(){
        const r = regionSelect.value;
        divisionSelect.innerHTML = '<option value="ALL">All Divisions</option>';
        cccSelect.innerHTML = '<option value="ALL">All CCCs</option>';

        if(r === 'ALL'){
          Object.keys(HIER).forEach(rKey=>{
            const region = HIER[rKey];
            Object.keys(region.divisions).forEach(dKey=>{
              const opt = document.createElement('option'); 
              opt.value = dKey; 
              opt.textContent = region.divisions[dKey].name + ' — ' + region.name; 
              divisionSelect.appendChild(opt);
            });
          });
        } else {
          const region = HIER[r];
          Object.keys(region.divisions).forEach(dKey=>{
            const opt = document.createElement('option'); 
            opt.value = dKey; 
            opt.textContent = region.divisions[dKey].name; 
            divisionSelect.appendChild(opt);
          });
        }

        applyFilters();
      }

      function onDivisionChange(){
        const d = divisionSelect.value;
        cccSelect.innerHTML = '<option value="ALL">All CCCs</option>';

        if(d === 'ALL'){
          const r = regionSelect.value;
          if(r === 'ALL'){
            Object.keys(HIER).forEach(rKey=>{
              const region = HIER[rKey];
              Object.keys(region.divisions).forEach(dKey=>{
                const div = region.divisions[dKey];
                Object.keys(div.cccs).forEach(cKey=>{
                  const opt = document.createElement('option'); 
                  opt.value = cKey; 
                  opt.textContent = div.cccs[cKey] + ' — ' + div.name; 
                  cccSelect.appendChild(opt);
                });
              });
            });
          } else {
            const region = HIER[r];
            Object.keys(region.divisions).forEach(dKey=>{
              const div = region.divisions[dKey];
              Object.keys(div.cccs).forEach(cKey=>{
                const opt = document.createElement('option'); 
                opt.value = cKey; 
                opt.textContent = div.cccs[cKey]; 
                cccSelect.appendChild(opt);
              });
            });
          }
        } else {
          for(const rKey of Object.keys(HIER)){
            if(HIER[rKey].divisions[d]){
              const div = HIER[rKey].divisions[d];
              Object.keys(div.cccs).forEach(cKey=>{
                const opt = document.createElement('option'); 
                opt.value = cKey; 
                opt.textContent = div.cccs[cKey]; 
                cccSelect.appendChild(opt);
              });
              break;
            }
          }
        }

        applyFilters();
      }

      function resetFilters(){
        regionSelect.value='ALL';
        onRegionChange();
        divisionSelect.value='ALL';
        onDivisionChange();
        cccSelect.value='ALL';
        baseClassSelect.value='ALL';
        categorySelect.value='ALL';
        meterSelect.value='ALL';
        phaseSelect.value='ALL';
        govtSelect.value='ALL';
        osbSelect.value='ALL';
        connBySelect.value='ALL';
        applyFilters();
      }

      function applyFilters(){
        const R = regionSelect.value;
        const D = divisionSelect.value;
        const C = cccSelect.value;

        filtered = rawData.filter(row=>{
          if(R !== 'ALL' && row.regionCode !== R) return false;
          if(D !== 'ALL' && row.divisionCode !== D) return false;
          if(C !== 'ALL' && row.cccCode !== C) return false;
          if(baseClassSelect.value !== 'ALL' && row.BASE_CLASS !== baseClassSelect.value) return false;
          if(categorySelect.value !== 'ALL' && row.CATEGORY !== categorySelect.value) return false;
          if(meterSelect.value !== 'ALL' && row.TYPE_OF_METER !== meterSelect.value) return false;
          if(phaseSelect.value !== 'ALL' && row.CONN_PHASE !== phaseSelect.value) return false;
          if(govtSelect.value !== 'ALL' && row.GOVT_STAT !== govtSelect.value) return false;
          if(osbSelect.value !== 'ALL' && row.OSB_GROUP !== osbSelect.value) return false;
          if(connBySelect.value !== 'ALL' && row.CONN_BY !== connBySelect.value) return false;
          return true;
        });

        document.getElementById('kpiCount').textContent = d3.sum(filtered, d=>d.COUNT).toLocaleString();
        document.getElementById('kpiLoad').textContent = d3.sum(filtered, d=>d.LOAD).toLocaleString();
        document.getElementById('kpiSD').textContent = d3.sum(filtered, d=>d.SD_LAKH).toLocaleString();
        document.getElementById('kpiOSD').textContent = d3.sum(filtered, d=>d.OSD_LAKH).toLocaleString();

        renderCharts();
        renderCustomTable();
      }
      
      function formatValue(value, format) {
        if (value === null || value === undefined) return '—';
        if (format === 'number') return Math.round(value).toLocaleString();
        if (format === 'decimal') return value.toFixed(2).toLocaleString();
        if (format === 'percent') return (value * 100).toFixed(2) + '%';
        return value.toString();
      }
      
      /**
       * Expands any 'pivot' fields in the selected list into their respective 'measure' fields.
       * @param {Array} fields - The current selectedFields array.
       * @returns {Array} The final list of fields to be rendered.
       */
      function getFinalRenderFields(fields) {
          const finalFields = [];
          
          fields.forEach(field => {
              if (field.type === 'pivot') {
                  // Find all measure fields related to this pivot key (e.g., GOVT_STAT_YES, GOVT_STAT_NO)
                  const pivotMeasures = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === field.key);
                  finalFields.push(...pivotMeasures);
              } else {
                  finalFields.push(field);
              }
          });
          return finalFields;
      }

      // --- Global Drag and Drop Handlers (FIXED: Defined in the main scope) ---
      
      function handleDragStart(e) {
          const key = this.dataset.key;
          const isSidebarItem = this.classList.contains('drag-item');
          
          e.dataTransfer.effectAllowed = 'copyMove';
          e.dataTransfer.setData('text/plain', key);
          e.dataTransfer.setData('source', isSidebarItem ? 'sidebar' : 'table');
          
          // For table headers, we need the original index in the selectedFields array, 
          // which is stored as the data-source-index attribute on the TH.
          if (!isSidebarItem) {
              const sourceIndex = this.dataset.sourceIndex;
              e.dataTransfer.setData('sourceIndex', sourceIndex);
          }
          this.classList.add('dragging');
      }

      function handleDragEnd(e) {
          this.classList.remove('dragging');
          // Clean up drop indicators
          document.querySelectorAll('.th-drop-left, .th-drop-right').forEach(el => el.classList.remove('th-drop-left', 'th-drop-right'));
          document.querySelectorAll('.field-list-wrap').forEach(el => el.classList.remove('table-drop-target'));
      }
      
      function handleTHDragOver(e) {
          e.preventDefault();
          e.stopPropagation(); 

          const targetTH = this;
          const rect = targetTH.getBoundingClientRect();
          const midpoint = rect.left + rect.width / 2;

          document.querySelectorAll('.th-drop-left, .th-drop-right').forEach(el => el.classList.remove('th-drop-left', 'th-drop-right'));

          // Determine if drop is on the left or right half
          if (e.clientX < midpoint) {
              targetTH.classList.add('th-drop-left');
              targetTH.classList.remove('th-drop-right');
          } else {
              targetTH.classList.add('th-drop-right');
              targetTH.classList.remove('th-drop-left');
          }
      }
      
      function handleTHDragLeave(e) {
          this.classList.remove('th-drop-left', 'th-drop-right');
      }
      
      function handleTHDrop(e) {
          e.preventDefault();
          e.stopPropagation();

          const key = e.dataTransfer.getData('text/plain');
          const source = e.dataTransfer.getData('source');
          const targetTH = this;
          
          // Get the index of the original field in selectedFields that generated this TH
          const targetIndex = parseInt(targetTH.dataset.sourceIndex); 

          const isLeft = targetTH.classList.contains('th-drop-left');
          // If dropping on the left side of a field, insert BEFORE that field (i.e., at its index).
          // If dropping on the right side, insert AFTER that field (i.e., at its index + 1).
          const insertionPoint = isLeft ? targetIndex : targetIndex + 1;
          
          targetTH.classList.remove('th-drop-left', 'th-drop-right');

          if (source === 'sidebar') {
              const field = ALL_FIELDS.find(f => f.key === key);
              // Only add if it's not already in the array (prevents duplication)
              if (field && !selectedFields.some(f => f.key === key)) {
                  selectedFields.splice(insertionPoint, 0, field);
              }
          } else if (source === 'table') {
              const sourceIndex = parseInt(e.dataTransfer.getData('sourceIndex'));
              if (sourceIndex !== -1 && sourceIndex !== targetIndex) {
                  const [movedField] = selectedFields.splice(sourceIndex, 1);
                  // Adjust insertion point because we just removed an item
                  const finalIndex = (insertionPoint > sourceIndex) ? insertionPoint - 1 : insertionPoint;
                  selectedFields.splice(finalIndex, 0, movedField);
              }
          }

          renderAvailableFields();
          renderCustomTable();
      }
      
      function handleSidebarDrop(e) {
        e.preventDefault();
        availableFieldsList.classList.remove('table-drop-target');
        const source = e.dataTransfer.getData('source');
        const key = e.dataTransfer.getData('text/plain');

        // This drop is only relevant for removing columns (source === 'table')
        if (source === 'table') {
            // Find the index of the field being removed (which is key)
            const index = selectedFields.findIndex(f => f.key === key);
            if (index > -1) {
                 selectedFields.splice(index, 1);
                 renderAvailableFields();
                 renderCustomTable();
            }
        }
      }
      
      function handleSidebarDragOver(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          const source = e.dataTransfer.getData('source');
          if (source === 'table') {
            availableFieldsList.classList.add('table-drop-target');
          }
      }

      function handleSidebarDragLeave(e) {
          availableFieldsList.classList.remove('table-drop-target');
      }
      
      // --- End Global Drag and Drop Handlers ---


      function renderCustomTable(){
        const table = document.getElementById('dataTable');
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        thead.innerHTML = '';
        tbody.innerHTML = '';
        
        // Fields for rendering (pivots expanded)
        const finalRenderFields = getFinalRenderFields(selectedFields);

        if(finalRenderFields.length === 0){
          thead.innerHTML = '<tr><th colspan="5" style="text-align: center;">Drag fields from the sidebar to create your report</th></tr>';
          return;
        }

        // 1. Build Header
        const headerRow = document.createElement('tr');
        let fieldCounter = 0; // Tracks the index in the original selectedFields array
        
        selectedFields.forEach((originalField, originalIndex) => {
          let renderFields;
          if (originalField.type === 'pivot') {
              renderFields = ALL_FIELDS.filter(f => f.isPivot && f.pivotKey === originalField.key);
          } else {
              renderFields = [originalField];
          }

          renderFields.forEach(field => {
            const th = document.createElement('th');
            th.textContent = field.label;
            // IMPORTANT: Store the index of the *original* field for drag-and-drop logic
            th.dataset.key = originalField.key; 
            th.dataset.sourceIndex = originalIndex;
            th.draggable = true; 
            
            // Attach listeners 
            th.addEventListener('dragstart', handleDragStart);
            th.addEventListener('dragover', handleTHDragOver);
            th.addEventListener('dragleave', handleTHDragLeave);
            th.addEventListener('drop', handleTHDrop);
            th.addEventListener('dragend', handleDragEnd);

            headerRow.appendChild(th);
          });
        });
        thead.appendChild(headerRow);
        
        // 2. Separate Dimensions and Measures (using original selectedFields)
        const dimensions = selectedFields.filter(f => f.type === 'dimension');
        const measures = selectedFields.filter(f => f.type === 'measure');
        const pivotField = selectedFields.find(f => f.type === 'pivot');
        
        if (dimensions.length === 0) {
            // Only measures (and potential pivot), single aggregated row
            const totalAgg = {
                COUNT: d3.sum(filtered, d => d.COUNT),
                LOAD: d3.sum(filtered, d => d.LOAD),
                SD_LAKH: d3.sum(filtered, d => d.SD_LAKH),
                OSD_LAKH: d3.sum(filtered, d => d.OSD_LAKH),
                Average_Load_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_Load_per_Consumer) : 0,
                Average_OSD_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_OSD_per_Consumer) : 0,
                Collection_Efficiency: filtered.length ? d3.mean(filtered, d => d.Collection_Efficiency) : 0,
            };
            
            // Add pivot aggregates if present
            if(pivotField) {
                 totalAgg['GOVT_STAT_YES'] = d3.sum(filtered.filter(d => d.GOVT_STAT === 'YES'), d => d.COUNT);
                 totalAgg['GOVT_STAT_NO'] = d3.sum(filtered.filter(d => d.GOVT_STAT === 'NO'), d => d.COUNT);
            }

            const tr = document.createElement('tr');
            finalRenderFields.forEach(field => {
                const td = document.createElement('td');
                td.textContent = formatValue(totalAgg[field.key], field.format);
                tr.appendChild(td);
            });
            if (finalRenderFields.length > 0) tbody.appendChild(tr);

        } else {
            // Dimensions and Measures (and potential pivot), aggregated data
            const dimKeys = dimensions.map(d => d.key);
            const aggregatedData = d3.rollups(
                filtered,
                v => {
                    const obj = {};
                    measures.forEach(m => {
                        if (m.key === 'COUNT' || m.key === 'LOAD' || m.key === 'SD_LAKH' || m.key === 'OSD_LAKH') {
                            obj[m.key] = d3.sum(v, d => d[m.key]);
                        } else if (m.key === 'Average_Load_per_Consumer' || m.key === 'Average_OSD_per_Consumer' || m.key === 'Collection_Efficiency') {
                            obj[m.key] = d3.mean(v, d => v.filter(row => row.COUNT > 0).length > 0 ? d[m.key] : 0); // Only average non-zero count rows
                        }
                    });
                    
                    // Add pivot measures to the rollup object
                    if(pivotField) {
                         obj['GOVT_STAT_YES'] = d3.sum(v.filter(d => d.GOVT_STAT === 'YES'), d => d.COUNT);
                         obj['GOVT_STAT_NO'] = d3.sum(v.filter(d => d.GOVT_STAT === 'NO'), d => d.COUNT);
                    }
                    
                    return obj;
                },
                ...dimKeys.map(key => d => d[key])
            );

            // 4. Transform rollups into flat array for table rendering
            const flatAggregatedData = [];
            function flatten(arr, currentDimensions) {
                if (!arr) return;
                arr.forEach(([key, value]) => {
                    const nextDimensions = [...currentDimensions, key];
                    if (Array.isArray(value)) {
                        flatten(value, nextDimensions);
                    } else {
                        const row = {};
                        dimKeys.forEach((k, i) => {
                            row[k] = nextDimensions[i];
                        });
                        Object.assign(row, value);
                        flatAggregatedData.push(row);
                    }
                });
            }
            flatten(aggregatedData, []);

            // 5. Render rows
            flatAggregatedData.forEach(row => {
                const tr = document.createElement('tr');
                finalRenderFields.forEach(field => {
                    const td = document.createElement('td');
                    let value = row[field.key];
                    td.textContent = formatValue(value, field.format);
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
        }
        
        if(tbody.children.length === 0 && finalRenderFields.length > 0) {
            tbody.innerHTML = `<tr><td colspan="${finalRenderFields.length}" class="empty-state">No data matches current filters for these columns.</td></tr>`;
        }
      }

      function initDragAndDrop() {
        // Initial setup for sidebar drop target (to remove columns)
        availableFieldsList.addEventListener('dragover', handleSidebarDragOver);
        availableFieldsList.addEventListener('dragleave', handleSidebarDragLeave);
        availableFieldsList.addEventListener('drop', handleSidebarDrop);

        renderAvailableFields();
      }

      function renderAvailableFields() {
        availableFieldsList.innerHTML = '';
        const selectedKeys = selectedFields.map(f => f.key);
        // Only show dimension and pivot fields in the sidebar
        const available = ALL_FIELDS.filter(f => (f.type === 'dimension' || f.type === 'pivot') && !selectedKeys.includes(f.key));

        if (available.length === 0) {
            availableFieldsList.innerHTML = '<div class="empty-state">All available fields are in use.</div>';
            return;
        }

        available.forEach(field => {
          const div = document.createElement('div');
          div.textContent = field.label;
          div.className = 'drag-item';
          div.draggable = true;
          div.dataset.key = field.key;
          div.addEventListener('dragstart', handleDragStart);
          div.addEventListener('dragend', handleDragEnd);
          availableFieldsList.appendChild(div);
        });
      }

      function renderCharts(){
        // Stacked bar chart
        const grouped = d3.rollup(
          filtered, 
          v=>d3.sum(v, d=>d.COUNT), 
          d=>d.BASE_CLASS, 
          d=>d.CATEGORY
        );
        
        const baseClasses = Array.from(new Set(filtered.map(d=>d.BASE_CLASS))).sort();
        const categories = Array.from(new Set(filtered.map(d=>d.CATEGORY))).sort();
        
        const datasets = categories.map(cat=>({ 
          label: cat, 
          data: baseClasses.map(b=> (grouped.get(b) && grouped.get(b).get(cat)) || 0),
          backgroundColor: d3.schemeSet3[categories.indexOf(cat) % d3.schemeSet3.length]
        }));

        const barCtx = document.getElementById('stackedBar').getContext('2d');
        if(stackedBarChart) stackedBarChart.destroy();
        stackedBarChart = new Chart(barCtx, { 
          type: 'bar', 
          data: { labels: baseClasses, datasets }, 
          options: { 
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { 
                position: 'bottom',
                labels: { color: '#9ca3af', font: { size: 11 } }
              } 
            }, 
            scales: { 
              x: { 
                stacked: true,
                ticks: { color: '#9ca3af', font: { size: 11 } },
                grid: { color: '#1f2937' }
              }, 
              y: { 
                stacked: true,
                ticks: { color: '#9ca3af', font: { size: 11 } },
                grid: { color: '#1f2937' }
              } 
            } 
          } 
        });

        // Pie chart - Meter
        const meterCounts = d3.rollup(filtered, v=>d3.sum(v, d=>d.COUNT), d=>d.TYPE_OF_METER);
        const meterLabels = Array.from(meterCounts.keys());
        const meterValues = Array.from(meterCounts.values());
        
        const meterCtx = document.getElementById('pieMeter').getContext('2d');
        if(pieMeterChart) pieMeterChart.destroy();
        pieMeterChart = new Chart(meterCtx, { 
          type: 'pie', 
          data: { 
            labels: meterLabels, 
            datasets: [{ 
              data: meterValues,
              backgroundColor: d3.schemeSet2
            }] 
          }, 
          options: { 
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { 
                position: 'right',
                labels: { color: '#9ca3af', font: { size: 10 } }
              } 
            } 
          } 
        });

        // Pie chart - Phase
        const phaseCounts = d3.rollup(filtered, v=>d3.sum(v, d=>d.COUNT), d=>d.CONN_PHASE);
        const phaseLabels = Array.from(phaseCounts.keys());
        const phaseValues = Array.from(phaseCounts.values());
        
        const phaseCtx = document.getElementById('piePhase').getContext('2d');
        if(piePhaseChart) piePhaseChart.destroy();
        piePhaseChart = new Chart(phaseCtx, { 
          type: 'pie', 
          data: { 
            labels: phaseLabels, 
            datasets: [{ 
              data: phaseValues,
              backgroundColor: d3.schemePastel1
            }] 
          }, 
          options: { 
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { 
                position: 'right',
                labels: { color: '#9ca3af', font: { size: 10 } }
              } 
            } 
          } 
        });
      }


      function exportFilteredCSV(){
        // Get the fields exactly as they will appear in the table columns
        const finalRenderFields = getFinalRenderFields(selectedFields);

        if(finalRenderFields.length === 0){
             alert('Please select columns for the table before exporting.');
             return;
        }

        const dimensions = selectedFields.filter(f => f.type === 'dimension');
        const measures = selectedFields.filter(f => f.type === 'measure');
        const pivotField = selectedFields.find(f => f.type === 'pivot');
        
        const exportKeys = finalRenderFields.map(f => f.key);
        const exportLabels = finalRenderFields.map(f => f.label);
        
        let exportRows = [];

        if (dimensions.length === 0) {
            const totalAgg = {
                COUNT: d3.sum(filtered, d => d.COUNT),
                LOAD: d3.sum(filtered, d => d.LOAD),
                SD_LAKH: d3.sum(filtered, d => d.SD_LAKH),
                OSD_LAKH: d3.sum(filtered, d => d.OSD_LAKH),
                Average_Load_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_Load_per_Consumer) : 0,
                Average_OSD_per_Consumer: filtered.length ? d3.mean(filtered, d => d.Average_OSD_per_Consumer) : 0,
                Collection_Efficiency: filtered.length ? d3.mean(filtered, d => d.Collection_Efficiency) : 0,
            };
            
            // Add pivot aggregates if present
            if(pivotField) {
                 totalAgg['GOVT_STAT_YES'] = d3.sum(filtered.filter(d => d.GOVT_STAT === 'YES'), d => d.COUNT);
                 totalAgg['GOVT_STAT_NO'] = d3.sum(filtered.filter(d => d.GOVT_STAT === 'NO'), d => d.COUNT);
            }
            
            exportRows.push(totalAgg);

        } else {
            const dimKeys = dimensions.map(d => d.key);
            const aggregatedData = d3.rollups(
                filtered,
                v => {
                    const obj = {};
                    measures.forEach(m => {
                        if (m.key === 'COUNT' || m.key === 'LOAD' || m.key === 'SD_LAKH' || m.key === 'OSD_LAKH') {
                            obj[m.key] = d3.sum(v, d => d[m.key]);
                        } else if (m.key === 'Average_Load_per_Consumer' || m.key === 'Average_OSD_per_Consumer' || m.key === 'Collection_Efficiency') {
                            obj[m.key] = d3.mean(v, d => v.filter(row => row.COUNT > 0).length > 0 ? d[m.key] : 0);
                        }
                    });
                    
                    // Add pivot measures to the rollup object
                    if(pivotField) {
                         obj['GOVT_STAT_YES'] = d3.sum(v.filter(d => d.GOVT_STAT === 'YES'), d => d.COUNT);
                         obj['GOVT_STAT_NO'] = d3.sum(v.filter(d => d.GOVT_STAT === 'NO'), d => d.COUNT);
                    }
                    
                    return obj;
                },
                ...dimKeys.map(key => d => d[key])
            );

            function flatten(arr, currentDimensions) {
                if (!arr) return;
                arr.forEach(([key, value]) => {
                    const nextDimensions = [...currentDimensions, key];
                    if (Array.isArray(value)) {
                        flatten(value, nextDimensions);
                    } else {
                        const row = {};
                        dimKeys.forEach((k, i) => {
                            row[k] = nextDimensions[i];
                        });
                        Object.assign(row, value);
                        exportRows.push(row);
                    }
                });
            }
            flatten(aggregatedData, []);
        }

        if(!exportRows.length){ 
          alert('No rows to export with current filters and columns'); 
          return; 
        }
        
        const csv = [exportLabels.join(',')]
          .concat(exportRows.map(r=> exportKeys.map(k=> JSON.stringify(formatValue(r[k], ALL_FIELDS.find(f => f.key === k).format || 'text'))).join(',')))
          .join('\n');
          
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); 
        a.href = url; 
        a.download = 'custom_ccc_report.csv'; 
        document.body.appendChild(a); 
        a.click(); 
        a.remove();
      }

      // Event listeners
      exportBtn.addEventListener('click', exportFilteredCSV);
      resetBtn.addEventListener('click', resetFilters);

      // Initial load
      loadData('https://docs.google.com/spreadsheets/d/e/2PACX-1vQT4ufTMHJGTUqNSqFSzz0q2x-ShM_WHlfSRxT4tVqA6GcaMK5g38PDLmcJR4JXuxLi-tKafW-Yxwdo/pub?gid=0&single=true&output=csv');

      // Resize handling
      window.addEventListener('resize', ()=>{
        if(stackedBarChart) stackedBarChart.resize(); 
        if(pieMeterChart) pieMeterChart.resize(); 
        if(piePhaseChart) piePhaseChart.resize();
      });

    } catch(e){
      console.error('Dashboard initialization failed:', e);
      document.body.innerHTML = '<div style="color:#ef4444;padding:24px;font-family:monospace"><strong>Dashboard Error:</strong><br><br>'+(e && e.stack ? e.stack : e) + '</div>';
    }
  </script>
</body>
</html>
